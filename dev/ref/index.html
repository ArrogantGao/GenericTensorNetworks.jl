<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>References · GraphTensorNetworks.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://Happy-Diode.github.io/GraphTensorNetworks.jl/ref/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><script src="../../copy.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/indigo.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">GraphTensorNetworks.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/IndependentSet/">Independent set problem</a></li><li><a class="tocitem" href="../tutorials/MaximalIS/">Maximal independent set problem</a></li><li><a class="tocitem" href="../tutorials/MaxCut/">Cutting problem</a></li><li><a class="tocitem" href="../tutorials/Matching/">Matching problem</a></li><li><a class="tocitem" href="../tutorials/PaintShop/">Binary paint shop problem</a></li><li><a class="tocitem" href="../tutorials/Coloring/">Coloring problem</a></li><li><a class="tocitem" href="../tutorials/Satisfiability/">Satisfiability problem</a></li><li><a class="tocitem" href="../tutorials/Others/">Other problems</a></li></ul></li><li><a class="tocitem" href="../performancetips/">Performance Tips</a></li><li class="is-active"><a class="tocitem" href>References</a><ul class="internal"><li><a class="tocitem" href="#Graph-problems"><span>Graph problems</span></a></li><li><a class="tocitem" href="#Properties"><span>Properties</span></a></li><li><a class="tocitem" href="#Element-Algebras"><span>Element Algebras</span></a></li><li><a class="tocitem" href="#Tensor-Network"><span>Tensor Network</span></a></li><li><a class="tocitem" href="#Others"><span>Others</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>References</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>References</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Happy-Diode/GraphTensorNetworks.jl/blob/master/docs/src/ref.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h1><h2 id="Graph-problems"><a class="docs-heading-anchor" href="#Graph-problems">Graph problems</a><a id="Graph-problems-1"></a><a class="docs-heading-anchor-permalink" href="#Graph-problems" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="GraphTensorNetworks.solve" href="#GraphTensorNetworks.solve"><code>GraphTensorNetworks.solve</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">solve(problem, property; usecuda=false, T=Float64)</code></pre><p>Solving a certain property of a graph problem.</p><p><strong>Positional Arguments</strong></p><ul><li><p><code>problem</code> is the graph problem with tensor network information,</p></li><li><p><code>property</code> is string specifying the task. Using the maximum independent set problem as an example, it can be one of</p><ul><li><p><a href="#GraphTensorNetworks.SizeMax"><code>SizeMax</code></a> for finding maximum set size,</p></li><li><p><a href="#GraphTensorNetworks.SizeMin"><code>SizeMin</code></a> for finding minimum set size,</p></li><li><p><a href="#GraphTensorNetworks.CountingMax"><code>CountingMax</code></a> for counting configurations with largest-K sizes,</p></li><li><p><a href="#GraphTensorNetworks.CountingMin"><code>CountingMin</code></a> for counting configurations with smallest-K sizes,</p></li><li><p><a href="#GraphTensorNetworks.CountingAll"><code>CountingAll</code></a> for counting all configurations,</p></li><li><p><a href="#GraphTensorNetworks.GraphPolynomial"><code>GraphPolynomial</code></a> for evaluating the graph polynomial,</p></li><li><p><a href="#GraphTensorNetworks.SingleConfigMax"><code>SingleConfigMax</code></a> for finding one maximum configuration,</p></li><li><p><a href="#GraphTensorNetworks.ConfigsMax"><code>ConfigsMax</code></a> for enumerating configurations with largest-K sizes,</p></li><li><p><a href="#GraphTensorNetworks.ConfigsMin"><code>ConfigsMin</code></a> for enumerating configurations with smallest-K sizes,</p></li><li><p><a href="#GraphTensorNetworks.ConfigsAll"><code>ConfigsAll</code></a> for enumerating all configurations,</p></li></ul></li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>usecuda</code> is a switch to use CUDA (if possible), user need to call statement <code>using CUDA</code> before turning on this switch.</li><li><code>T</code> is the &quot;base&quot; element type, sometimes can be used to reduce the memory cost.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/GraphTensorNetworks.jl/blob/ccb9c974c5bad95082bcae49f697ed127a627996/src/interfaces.jl#L192-L220">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphTensorNetworks.GraphProblem" href="#GraphTensorNetworks.GraphProblem"><code>GraphTensorNetworks.GraphProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GraphProblem</code></pre><p>The abstract base type of graph problems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/GraphTensorNetworks.jl/blob/ccb9c974c5bad95082bcae49f697ed127a627996/src/networks/networks.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphTensorNetworks.IndependentSet" href="#GraphTensorNetworks.IndependentSet"><code>GraphTensorNetworks.IndependentSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IndependentSet{CT&lt;:AbstractEinsum,WT&lt;:Union{UnWeighted, Vector}} &lt;: GraphProblem
IndependentSet(graph; weights=UnWeighted(), openvertices=(),
             optimizer=GreedyMethod(), simplifier=nothing)</code></pre><p>The <a href="https://psychic-meme-f4d866f8.pages.github.io/dev/tutorials/IndependentSet.html">independent set problem</a> in graph theory. In the constructor, <code>weights</code> are the weights of vertices. <code>openvertices</code> specifies labels for the output tensor. <code>optimizer</code> and <code>simplifier</code> are for tensor network optimization, check <a href="#OMEinsumContractionOrders.optimize_code"><code>optimize_code</code></a> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/GraphTensorNetworks.jl/blob/ccb9c974c5bad95082bcae49f697ed127a627996/src/networks/IndependentSet.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphTensorNetworks.MaximalIS" href="#GraphTensorNetworks.MaximalIS"><code>GraphTensorNetworks.MaximalIS</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MaximalIS{CT&lt;:AbstractEinsum,WT&lt;:Union{UnWeighted, Vector}} &lt;: GraphProblem
MaximalIS(graph; weights=UnWeighted(), openvertices=(),
             optimizer=GreedyMethod(), simplifier=nothing)</code></pre><p>The <a href="https://psychic-meme-f4d866f8.pages.github.io/dev/tutorials/MaximalIS.html">maximal independent set</a> problem. In the constructor, <code>weights</code> are the weights of vertices. <code>optimizer</code> and <code>simplifier</code> are for tensor network optimization, check <a href="#OMEinsumContractionOrders.optimize_code"><code>optimize_code</code></a> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/GraphTensorNetworks.jl/blob/ccb9c974c5bad95082bcae49f697ed127a627996/src/networks/MaximalIS.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphTensorNetworks.Matching" href="#GraphTensorNetworks.Matching"><code>GraphTensorNetworks.Matching</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Matching{CT&lt;:AbstractEinsum} &lt;: GraphProblem
Matching(graph; openvertices=(), optimizer=GreedyMethod(), simplifier=nothing)</code></pre><p>The <a href="https://psychic-meme-f4d866f8.pages.github.io/dev/tutorials/Matching.html">Vertex matching</a> problem. <code>optimizer</code> and <code>simplifier</code> are for tensor network optimization, check <a href="#OMEinsumContractionOrders.optimize_code"><code>optimize_code</code></a> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/GraphTensorNetworks.jl/blob/ccb9c974c5bad95082bcae49f697ed127a627996/src/networks/Matching.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphTensorNetworks.Coloring" href="#GraphTensorNetworks.Coloring"><code>GraphTensorNetworks.Coloring</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Coloring{K,CT&lt;:AbstractEinsum} &lt;: GraphProblem
Coloring{K}(graph; openvertices=(), optimizer=GreedyMethod(), simplifier=nothing)</code></pre><p>The <a href="https://psychic-meme-f4d866f8.pages.github.io/dev/tutorials/Coloring.html">Vertex Coloring</a> problem. <code>optimizer</code> and <code>simplifier</code> are for tensor network optimization, check <a href="#OMEinsumContractionOrders.optimize_code"><code>optimize_code</code></a> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/GraphTensorNetworks.jl/blob/ccb9c974c5bad95082bcae49f697ed127a627996/src/networks/Coloring.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphTensorNetworks.MaxCut" href="#GraphTensorNetworks.MaxCut"><code>GraphTensorNetworks.MaxCut</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MaxCut{CT&lt;:AbstractEinsum,WT&lt;:Union{UnWeighted, Vector}} &lt;: GraphProblem
MaxCut(graph; weights=UnWeighted(), openvertices=(),
            optimizer=GreedyMethod(), simplifier=nothing)</code></pre><p>The <a href="https://psychic-meme-f4d866f8.pages.github.io/dev/tutorials/MaxCut.html">cutting</a> problem (or spin glass problem). In the constructor, <code>weights</code> are the weights of edges. <code>optimizer</code> and <code>simplifier</code> are for tensor network optimization, check <a href="#OMEinsumContractionOrders.optimize_code"><code>optimize_code</code></a> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/GraphTensorNetworks.jl/blob/ccb9c974c5bad95082bcae49f697ed127a627996/src/networks/MaxCut.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphTensorNetworks.PaintShop" href="#GraphTensorNetworks.PaintShop"><code>GraphTensorNetworks.PaintShop</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PaintShop{CT&lt;:AbstractEinsum} &lt;: GraphProblem
PaintShop(sequence::AbstractVector; openvertices=(),
         optimizer=GreedyMethod(), simplifier=nothing)</code></pre><p>The <a href="https://psychic-meme-f4d866f8.pages.github.io/dev/tutorials/PaintShop.html">binary paint shop problem</a>. <code>optimizer</code> and <code>simplifier</code> are for tensor network optimization, check <a href="#OMEinsumContractionOrders.optimize_code"><code>optimize_code</code></a> for details.</p><p><strong>Example</strong></p><p>One can encode the paint shop problem <code>abaccb</code> as the following</p><pre><code class="language-julia-repl hljs">julia&gt; syms = collect(&quot;abaccb&quot;);

julia&gt; pb = PaintShop(syms);

julia&gt; solve(pb, SizeMin())[]
2.0ₜ

julia&gt; solve(pb, ConfigsMin())[].c.data
2-element Vector{StaticBitVector{3, 1}}:
 100
 011</code></pre><p>In our definition, we find the maximum number of unchanged color in this sequence, i.e. (n-1) - (minimum number of color changes) In the output of maximum configurations, the two configurations are defined on 5 bonds i.e. pairs of (i, i+1), <code>0</code> means color changed, while <code>1</code> means color not changed. If we denote two &quot;colors&quot; as <code>r</code> and <code>b</code>, then the optimal painting is <code>rbbbrr</code> or <code>brrrbb</code>, both change the colors twice.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/GraphTensorNetworks.jl/blob/ccb9c974c5bad95082bcae49f697ed127a627996/src/networks/PaintShop.jl#L1-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphTensorNetworks.set_packing" href="#GraphTensorNetworks.set_packing"><code>GraphTensorNetworks.set_packing</code></a> — <span class="docstring-category">Function</span></header><section><div><p>set_packing(sets; openvertices=(), optimizer=GreedyMethod(), simplifier=nothing)</p><p>Set packing is a generalization of independent set problem to hypergraphs. Calling this function will return you an <code>IndependentSet</code> instance. <code>sets</code> are a vector of vectors, each element being a vertex in the independent set problem. <code>optimizer</code> and <code>simplifier</code> are for tensor network optimization, check <code>optimize_code</code> for details.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; sets = [[1, 2, 5], [1, 3], [2, 4], [3, 6], [2, 3, 6]];  # each set is a vertex

julia&gt; gp = set_packing(sets);

julia&gt; res = best_solutions(gp; all=true)[]
(2, {10010, 00110, 01100})ₜ</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/GraphTensorNetworks.jl/blob/ccb9c974c5bad95082bcae49f697ed127a627996/src/networks/IndependentSet.jl#L54-L72">source</a></section></article><h4 id="Graph-Problem-Interfaces"><a class="docs-heading-anchor" href="#Graph-Problem-Interfaces">Graph Problem Interfaces</a><a id="Graph-Problem-Interfaces-1"></a><a class="docs-heading-anchor-permalink" href="#Graph-Problem-Interfaces" title="Permalink"></a></h4><p>To subtype <a href="#GraphTensorNetworks.GraphProblem"><code>GraphProblem</code></a>, a new type must contain a <code>code</code> field to represent the (optimized) tensor network. Interfaces <a href="#GraphTensorNetworks.generate_tensors"><code>GraphTensorNetworks.generate_tensors</code></a>, <a href="#GraphTensorNetworks.labels"><code>labels</code></a>, <a href="#GraphTensorNetworks.flavors"><code>flavors</code></a> and <a href="#GraphTensorNetworks.get_weights"><code>get_weights</code></a> are required. <a href="#GraphTensorNetworks.nflavor"><code>nflavor</code></a> is optional.</p><article class="docstring"><header><a class="docstring-binding" id="GraphTensorNetworks.generate_tensors" href="#GraphTensorNetworks.generate_tensors"><code>GraphTensorNetworks.generate_tensors</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">generate_tensors(func, problem::GraphProblem)</code></pre><p>Generate a vector of tensors as the inputs of the tensor network contraction code <code>problem.code</code>. <code>func</code> is a function to customize the tensors. <code>func(symbol)</code> returns a vector of elements, the length of which is same as the number of flavors.</p><p><strong>Example</strong></p><p>The following code gives your the maximum independent set size</p><pre><code class="language-julia-repl hljs">julia&gt; using Graphs, GraphTensorNetworks

julia&gt; gp = IndependentSet(smallgraph(:petersen));

julia&gt; getixsv(gp.code)
25-element Vector{Vector{Int64}}:
 [1]
 [2]
 [3]
 [4]
 [5]
 [6]
 [7]
 [8]
 [9]
 [10]
 ⋮
 [3, 8]
 [4, 5]
 [4, 9]
 [5, 10]
 [6, 8]
 [6, 9]
 [7, 9]
 [7, 10]
 [8, 10]

julia&gt; gp.code(GraphTensorNetworks.generate_tensors(Tropical(1.0), gp)...)
0-dimensional Array{TropicalF64, 0}:
4.0ₜ</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/GraphTensorNetworks.jl/blob/ccb9c974c5bad95082bcae49f697ed127a627996/src/networks/networks.jl#L55-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphTensorNetworks.labels" href="#GraphTensorNetworks.labels"><code>GraphTensorNetworks.labels</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">labels(problem::GraphProblem)</code></pre><p>The labels of a graph problem is defined as the degrees of freedoms in the graph problem. e.g. for the maximum independent set problems, they are the indices of vertices: 1, 2, 3..., while for the max cut problem, they are the edges.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/GraphTensorNetworks.jl/blob/ccb9c974c5bad95082bcae49f697ed127a627996/src/networks/networks.jl#L21-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphTensorNetworks.flavors" href="#GraphTensorNetworks.flavors"><code>GraphTensorNetworks.flavors</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">flavors(::Type{&lt;:GraphProblem})</code></pre><p>It returns a vector of integers as the flavors of a degree of freedom. Its size is the same as the degree of freedom on a single vertex/edge.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/GraphTensorNetworks.jl/blob/ccb9c974c5bad95082bcae49f697ed127a627996/src/networks/networks.jl#L39-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphTensorNetworks.get_weights" href="#GraphTensorNetworks.get_weights"><code>GraphTensorNetworks.get_weights</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_weights(problem::GraphProblem, sym)</code></pre><p>The weights for the degree of freedom specified by <code>sym</code> of the graph problem, where <code>sym</code> is a symbol. In graph polynomial, integer weights are the orders of <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/GraphTensorNetworks.jl/blob/ccb9c974c5bad95082bcae49f697ed127a627996/src/networks/networks.jl#L13-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphTensorNetworks.nflavor" href="#GraphTensorNetworks.nflavor"><code>GraphTensorNetworks.nflavor</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">nflavor(::Type{&lt;:GraphProblem})</code></pre><p>Bond size is equal to the number of flavors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/GraphTensorNetworks.jl/blob/ccb9c974c5bad95082bcae49f697ed127a627996/src/networks/networks.jl#L47-L51">source</a></section></article><h4 id="Graph-Problem-Utilities"><a class="docs-heading-anchor" href="#Graph-Problem-Utilities">Graph Problem Utilities</a><a id="Graph-Problem-Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Graph-Problem-Utilities" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="GraphTensorNetworks.is_independent_set" href="#GraphTensorNetworks.is_independent_set"><code>GraphTensorNetworks.is_independent_set</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_independent_set(g::SimpleGraph, config)</code></pre><p>Return true if <code>config</code> (a vector of boolean numbers as the mask of vertices) is an independent set of graph <code>g</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/GraphTensorNetworks.jl/blob/ccb9c974c5bad95082bcae49f697ed127a627996/src/networks/IndependentSet.jl#L99-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphTensorNetworks.mis_compactify!" href="#GraphTensorNetworks.mis_compactify!"><code>GraphTensorNetworks.mis_compactify!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mis_compactify!(tropicaltensor)</code></pre><p>Compactify tropical tensor for maximum independent set problem. It will eliminate some entries by setting them to zero, by the criteria that removing these entry does not change the MIS size of its parent graph (reference to be added).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/GraphTensorNetworks.jl/blob/ccb9c974c5bad95082bcae49f697ed127a627996/src/networks/IndependentSet.jl#L79-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphTensorNetworks.is_maximal_independent_set" href="#GraphTensorNetworks.is_maximal_independent_set"><code>GraphTensorNetworks.is_maximal_independent_set</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_maximal_independent_set(g::SimpleGraph, config)</code></pre><p>Return true if <code>config</code> (a vector of boolean numbers as the mask of vertices) is a maximal independent set of graph <code>g</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/GraphTensorNetworks.jl/blob/ccb9c974c5bad95082bcae49f697ed127a627996/src/networks/MaximalIS.jl#L43-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphTensorNetworks.cut_size" href="#GraphTensorNetworks.cut_size"><code>GraphTensorNetworks.cut_size</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">cut_size(g::SimpleGraph, config; weights=UnWeighted())</code></pre><p>Compute the cut size from vertex <code>config</code> (an iterator).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/GraphTensorNetworks.jl/blob/ccb9c974c5bad95082bcae49f697ed127a627996/src/networks/MaxCut.jl#L36-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphTensorNetworks.num_paint_shop_color_switch" href="#GraphTensorNetworks.num_paint_shop_color_switch"><code>GraphTensorNetworks.num_paint_shop_color_switch</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">num_paint_shop_color_switch(sequence::AbstractVector, coloring)</code></pre><p>Returns the number of color switches.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/GraphTensorNetworks.jl/blob/ccb9c974c5bad95082bcae49f697ed127a627996/src/networks/PaintShop.jl#L77-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphTensorNetworks.paint_shop_coloring_from_config" href="#GraphTensorNetworks.paint_shop_coloring_from_config"><code>GraphTensorNetworks.paint_shop_coloring_from_config</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">paint_shop_coloring_from_config(p::PaintShop, config)</code></pre><p>Returns a valid painting from the paint shop configuration (given by the configuration solvers). The <code>config</code> is a sequence of 0 and 1, where 0 means painting the first appearence of a car in blue, 1 otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/GraphTensorNetworks.jl/blob/ccb9c974c5bad95082bcae49f697ed127a627996/src/networks/PaintShop.jl#L86-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphTensorNetworks.is_good_vertex_coloring" href="#GraphTensorNetworks.is_good_vertex_coloring"><code>GraphTensorNetworks.is_good_vertex_coloring</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_good_vertex_coloring(graph::SimpleGraph, config)</code></pre><p>Returns true if the coloring specified by config is a valid one, i.e. does not violate the contraints of vertices of an edges having different colors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/GraphTensorNetworks.jl/blob/ccb9c974c5bad95082bcae49f697ed127a627996/src/networks/Coloring.jl#L45-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphTensorNetworks.CNF" href="#GraphTensorNetworks.CNF"><code>GraphTensorNetworks.CNF</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CNF{T}
CNF(clauses)</code></pre><p>Boolean expression in <a href="https://en.wikipedia.org/wiki/Conjunctive_normal_form">conjunctive normal form</a>. <code>clauses</code> is a vector of <a href="#GraphTensorNetworks.CNFClause"><code>CNFClause</code></a>, if and only if all clauses are satisfied, this CNF is satisfied.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @bools x y z

julia&gt; cnf = (x ∨ y) ∧ (¬y ∨ z)
(x ∨ y) ∧ (¬y ∨ z)

julia&gt; satisfiable(cnf, Dict([:x=&gt;true, :y=&gt;false, :z=&gt;true]))
true

julia&gt; satisfiable(cnf, Dict([:x=&gt;false, :y=&gt;false, :z=&gt;true]))
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/GraphTensorNetworks.jl/blob/ccb9c974c5bad95082bcae49f697ed127a627996/src/networks/Satisfiability.jl#L31-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphTensorNetworks.CNFClause" href="#GraphTensorNetworks.CNFClause"><code>GraphTensorNetworks.CNFClause</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CNFClause{T}
CNFClause(vars)</code></pre><p>A clause in <a href="#GraphTensorNetworks.CNF"><code>CNF</code></a>, its value is the logical or of <code>vars</code>, where <code>vars</code> is a vector of <a href="#GraphTensorNetworks.BoolVar"><code>BoolVar</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/GraphTensorNetworks.jl/blob/ccb9c974c5bad95082bcae49f697ed127a627996/src/networks/Satisfiability.jl#L17-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphTensorNetworks.BoolVar" href="#GraphTensorNetworks.BoolVar"><code>GraphTensorNetworks.BoolVar</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BoolVar{T}
BoolVar(name, neg)</code></pre><p>Boolean variable for constructing CNF clauses.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/GraphTensorNetworks.jl/blob/ccb9c974c5bad95082bcae49f697ed127a627996/src/networks/Satisfiability.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphTensorNetworks.satisfiable" href="#GraphTensorNetworks.satisfiable"><code>GraphTensorNetworks.satisfiable</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">satisfiable(cnf::CNF, config::AbstractDict)</code></pre><p>Returns true if an assignment of variables satisfies a <a href="#GraphTensorNetworks.CNF"><code>CNF</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/GraphTensorNetworks.jl/blob/ccb9c974c5bad95082bcae49f697ed127a627996/src/networks/Satisfiability.jl#L130-L134">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphTensorNetworks.@bools" href="#GraphTensorNetworks.@bools"><code>GraphTensorNetworks.@bools</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@bools(syms::Symbol...)</code></pre><p>Create some boolean variables of type <a href="#GraphTensorNetworks.BoolVar"><code>BoolVar</code></a> in current scope that can be used in create a <a href="#GraphTensorNetworks.CNF"><code>CNF</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @bools x y z

julia&gt; (x ∨ y) ∧ (¬y ∨ z)
(x ∨ y) ∧ (¬y ∨ z)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/GraphTensorNetworks.jl/blob/ccb9c974c5bad95082bcae49f697ed127a627996/src/networks/Satisfiability.jl#L88-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphTensorNetworks.:∨" href="#GraphTensorNetworks.:∨"><code>GraphTensorNetworks.:∨</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">∨(vars...)</code></pre><p>Logical or that applied on <a href="#GraphTensorNetworks.BoolVar"><code>BoolVar</code></a> and <a href="#GraphTensorNetworks.CNFClause"><code>CNFClause</code></a> and returns a [<code>CNFClause</code>].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/GraphTensorNetworks.jl/blob/ccb9c974c5bad95082bcae49f697ed127a627996/src/networks/Satisfiability.jl#L68-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphTensorNetworks.:¬" href="#GraphTensorNetworks.:¬"><code>GraphTensorNetworks.:¬</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">¬(var::BoolVar)</code></pre><p>Negation of a boolean variables of type <a href="#GraphTensorNetworks.BoolVar"><code>BoolVar</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/GraphTensorNetworks.jl/blob/ccb9c974c5bad95082bcae49f697ed127a627996/src/networks/Satisfiability.jl#L61-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphTensorNetworks.:∧" href="#GraphTensorNetworks.:∧"><code>GraphTensorNetworks.:∧</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">∧(vars...)</code></pre><p>Logical and applied on <a href="#GraphTensorNetworks.CNFClause"><code>CNFClause</code></a> and <a href="#GraphTensorNetworks.CNF"><code>CNF</code></a> and returns a new [<code>CNF</code>].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/GraphTensorNetworks.jl/blob/ccb9c974c5bad95082bcae49f697ed127a627996/src/networks/Satisfiability.jl#L78-L82">source</a></section></article><h2 id="Properties"><a class="docs-heading-anchor" href="#Properties">Properties</a><a id="Properties-1"></a><a class="docs-heading-anchor-permalink" href="#Properties" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="GraphTensorNetworks.SizeMax" href="#GraphTensorNetworks.SizeMax"><code>GraphTensorNetworks.SizeMax</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SizeMax &lt;: AbstractProperty
SizeMax()</code></pre><p>The maximum set size. e.g. the largest size of the <a href="#GraphTensorNetworks.IndependentSet"><code>IndependentSet</code></a>  problem is also know as the independence number.</p><ul><li>The corresponding tensor element type is max-plus tropical number <a href="#TropicalNumbers.Tropical"><code>Tropical</code></a>.</li><li>It is compatible with weighted graph problems.</li><li>BLAS (on CPU) and GPU are supported,</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/GraphTensorNetworks.jl/blob/ccb9c974c5bad95082bcae49f697ed127a627996/src/interfaces.jl#L3-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphTensorNetworks.SizeMin" href="#GraphTensorNetworks.SizeMin"><code>GraphTensorNetworks.SizeMin</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SizeMin &lt;: AbstractProperty
SizeMin()</code></pre><p>The maximum set size. e.g. the smallest size ofthe <a href="#GraphTensorNetworks.MaximalIS"><code>MaximalIS</code></a> problem is also known as the independent domination number.</p><ul><li>The corresponding tensor element type inverted max-plus tropical number <a href="#TropicalNumbers.Tropical"><code>Tropical</code></a>, which is equivalent to the min-plus tropical number.</li><li>It is compatible with weighted graph problems.</li><li>BLAS (on CPU) and GPU are supported,</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/GraphTensorNetworks.jl/blob/ccb9c974c5bad95082bcae49f697ed127a627996/src/interfaces.jl#L15-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphTensorNetworks.CountingAll" href="#GraphTensorNetworks.CountingAll"><code>GraphTensorNetworks.CountingAll</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CountingAll &lt;: AbstractProperty
CountingAll()</code></pre><p>Counting the total number of sets. e.g. for the <a href="#GraphTensorNetworks.IndependentSet"><code>IndependentSet</code></a> problem, it counts the independent sets.</p><ul><li>The corresponding tensor element type is <code>Base.Real</code>.</li><li>The weights on graph does not have effect.</li><li>BLAS (GPU and CPU) and GPU are supported,</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/GraphTensorNetworks.jl/blob/ccb9c974c5bad95082bcae49f697ed127a627996/src/interfaces.jl#L27-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphTensorNetworks.CountingMax" href="#GraphTensorNetworks.CountingMax"><code>GraphTensorNetworks.CountingMax</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CountingMax{K} &lt;: AbstractProperty
CountingMax(K=1)</code></pre><p>Counting the number of sets with largest-K size. e.g. for <a href="#GraphTensorNetworks.IndependentSet"><code>IndependentSet</code></a> problem, it counts independent sets of size <span>$\alpha(G), \alpha(G)-1, \ldots, \alpha(G)-K+1$</span>.</p><ul><li>The corresponding tensor element type is <a href="#TropicalNumbers.CountingTropical"><code>CountingTropical</code></a> for <code>K == 1</code>, and <a href="#GraphTensorNetworks.TruncatedPoly"><code>TruncatedPoly</code></a><code>{K}</code> for <code>K &gt; 1</code>.</li><li>Weighted graph problems is only supported for <code>K == 1</code>.</li><li>GPU is supported,</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/GraphTensorNetworks.jl/blob/ccb9c974c5bad95082bcae49f697ed127a627996/src/interfaces.jl#L39-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphTensorNetworks.CountingMin" href="#GraphTensorNetworks.CountingMin"><code>GraphTensorNetworks.CountingMin</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CountingMin{K} &lt;: AbstractProperty
CountingMin(K=1)</code></pre><p>Counting the number of sets with smallest-K size.</p><ul><li>The corresponding tensor element type is inverted <a href="#TropicalNumbers.CountingTropical"><code>CountingTropical</code></a> for <code>K == 1</code>, and <a href="#GraphTensorNetworks.TruncatedPoly"><code>TruncatedPoly</code></a><code>{K}</code> for <code>K &gt; 1</code>.</li><li>Weighted graph problems is only supported for <code>K == 1</code>.</li><li>GPU is supported,</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/GraphTensorNetworks.jl/blob/ccb9c974c5bad95082bcae49f697ed127a627996/src/interfaces.jl#L54-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphTensorNetworks.GraphPolynomial" href="#GraphTensorNetworks.GraphPolynomial"><code>GraphTensorNetworks.GraphPolynomial</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GraphPolynomial{METHOD} &lt;: AbstractProperty
GraphPolynomial(; method=:finitefield, kwargs...)</code></pre><p>Compute the graph polynomial, e.g. for <a href="#GraphTensorNetworks.IndependentSet"><code>IndependentSet</code></a> problem, it is the independence polynomial. The <code>METHOD</code> type parameter can be one of the following symbols</p><p><strong>Method Argument</strong></p><ul><li><code>:finitefield</code>, uses finite field algebra to fit the polynomial.<ul><li>The corresponding tensor element type is <a href="#Mods.Mod"><code>Mods.Mod</code></a>,</li><li>It does not have round-off error,</li><li>GPU is supported,</li><li>It accepts keyword arguments <code>maxorder</code> (optional, e.g. the MIS size in the <a href="#GraphTensorNetworks.IndependentSet"><code>IndependentSet</code></a> problem).</li></ul></li><li><code>:polynomial</code>, use polynomial numbers to solve the polynomial directly.<ul><li>The corresponding tensor element type is <a href="#Polynomials.Polynomial"><code>Polynomials.Polynomial</code></a>.</li><li>It might have small round-off error depending on the data type for storing the counting.</li><li>It has memory overhead that linear to the graph size.</li></ul></li><li><code>:fft</code>, use fast fourier transformation to fit the polynomial.<ul><li>The corresponding tensor element type is <code>Base.Complex</code>.</li><li>It has (controllable) round-off error.</li><li>BLAS and GPU are supported.</li><li>It accepts keyword arguments <code>maxorder</code> (optional) and <code>r</code>,   if <code>r &gt; 1</code>, one has better precision for coefficients of large order, if <code>r &lt; 1</code>,   one has better precision for coefficients of small order.</li></ul></li></ul><p>Graph polynomials are not defined for weighted graph problems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/GraphTensorNetworks.jl/blob/ccb9c974c5bad95082bcae49f697ed127a627996/src/interfaces.jl#L68-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphTensorNetworks.SingleConfigMax" href="#GraphTensorNetworks.SingleConfigMax"><code>GraphTensorNetworks.SingleConfigMax</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SingleConfigMax{BOUNDED} &lt;: AbstractProperty
SingleConfigMax(; bounded=false)</code></pre><p>Finding single best solution, e.g. for <a href="#GraphTensorNetworks.IndependentSet"><code>IndependentSet</code></a> problem, it is one of the maximum independent sets.</p><ul><li>The corresponding data type is <a href="#TropicalNumbers.CountingTropical"><code>CountingTropical{Float64,&lt;:ConfigSampler}</code></a> if <code>BOUNDED</code> is <code>false</code>, <a href="#TropicalNumbers.Tropical"><code>Tropical</code></a> otherwise.</li><li>Weighted graph problems is supported.</li><li>GPU is supported,</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>bounded</code>, if it is true, use bounding trick (or boolean gradients) to reduce the working memory to store intermediate configurations.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/GraphTensorNetworks.jl/blob/ccb9c974c5bad95082bcae49f697ed127a627996/src/interfaces.jl#L102-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphTensorNetworks.SingleConfigMin" href="#GraphTensorNetworks.SingleConfigMin"><code>GraphTensorNetworks.SingleConfigMin</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SingleConfigMin{BOUNDED} &lt;: AbstractProperty
SingleConfigMin(; bounded=false)</code></pre><p>Finding single &quot;worst&quot; solution.</p><ul><li>The corresponding data type is inverted <a href="#TropicalNumbers.CountingTropical"><code>CountingTropical{Float64,&lt;:ConfigSampler}</code></a> if <code>BOUNDED</code> is <code>false</code>, inverted <a href="#TropicalNumbers.Tropical"><code>Tropical</code></a> otherwise.</li><li>Weighted graph problems is supported.</li><li>GPU is supported,</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>bounded</code>, if it is true, use bounding trick (or boolean gradients) to reduce the working memory to store intermediate configurations.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/GraphTensorNetworks.jl/blob/ccb9c974c5bad95082bcae49f697ed127a627996/src/interfaces.jl#L119-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphTensorNetworks.ConfigsAll" href="#GraphTensorNetworks.ConfigsAll"><code>GraphTensorNetworks.ConfigsAll</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ConfigsAll{TREESTORAGE} &lt;:AbstractProperty
ConfigsAll(; tree_storage=false)</code></pre><p>Find all valid configurations, e.g. for <a href="#GraphTensorNetworks.IndependentSet"><code>IndependentSet</code></a> problem, it is finding all independent sets.</p><ul><li>The corresponding data type is <a href="#GraphTensorNetworks.ConfigEnumerator"><code>ConfigEnumerator</code></a>.</li><li>Weights do not take effect.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>tree_storage</code>, if it is true, it uses more memory efficient tree-structure to store the configurations.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/GraphTensorNetworks.jl/blob/ccb9c974c5bad95082bcae49f697ed127a627996/src/interfaces.jl#L136-L148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphTensorNetworks.ConfigsMax" href="#GraphTensorNetworks.ConfigsMax"><code>GraphTensorNetworks.ConfigsMax</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ConfigsMax{K, BOUNDED, TREESTORAGE} &lt;:AbstractProperty
ConfigsMax(K=1; bounded=true, tree_storage=true)</code></pre><p>Find configurations with largest-K sizes, e.g. for <a href="#GraphTensorNetworks.IndependentSet"><code>IndependentSet</code></a> problem, it is finding all independent sets of sizes <span>$\alpha(G), \alpha(G)-1, \ldots, \alpha(G)-K+1$</span>.</p><ul><li>The corresponding data type is <a href="#TropicalNumbers.CountingTropical"><code>CountingTropical</code></a><code>{Float64,&lt;:ConfigEnumerator}</code> for <code>K == 1</code> and <a href="#GraphTensorNetworks.TruncatedPoly"><code>TruncatedPoly</code></a><code>{K,&lt;:ConfigEnumerator}</code> for <code>K &gt; 1</code>.</li><li>Weighted graph problems is only supported for <code>K == 1</code>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>bounded</code>, if it is true, use bounding trick (or boolean gradients) to reduce the working memory to store intermediate configurations.</li><li><code>tree_storage</code>, if it is true, it uses more memory efficient tree-structure to store the configurations.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/GraphTensorNetworks.jl/blob/ccb9c974c5bad95082bcae49f697ed127a627996/src/interfaces.jl#L153-L167">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphTensorNetworks.ConfigsMin" href="#GraphTensorNetworks.ConfigsMin"><code>GraphTensorNetworks.ConfigsMin</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ConfigsMin{K, BOUNDED, TREESTORAGE} &lt;:AbstractProperty
ConfigsMin(K=1; bounded=true, tree_storage=false)</code></pre><p>Find configurations with smallest-K sizes.</p><ul><li>The corresponding data type is inverted <a href="#TropicalNumbers.CountingTropical"><code>CountingTropical</code></a><code>{Float64,&lt;:ConfigEnumerator}</code> for <code>K == 1</code> and inverted <a href="#GraphTensorNetworks.TruncatedPoly"><code>TruncatedPoly</code></a><code>{K,&lt;:ConfigEnumerator}</code> for <code>K &gt; 1</code>.</li><li>Weighted graph problems is only supported for <code>K == 1</code>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>bounded</code>, if it is true, use bounding trick (or boolean gradients) to reduce the working memory to store intermediate configurations.</li><li><code>tree_storage</code>, if it is true, it uses more memory efficient tree-structure to store the configurations.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/GraphTensorNetworks.jl/blob/ccb9c974c5bad95082bcae49f697ed127a627996/src/interfaces.jl#L173-L186">source</a></section></article><h2 id="Element-Algebras"><a class="docs-heading-anchor" href="#Element-Algebras">Element Algebras</a><a id="Element-Algebras-1"></a><a class="docs-heading-anchor-permalink" href="#Element-Algebras" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="GraphTensorNetworks.is_commutative_semiring" href="#GraphTensorNetworks.is_commutative_semiring"><code>GraphTensorNetworks.is_commutative_semiring</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_commutative_semiring(a::T, b::T, c::T) where T</code></pre><p>Check if elements <code>a</code>, <code>b</code> and <code>c</code> satisfied the commutative semiring requirements.</p><p class="math-container">\[\begin{align*}
(a \oplus b) \oplus c = a \oplus (b \oplus c) &amp; \hspace{5em}\triangleright\text{commutative monoid $\oplus$ with identity $\mathbb{0}$}\\
a \oplus \mathbb{0} = \mathbb{0} \oplus a = a &amp;\\
a \oplus b = b \oplus a &amp;\\
&amp;\\
(a \odot b) \odot c = a \odot (b \odot c)  &amp;   \hspace{5em}\triangleright \text{commutative monoid $\odot$ with identity $\mathbb{1}$}\\
a \odot  \mathbb{1} =  \mathbb{1} \odot a = a &amp;\\
a \odot b = b \odot a &amp;\\
&amp;\\
a \odot (b\oplus c) = a\odot b \oplus a\odot c  &amp;  \hspace{5em}\triangleright \text{left and right distributive}\\
(a\oplus b) \odot c = a\odot c \oplus b\odot c &amp;\\
&amp;\\
a \odot \mathbb{0} = \mathbb{0} \odot a = \mathbb{0}
\end{align*}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/GraphTensorNetworks.jl/blob/ccb9c974c5bad95082bcae49f697ed127a627996/src/arithematics.jl#L14-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TropicalNumbers.Tropical" href="#TropicalNumbers.Tropical"><code>TropicalNumbers.Tropical</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Tropical{T} &lt;: Number</code></pre><p><a href="https://en.wikipedia.org/wiki/Tropical_geometry">Tropical number</a> is a semiring algebra that maps</p><ul><li><code>+</code> in regular algebra to <code>max</code>,</li><li><code>*</code> in regular algebra to <code>+</code>,</li><li><code>1</code> in regular algebra to <code>0</code>,</li><li><code>0</code> in regular algebra to <code>-Inf</code> (for integer content types, this is chosen as a mall integer).</li></ul><p>We implemented fast tropical matrix multiplication in <a href="https://github.com/TensorBFS/TropicalGEMM.jl/"><code>TropicalGEMM</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Tropical(1.0) + Tropical(3.0)
3.0ₜ

julia&gt; Tropical(1.0) * Tropical(3.0)
4.0ₜ

julia&gt; one(TropicalF64)
0.0ₜ

julia&gt; zero(TropicalF64)
-Infₜ</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TropicalNumbers.CountingTropical" href="#TropicalNumbers.CountingTropical"><code>TropicalNumbers.CountingTropical</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CountingTropical{T,CT} &lt;: Number</code></pre><p>Counting tropical number type is also a semiring algebra. It is tropical algebra with one extra field for counting, it is introduced in <a href="https://arxiv.org/abs/2008.06888">arXiv:2008.06888</a>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; CountingTropical(1.0, 5.0) + CountingTropical(3.0, 2.0)
(3.0, 2.0)ₜ

julia&gt; CountingTropical(1.0, 5.0) * CountingTropical(3.0, 2.0)
(4.0, 10.0)ₜ

julia&gt; one(CountingTropicalF64)
(0.0, 1.0)ₜ

julia&gt; zero(CountingTropicalF64)
(-Inf, 0.0)ₜ</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Mods.Mod" href="#Mods.Mod"><code>Mods.Mod</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>Mod{m}(v)</code> creates a modular number in mod <code>m</code> with value <code>mod(v,m)</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Polynomials.Polynomial" href="#Polynomials.Polynomial"><code>Polynomials.Polynomial</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Polynomial{T, X}(coeffs::AbstractVector{T}, [var = :x])</code></pre><p>Construct a polynomial from its coefficients <code>coeffs</code>, lowest order first, optionally in terms of the given variable <code>var</code> which may be a character, symbol, or a string.</p><p>If <span>$p = a_n x^n + \ldots + a_2 x^2 + a_1 x + a_0$</span>, we construct this through <code>Polynomial([a_0, a_1, ..., a_n])</code>.</p><p>The usual arithmetic operators are overloaded to work with polynomials as well as with combinations of polynomials and scalars. However, operations involving two polynomials of different variables causes an error except those involving a constant polynomial.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>Polynomial</code> is not axis-aware, and it treats <code>coeffs</code> simply as a list of coefficients with the first index always corresponding to the constant term. In order to use the axis of <code>coeffs</code> as exponents, consider using a <a href="@ref"><code>LaurentPolynomial</code></a> or possibly a <a href="@ref"><code>SparsePolynomial</code></a>.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Polynomials

julia&gt; Polynomial([1, 0, 3, 4])
Polynomial(1 + 3*x^2 + 4*x^3)

julia&gt; Polynomial([1, 2, 3], :s)
Polynomial(1 + 2*s + 3*s^2)

julia&gt; one(Polynomial)
Polynomial(1.0)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphTensorNetworks.TruncatedPoly" href="#GraphTensorNetworks.TruncatedPoly"><code>GraphTensorNetworks.TruncatedPoly</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TruncatedPoly{K,T,TO} &lt;: Number
TruncatedPoly(coeffs::Tuple, maxorder)</code></pre><p>Polynomial truncated to largest <code>K</code> orders. <code>T</code> is the coefficients type and <code>TO</code> is the orders type.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; TruncatedPoly((1,2,3), 6)
x^4 + 2*x^5 + 3*x^6

julia&gt; TruncatedPoly((1,2,3), 6) * TruncatedPoly((5,2,1), 3)
20*x^7 + 8*x^8 + 3*x^9

julia&gt; TruncatedPoly((1,2,3), 6) + TruncatedPoly((5,2,1), 3)
x^4 + 2*x^5 + 3*x^6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/GraphTensorNetworks.jl/blob/ccb9c974c5bad95082bcae49f697ed127a627996/src/arithematics.jl#L82-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphTensorNetworks.Max2Poly" href="#GraphTensorNetworks.Max2Poly"><code>GraphTensorNetworks.Max2Poly</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Max2Poly{T,TO} = TruncatedPoly{2,T,TO}
Max2Poly(a, b, maxorder)</code></pre><p>A shorthand of <a href="#GraphTensorNetworks.TruncatedPoly"><code>TruncatedPoly</code></a>{2}.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/GraphTensorNetworks.jl/blob/ccb9c974c5bad95082bcae49f697ed127a627996/src/arithematics.jl#L106-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphTensorNetworks.ConfigEnumerator" href="#GraphTensorNetworks.ConfigEnumerator"><code>GraphTensorNetworks.ConfigEnumerator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ConfigEnumerator{N,S,C} &lt;: AbstractSetNumber</code></pre><p>Set algebra for enumerating configurations, where <code>N</code> is the length of configurations, <code>C</code> is the size of storage in unit of <code>UInt64</code>, <code>S</code> is the bit width to store a single element in a configuration, i.e. <code>log2(# of flavors)</code>, for bitstrings, it is <code>1</code>`.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = ConfigEnumerator([StaticBitVector([1,1,1,0,0]), StaticBitVector([1,0,0,0,1])])
{11100, 10001}

julia&gt; b = ConfigEnumerator([StaticBitVector([0,0,0,0,0]), StaticBitVector([1,0,1,0,1])])
{00000, 10101}

julia&gt; a + b
{11100, 10001, 00000, 10101}

julia&gt; one(a)
{00000}

julia&gt; zero(a)
{}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/GraphTensorNetworks.jl/blob/ccb9c974c5bad95082bcae49f697ed127a627996/src/arithematics.jl#L171-L196">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphTensorNetworks.TreeConfigEnumerator" href="#GraphTensorNetworks.TreeConfigEnumerator"><code>GraphTensorNetworks.TreeConfigEnumerator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TreeConfigEnumerator{N,S,C} &lt;: AbstractSetNumber</code></pre><p>Configuration enumerator encoded in a tree, it is the most natural representation given by a sum-product network and is often more memory efficient than putting the configurations in a vector. <code>N</code>, <code>S</code> and <code>C</code> are type parameters from the <a href="#GraphTensorNetworks.StaticElementVector"><code>StaticElementVector</code></a>{N,S,C}.</p><p><strong>Fields</strong></p><ul><li><code>tag</code> is one of <code>ZERO</code>, <code>LEAF</code>, <code>SUM</code>, <code>PROD</code>.</li><li><code>data</code> is the element stored in a <code>LEAF</code> node.</li><li><code>left</code> and <code>right</code> are two operands of a <code>SUM</code> or <code>PROD</code> node.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; s = TreeConfigEnumerator(bv&quot;00111&quot;)
00111


julia&gt; q = TreeConfigEnumerator(bv&quot;10000&quot;)
10000


julia&gt; x = s + q
+
├─ 00111
└─ 10000


julia&gt; y = x * x
*
├─ +
│  ├─ 00111
│  └─ 10000
└─ +
   ├─ 00111
   └─ 10000


julia&gt; collect(y)
4-element Vector{StaticBitVector{5, 1}}:
 00111
 10111
 10111
 10000

julia&gt; zero(s)



julia&gt; one(s)
00000

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/GraphTensorNetworks.jl/blob/ccb9c974c5bad95082bcae49f697ed127a627996/src/arithematics.jl#L286-L342">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphTensorNetworks.ConfigSampler" href="#GraphTensorNetworks.ConfigSampler"><code>GraphTensorNetworks.ConfigSampler</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ConfigSampler{N,S,C} &lt;: AbstractSetNumber
ConfigSampler(elements::StaticElementVector)</code></pre><p>The algebra for sampling one configuration, where <code>N</code> is the length of configurations, <code>C</code> is the size of storage in unit of <code>UInt64</code>, <code>S</code> is the bit width to store a single element in a configuration, i.e. <code>log2(# of flavors)</code>, for bitstrings, it is <code>1</code>`.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>ConfigSampler</code> is a <strong>probabilistic</strong> commutative semiring, adding two config samplers do not give you deterministic results.</p></div></div><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ConfigSampler(StaticBitVector([1,1,1,0,0]))
ConfigSampler{5, 1, 1}(11100)

julia&gt; ConfigSampler(StaticBitVector([1,1,1,0,0])) + ConfigSampler(StaticBitVector([1,0,1,0,0]))
ConfigSampler{5, 1, 1}(10100)

julia&gt; ConfigSampler(StaticBitVector([1,1,1,0,0])) * ConfigSampler(StaticBitVector([0,0,0,0,1]))
ConfigSampler{5, 1, 1}(11101)

julia&gt; one(ConfigSampler{5, 1, 1})
ConfigSampler{5, 1, 1}(00000)

julia&gt; zero(ConfigSampler{5, 1, 1})
ConfigSampler{5, 1, 1}(11111)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/GraphTensorNetworks.jl/blob/ccb9c974c5bad95082bcae49f697ed127a627996/src/arithematics.jl#L232-L261">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphTensorNetworks.StaticBitVector" href="#GraphTensorNetworks.StaticBitVector"><code>GraphTensorNetworks.StaticBitVector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">StaticBitVector{N,C} = StaticElementVector{N,1,C}
StaticBitVector(x::AbstractVector)</code></pre><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; sb = StaticBitVector([1,0,0,1,1])
10011

julia&gt; sb[3]
0x0000000000000000</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/GraphTensorNetworks.jl/blob/ccb9c974c5bad95082bcae49f697ed127a627996/src/bitvector.jl#L84-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphTensorNetworks.StaticElementVector" href="#GraphTensorNetworks.StaticElementVector"><code>GraphTensorNetworks.StaticElementVector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">StaticElementVector{N,S,C}
StaticElementVector(nflavor::Int, x::AbstractVector)</code></pre><p><code>N</code> is the length of vector, <code>C</code> is the size of storage in unit of <code>UInt64</code>, <code>S</code> is the stride defined as the <code>log2(# of flavors)</code>. When the number of flavors is 2, it is a <code>StaticBitVector</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ev = StaticElementVector(3, [1,2,0,1,2])
12012

julia&gt; ev[2]
0x0000000000000002</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/GraphTensorNetworks.jl/blob/ccb9c974c5bad95082bcae49f697ed127a627996/src/bitvector.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphTensorNetworks.save_configs" href="#GraphTensorNetworks.save_configs"><code>GraphTensorNetworks.save_configs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">save_configs(filename, data::ConfigEnumerator; format=:binary)</code></pre><p>Save configurations <code>data</code> to file <code>filename</code>. The format is <code>:binary</code> or <code>:text</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/GraphTensorNetworks.jl/blob/ccb9c974c5bad95082bcae49f697ed127a627996/src/interfaces.jl#L301-L305">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphTensorNetworks.load_configs" href="#GraphTensorNetworks.load_configs"><code>GraphTensorNetworks.load_configs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">load_configs(filename; format=:binary, bitlength=nothing, nflavors=2)</code></pre><p>Load configurations from file <code>filename</code>. The format is <code>:binary</code> or <code>:text</code>. If the format is <code>:binary</code>, the bitstring length <code>bitlength</code> must be specified, <code>nflavors</code> specifies the degree of freedom.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/GraphTensorNetworks.jl/blob/ccb9c974c5bad95082bcae49f697ed127a627996/src/interfaces.jl#L316-L322">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphTensorNetworks.@bv_str" href="#GraphTensorNetworks.@bv_str"><code>GraphTensorNetworks.@bv_str</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>Constructing a static bit vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/GraphTensorNetworks.jl/blob/ccb9c974c5bad95082bcae49f697ed127a627996/src/bitvector.jl#L144-L146">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphTensorNetworks.onehotv" href="#GraphTensorNetworks.onehotv"><code>GraphTensorNetworks.onehotv</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">onehotv(::Type{&lt;:StaticElementVector}, i, v)
onehotv(::Type{&lt;:StaticBitVector, i)</code></pre><p>Returns a static element vector, with the value at location <code>i</code> being <code>v</code> (1 if not specified).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/GraphTensorNetworks.jl/blob/ccb9c974c5bad95082bcae49f697ed127a627996/src/bitvector.jl#L71-L76">source</a></section></article><h2 id="Tensor-Network"><a class="docs-heading-anchor" href="#Tensor-Network">Tensor Network</a><a id="Tensor-Network-1"></a><a class="docs-heading-anchor-permalink" href="#Tensor-Network" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="OMEinsumContractionOrders.optimize_code" href="#OMEinsumContractionOrders.optimize_code"><code>OMEinsumContractionOrders.optimize_code</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">optimize_code(eincode, size_dict, optimizer = GreedyMethod(), simplifier=nothing, permute=true)</code></pre><p>Optimize the einsum contraction code and reduce the time/space complexity of tensor network contraction. Returns a <code>NestedEinsum</code> instance. Input arguments are</p><ul><li><code>eincode</code> is an einsum contraction code instance, one of <code>DynamicEinCode</code>, <code>StaticEinCode</code> or <code>NestedEinsum</code>.</li><li><code>size</code> is a dictionary of &quot;edge label=&gt;edge size&quot; that contains the size information, one can use <code>uniformsize(eincode, 2)</code> to create a uniform size.</li><li><code>optimizer</code> is a <code>CodeOptimizer</code> instance, should be one of <code>GreedyMethod</code>, <code>KaHyParBipartite</code>, <code>SABipartite</code> or <code>TreeSA</code>. Check their docstrings for details.</li><li><code>simplifier</code> is one of <code>MergeVectors</code> or <code>MergeGreedy</code>.</li><li>optimize the permutation if <code>permute</code> is true.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="OMEinsum.getixsv" href="#OMEinsum.getixsv"><code>OMEinsum.getixsv</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getixsv(code)</code></pre><p>Get labels of input tensors for <code>EinCode</code>, <code>NestedEinsum</code> and some other einsum like objects. Returns a vector of vector.</p><pre><code class="language-julia-repl hljs">julia&gt; getixsv(ein&quot;(ij,jk),k-&gt;i&quot;)
3-element Vector{Vector{Char}}:
 [&#39;i&#39;, &#39;j&#39;]
 [&#39;j&#39;, &#39;k&#39;]
 [&#39;k&#39;]</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="OMEinsum.getiyv" href="#OMEinsum.getiyv"><code>OMEinsum.getiyv</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getiy(code)</code></pre><p>Get labels of the output tensor for <code>EinCode</code>, <code>NestedEinsum</code> and some other einsum like objects. Returns a vector.</p><pre><code class="language-julia-repl hljs">julia&gt; getiyv(ein&quot;(ij,jk),k-&gt;i&quot;)
1-element Vector{Char}:
 &#39;i&#39;: ASCII/Unicode U+0069 (category Ll: Letter, lowercase)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="OMEinsum.timespace_complexity" href="#OMEinsum.timespace_complexity"><code>OMEinsum.timespace_complexity</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">timespace_complexity(eincode, size_dict)</code></pre><p>Returns the time and space complexity of the einsum contraction. The time complexity is defined as <code>log2(number of element multiplication)</code>. The space complexity is defined as <code>log2(size of the maximum intermediate tensor)</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="OMEinsum.timespacereadwrite_complexity" href="#OMEinsum.timespacereadwrite_complexity"><code>OMEinsum.timespacereadwrite_complexity</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">timespacereadwrite_complexity(eincode, size_dict)</code></pre><p>Returns the time, space and read-write complexity of the einsum contraction. The time complexity is defined as <code>log2(number of element-wise multiplication)</code>. The space complexity is defined as <code>log2(size of the maximum intermediate tensor)</code>. The read-write complexity is defined as <code>log2(the number of read-write operations)</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="OMEinsum.@ein_str" href="#OMEinsum.@ein_str"><code>OMEinsum.@ein_str</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">ein&quot;ij,jk -&gt; ik&quot;(A,B)</code></pre><p>String macro interface which understands <code>numpy.einsum</code>&#39;s notation. Translates strings into <code>StaticEinCode</code>-structs that can be called to evaluate an <code>einsum</code>. To control evaluation order, use parentheses - instead of an <code>EinCode</code>, a <code>NestedEinsum</code> is returned which evaluates the expression according to parens. The valid character ranges for index-labels are <code>a-z</code> and <code>α-ω</code>.</p><p><strong>example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a, b, c = rand(10,10), rand(10,10), rand(10,1);

julia&gt; ein&quot;ij,jk,kl -&gt; il&quot;(a,b,c) ≈ ein&quot;(ij,jk),kl -&gt; il&quot;(a,b,c) ≈ a * b * c
true</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="OMEinsumContractionOrders.GreedyMethod" href="#OMEinsumContractionOrders.GreedyMethod"><code>OMEinsumContractionOrders.GreedyMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GreedyMethod{MT}
GreedyMethod(; method=MinSpaceOut(), nrepeat=10)</code></pre><p>The fast but poor greedy optimizer. Input arguments are</p><ul><li><code>method</code> is <code>MinSpaceDiff()</code> or <code>MinSpaceOut</code>.<ul><li><code>MinSpaceOut</code> choose one of the contraction that produces a minimum output tensor size,</li><li><code>MinSpaceDiff</code> choose one of the contraction that decrease the space most.</li></ul></li><li><code>nrepeat</code> is the number of repeatition, returns the best contraction order.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="OMEinsumContractionOrders.TreeSA" href="#OMEinsumContractionOrders.TreeSA"><code>OMEinsumContractionOrders.TreeSA</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TreeSA{RT,IT,GM}
TreeSA(; sc_target=20, βs=collect(0.01:0.05:15), ntrials=10, niters=50,
    sc_weight=1.0, rw_weight=0.2, initializer=:greedy, greedy_config=GreedyMethod(; nrepeat=1))</code></pre><p>Optimize the einsum contraction pattern using the simulated annealing on tensor expression tree.</p><ul><li><code>sc_target</code> is the target space complexity,</li><li><code>ntrials</code>, <code>βs</code> and <code>niters</code> are annealing parameters, doing <code>ntrials</code> indepedent annealings, each has inverse tempteratures specified by <code>βs</code>, in each temperature, do <code>niters</code> updates of the tree.</li><li><code>sc_weight</code> is the relative importance factor of space complexity in the loss compared with the time complexity.</li><li><code>rw_weight</code> is the relative importance factor of memory read and write in the loss compared with the time complexity.</li><li><code>initializer</code> specifies how to determine the initial configuration, it can be <code>:greedy</code> or <code>:random</code>. If it is using <code>:greedy</code> method to generate the initial configuration, it also uses two extra arguments <code>greedy_method</code> and <code>greedy_nrepeat</code>.</li><li><code>nslices</code> is the number of sliced legs, default is 0.</li></ul><p><strong>References</strong></p><ul><li><a href="https://arxiv.org/abs/2108.05665">Recursive Multi-Tensor Contraction for XEB Verification of Quantum Circuits</a></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="OMEinsumContractionOrders.SABipartite" href="#OMEinsumContractionOrders.SABipartite"><code>OMEinsumContractionOrders.SABipartite</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SABipartite{RT,BT}
SABipartite(; sc_target=25, ntrials=50, βs=0.1:0.2:15.0, niters=1000
    max_group_size=40, greedy_config=GreedyMethod(), initializer=:random)</code></pre><p>Optimize the einsum code contraction order using the Simulated Annealing bipartition + Greedy approach. This program first recursively cuts the tensors into several groups using simulated annealing, with maximum group size specifed by <code>max_group_size</code> and maximum space complexity specified by <code>sc_target</code>, Then finds the contraction order inside each group with the greedy search algorithm. Other arguments are</p><ul><li><code>size_dict</code>, a dictionary that specifies leg dimensions,</li><li><code>sc_target</code> is the target space complexity, defined as <code>log2(number of elements in the largest tensor)</code>,</li><li><code>max_group_size</code> is the maximum size that allowed to used greedy search,</li><li><code>βs</code> is a list of inverse temperature <code>1/T</code>,</li><li><code>niters</code> is the number of iteration in each temperature,</li><li><code>ntrials</code> is the number of repetition (with different random seeds),</li><li><code>greedy_config</code> configures the greedy method,</li><li><code>initializer</code>, the partition configuration initializer, one can choose <code>:random</code> or <code>:greedy</code> (slow but better).</li></ul><p><strong>References</strong></p><ul><li><a href="https://arxiv.org/abs/2002.01935">Hyper-optimized tensor network contraction</a></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="OMEinsumContractionOrders.KaHyParBipartite" href="#OMEinsumContractionOrders.KaHyParBipartite"><code>OMEinsumContractionOrders.KaHyParBipartite</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">KaHyParBipartite{RT,IT,GM}
KaHyParBipartite(; sc_target, imbalances=collect(0.0:0.005:0.8),
    max_group_size=40, greedy_config=GreedyMethod())</code></pre><p>Optimize the einsum code contraction order using the KaHyPar + Greedy approach. This program first recursively cuts the tensors into several groups using KaHyPar, with maximum group size specifed by <code>max_group_size</code> and maximum space complexity specified by <code>sc_target</code>, Then finds the contraction order inside each group with the greedy search algorithm. Other arguments are</p><ul><li><code>sc_target</code> is the target space complexity, defined as <code>log2(number of elements in the largest tensor)</code>,</li><li><code>imbalances</code> is a KaHyPar parameter that controls the group sizes in hierarchical bipartition,</li><li><code>max_group_size</code> is the maximum size that allowed to used greedy search,</li><li><code>greedy_config</code> is a greedy optimizer.</li></ul><p><strong>References</strong></p><ul><li><a href="https://arxiv.org/abs/2002.01935">Hyper-optimized tensor network contraction</a></li><li><a href="https://arxiv.org/abs/2103.03074">Simulating the Sycamore quantum supremacy circuits</a></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="OMEinsumContractionOrders.MergeVectors" href="#OMEinsumContractionOrders.MergeVectors"><code>OMEinsumContractionOrders.MergeVectors</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MergeVectors &lt;: CodeSimplifier
MergeVectors()</code></pre><p>Contraction code simplifier (in order to reduce the time of calling optimizers) that merges vectors to closest tensors.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="OMEinsumContractionOrders.MergeGreedy" href="#OMEinsumContractionOrders.MergeGreedy"><code>OMEinsumContractionOrders.MergeGreedy</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MergeGreedy &lt;: CodeSimplifier
MergeGreedy(; threshhold=-1e-12)</code></pre><p>Contraction code simplifier (in order to reduce the time of calling optimizers) that merges tensors greedily if the space complexity of merged tensors is reduced (difference smaller than the <code>threshhold</code>).</p></div></section></article><h2 id="Others"><a class="docs-heading-anchor" href="#Others">Others</a><a id="Others-1"></a><a class="docs-heading-anchor-permalink" href="#Others" title="Permalink"></a></h2><h4 id="Graph"><a class="docs-heading-anchor" href="#Graph">Graph</a><a id="Graph-1"></a><a class="docs-heading-anchor-permalink" href="#Graph" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="GraphTensorNetworks.show_graph" href="#GraphTensorNetworks.show_graph"><code>GraphTensorNetworks.show_graph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">show_graph(locations, edges;
    vertex_colors=[&quot;black&quot;, &quot;black&quot;, ...],
    edge_colors=[&quot;black&quot;, &quot;black&quot;, ...],
    texts=[&quot;1&quot;, &quot;2&quot;, ...],
    format=SVG,
    edge_color=&quot;black&quot;,
    kwargs...
    )
show_graph(graph::SimpleGraph; locs=spring_layout(graph), kwargs...)</code></pre><p>Plots vertices at <code>locations</code> with vertex colors specified by <code>vertex_colors</code> and texts specified by <code>texts</code>. You will need a <code>VSCode</code>, <code>Pluto</code> notebook or <code>Jupyter</code> notebook to show the image. If you want to write this image to the disk without displaying it in a frontend, please try</p><pre><code class="language-julia hljs">julia&gt; open(&quot;test.png&quot;, &quot;w&quot;) do f
            viz_atoms(f, generate_sites(SquareLattice(), 5, 5))
       end</code></pre><p>The <code>format</code> keyword argument can be <code>Compose.SVG</code> or <code>Compose.PDF</code>.</p><p><strong>Other keyword arguments</strong></p><ul><li>line, vertex and text<ul><li>scale::Float64 = 1.0</li><li>pad::Float64 = 1.5</li></ul></li><li>vertex<ul><li>vertex_text_color::String = &quot;black&quot;</li><li>vertex_stroke_color = &quot;black&quot;</li><li>vertex_fill_color = &quot;white&quot;</li></ul></li><li>edge<ul><li>edge_color::String = &quot;black&quot;</li></ul></li><li>image size in <code>cm</code><ul><li>image_size::Float64 = 12</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/GraphTensorNetworks.jl/blob/ccb9c974c5bad95082bcae49f697ed127a627996/src/visualize.jl#L59-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphTensorNetworks.spring_layout" href="#GraphTensorNetworks.spring_layout"><code>GraphTensorNetworks.spring_layout</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Spring layout for graph plotting, returns a vector of vertex locations.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This function is copied from <a href="https://github.com/JuliaGraphs/GraphPlot.jl"><code>GraphPlot.jl</code></a>, where you can find more information about his function.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/GraphTensorNetworks.jl/blob/ccb9c974c5bad95082bcae49f697ed127a627996/src/visualize.jl#L184-L190">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphTensorNetworks.diagonal_coupled_graph" href="#GraphTensorNetworks.diagonal_coupled_graph"><code>GraphTensorNetworks.diagonal_coupled_graph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">diagonal_coupled_graph(mask::AbstractMatrix{Bool})</code></pre><p>Create a masked diagonal coupled square lattice graph from a specified <code>mask</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/GraphTensorNetworks.jl/blob/ccb9c974c5bad95082bcae49f697ed127a627996/src/graphs.jl#L39-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphTensorNetworks.square_lattice_graph" href="#GraphTensorNetworks.square_lattice_graph"><code>GraphTensorNetworks.square_lattice_graph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">square_lattice_graph(mask::AbstractMatrix{Bool})</code></pre><p>Create a masked square lattice graph.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/GraphTensorNetworks.jl/blob/ccb9c974c5bad95082bcae49f697ed127a627996/src/graphs.jl#L14-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphTensorNetworks.unit_disk_graph" href="#GraphTensorNetworks.unit_disk_graph"><code>GraphTensorNetworks.unit_disk_graph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">unit_disk_graph(locs::AbstractVector, unit::Real)</code></pre><p>Create a unit disk graph with locations specified by <code>locs</code> and unit distance <code>unit</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/GraphTensorNetworks.jl/blob/ccb9c974c5bad95082bcae49f697ed127a627996/src/graphs.jl#L49-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphTensorNetworks.line_graph" href="#GraphTensorNetworks.line_graph"><code>GraphTensorNetworks.line_graph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">line_graph(g::SimpleGraph)</code></pre><p>Returns the line graph of <code>g</code>. The line graph is generated by mapping an edge to a vertex and two edges sharing a common vertex will be connected.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/GraphTensorNetworks.jl/blob/ccb9c974c5bad95082bcae49f697ed127a627996/src/graphs.jl#L65-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphTensorNetworks.random_diagonal_coupled_graph" href="#GraphTensorNetworks.random_diagonal_coupled_graph"><code>GraphTensorNetworks.random_diagonal_coupled_graph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">random_diagonal_coupled_graph(m::Int, n::Int, ρ::Real)</code></pre><p>Create a random masked diagonal coupled square lattice graph, with number of vertices fixed to <span>$\lfloor mn\rho \rceil$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/GraphTensorNetworks.jl/blob/ccb9c974c5bad95082bcae49f697ed127a627996/src/graphs.jl#L24-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphTensorNetworks.random_square_lattice_graph" href="#GraphTensorNetworks.random_square_lattice_graph"><code>GraphTensorNetworks.random_square_lattice_graph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">random_square_lattice_graph(m::Int, n::Int, ρ::Real)</code></pre><p>Create a random masked square lattice graph, with number of vertices fixed to <span>$\lfloor mn\rho \rceil$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/GraphTensorNetworks.jl/blob/ccb9c974c5bad95082bcae49f697ed127a627996/src/graphs.jl#L4-L8">source</a></section></article><p>One can also use <code>random_regular_graph</code> and <code>smallgraph</code> in <a href="https://github.com/JuliaGraphs/Graphs.jl">Graphs</a> to build special graphs.</p><h4 id="Shortcuts"><a class="docs-heading-anchor" href="#Shortcuts">Shortcuts</a><a id="Shortcuts-1"></a><a class="docs-heading-anchor-permalink" href="#Shortcuts" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="GraphTensorNetworks.max_size" href="#GraphTensorNetworks.max_size"><code>GraphTensorNetworks.max_size</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">max_size(problem; usecuda=false)</code></pre><p>Returns the maximum size of the graph problem.  A shorthand of <code>solve(problem, SizeMax(); usecuda=false)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/GraphTensorNetworks.jl/blob/ccb9c974c5bad95082bcae49f697ed127a627996/src/interfaces.jl#L283-L288">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphTensorNetworks.max_size_count" href="#GraphTensorNetworks.max_size_count"><code>GraphTensorNetworks.max_size_count</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">max_size_count(problem; usecuda=false)</code></pre><p>Returns the maximum size and the counting of the graph problem. It is a shorthand of <code>solve(problem, CountingMax(); usecuda=false)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Happy-Diode/GraphTensorNetworks.jl/blob/ccb9c974c5bad95082bcae49f697ed127a627996/src/interfaces.jl#L291-L296">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../performancetips/">« Performance Tips</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.12 on <span class="colophon-date" title="Thursday 24 February 2022 03:43">Thursday 24 February 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
