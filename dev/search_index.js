var documenterSearchIndex = {"docs":
[{"location":"tutorials/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"EditURL = \"https://github.com/Happy-Diode/GraphTensorNetworks.jl/blob/master/examples/PaintShop.jl\"","category":"page"},{"location":"tutorials/PaintShop/#Binary-paint-shop-problem","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"","category":"section"},{"location":"tutorials/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"note: Note\nIt is recommended to read the Independent set problem tutorial first to know more abouthow to optimize the tensor network contraction order,\nwhat graph properties are available and how to select correct method to compute graph properties,\nhow to compute weighted graphs and handle open vertices.","category":"page"},{"location":"tutorials/PaintShop/#Problme-Definition","page":"Binary paint shop problem","title":"Problme Definition","text":"","category":"section"},{"location":"tutorials/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"The binary paint shop problem is defined as follows: we are given a 2m length sequence containing m cars, where each car appears twice. Each car need to be colored red in one occurrence, and blue in the other. We need to choose which occurrence for each car to color with which color — the goal is to minimize the number of times we need to change the current color.","category":"page"},{"location":"tutorials/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"In the following, we use a character to represent a car, and defined a binary paint shop problem as a string that each character appear exactly twice.","category":"page"},{"location":"tutorials/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"using GraphTensorNetworks, Graphs\n\nsequence = collect(\"iadgbeadfcchghebif\")","category":"page"},{"location":"tutorials/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"We can visualize this paint shop problem as a graph","category":"page"},{"location":"tutorials/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"rot(a, b, θ) = cos(θ)*a + sin(θ)*b, cos(θ)*b - sin(θ)*a\n\nlocations = [rot(0.0, 1.0, -0.25π - 1.5*π*(i-0.5)/length(sequence)) for i=1:length(sequence)]\n\ngraph = path_graph(length(sequence))\nfor i=1:length(sequence)\n    j = findlast(==(sequence[i]), sequence)\n    i != j && add_edge!(graph, i, j)\nend\n\nshow_graph(graph; locs=locations, texts=string.(sequence), edge_colors=\n    [sequence[e.src] == sequence[e.dst] ? \"blue\" : \"black\" for e in edges(graph)])","category":"page"},{"location":"tutorials/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"Vertices connected by blue edges must have different colors, and the goal becomes a min-cut problem defined on black edges.","category":"page"},{"location":"tutorials/PaintShop/#Tensor-network-representation","page":"Binary paint shop problem","title":"Tensor network representation","text":"","category":"section"},{"location":"tutorials/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"Type PaintShop can be used for constructing the tensor network with optimized contraction order for solving a binary paint shop problem. To obtain its tensor network representation, we associating car c_i (the i-th character in our example) with a degree of freedom s_c_i in 0 1, where we use 0 to denote the first appearance of a car is colored red and 1 to denote the first appearance of a car is colored blue. For each black edges (i i+1), we define an edge tensor labeld by (s_c_i s_c_i+1) as follows: If both cars on this edge are their first or second appearance","category":"page"},{"location":"tutorials/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"B^rm parallel = left(beginmatrix\nx  1 \n1  x \nendmatrixright)","category":"page"},{"location":"tutorials/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"otherwise,","category":"page"},{"location":"tutorials/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"B^rm anti-parallel = left(beginmatrix\n1  x \nx  1 \nendmatrixright)","category":"page"},{"location":"tutorials/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"It can be understood as, when both cars are their first appearance, they tend to have the same configuration so that the color is not changed. Otherwise, they tend to have different configuration to keep the color unchanged.","category":"page"},{"location":"tutorials/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"Let us contruct the problem instance as bellow.","category":"page"},{"location":"tutorials/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"problem = PaintShop(sequence);\nnothing #hide","category":"page"},{"location":"tutorials/PaintShop/#Counting-properties","page":"Binary paint shop problem","title":"Counting properties","text":"","category":"section"},{"location":"tutorials/PaintShop/#graph-polynomial","page":"Binary paint shop problem","title":"graph polynomial","text":"","category":"section"},{"location":"tutorials/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"The graph polynomial defined for the maximal independent set problem is","category":"page"},{"location":"tutorials/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"I_rm max(G x) = sum_k=0^alpha(G) b_k x^k","category":"page"},{"location":"tutorials/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"where b_k is the number of maximal independent sets of size k in graph G=(V E).","category":"page"},{"location":"tutorials/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"max_config = solve(problem, GraphPolynomial())[]","category":"page"},{"location":"tutorials/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"Since it only counts the maximal independent sets, the first several coefficients are 0.","category":"page"},{"location":"tutorials/PaintShop/#Counting-properties-2","page":"Binary paint shop problem","title":"Counting properties","text":"","category":"section"},{"location":"tutorials/PaintShop/#graph-polynomial-2","page":"Binary paint shop problem","title":"graph polynomial","text":"","category":"section"},{"location":"tutorials/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"The graph polynomial of the binary paint shop problem in our convension is defined as","category":"page"},{"location":"tutorials/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"D(G x) = sum_k=0^delta(G) d_k x^k","category":"page"},{"location":"tutorials/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"where d_k is the number of possible coloring with number of color changes 2m-1-k.","category":"page"},{"location":"tutorials/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"paint_polynomial = solve(problem, GraphPolynomial())[]","category":"page"},{"location":"tutorials/PaintShop/#Configuration-properties","page":"Binary paint shop problem","title":"Configuration properties","text":"","category":"section"},{"location":"tutorials/PaintShop/#finding-best-solutions","page":"Binary paint shop problem","title":"finding best solutions","text":"","category":"section"},{"location":"tutorials/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"best_configs = solve(problem, ConfigsMin())[]","category":"page"},{"location":"tutorials/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"One can see to identical bitstrings corresponding two different vertex configurations, they are related to bit-flip symmetry.","category":"page"},{"location":"tutorials/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"painting1 = paint_shop_coloring_from_config(problem, best_configs.c.data[1])\n\nshow_graph(graph; locs=locations, texts=string.(sequence),\n    edge_colors=[sequence[e.src] == sequence[e.dst] ? \"blue\" : \"black\" for e in edges(graph)],\n    vertex_colors=[isone(c) ? \"red\" : \"black\" for c in painting1], vertex_text_color=\"white\")","category":"page"},{"location":"tutorials/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"Since we have different choices of initial color, the number of best solution is 2.","category":"page"},{"location":"tutorials/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"The following function will check the solution and return you the number of color switchs","category":"page"},{"location":"tutorials/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"num_paint_shop_color_switch(sequence, painting1)","category":"page"},{"location":"tutorials/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"","category":"page"},{"location":"tutorials/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/Others/","page":"Other problems","title":"Other problems","text":"EditURL = \"https://github.com/Happy-Diode/GraphTensorNetworks.jl/blob/master/examples/Others.jl\"","category":"page"},{"location":"tutorials/Others/#Other-problems-can-be-solved-by-GraphTensorNetworks","page":"Other problems","title":"Other problems can be solved by GraphTensorNetworks","text":"","category":"section"},{"location":"tutorials/Others/#Set-packing-problem","page":"Other problems","title":"Set packing problem","text":"","category":"section"},{"location":"tutorials/Others/","page":"Other problems","title":"Other problems","text":"It is a generalization of the independent set problem.","category":"page"},{"location":"tutorials/Others/#Vertex-cover-problem","page":"Other problems","title":"Vertex cover problem","text":"","category":"section"},{"location":"tutorials/Others/","page":"Other problems","title":"Other problems","text":"A vertex cover is a complement of an independent set.","category":"page"},{"location":"tutorials/Others/#Maximal-clique-problem","page":"Other problems","title":"Maximal clique problem","text":"","category":"section"},{"location":"tutorials/Others/","page":"Other problems","title":"Other problems","text":"The maximal clique of graph G is a maximal clique of G's complement graph.","category":"page"},{"location":"tutorials/Others/","page":"Other problems","title":"Other problems","text":"","category":"page"},{"location":"tutorials/Others/","page":"Other problems","title":"Other problems","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"EditURL = \"https://github.com/Happy-Diode/GraphTensorNetworks.jl/blob/master/examples/MaxCut.jl\"","category":"page"},{"location":"tutorials/MaxCut/#Cutting-problem-(Spin-glass-problem)","page":"Cutting problem","title":"Cutting problem (Spin-glass problem)","text":"","category":"section"},{"location":"tutorials/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"note: Note\nIt is recommended to read the Independent set problem tutorial first to know more abouthow to optimize the tensor network contraction order,\nwhat graph properties are available and how to select correct method to compute graph properties,\nhow to compute weighted graphs and handle open vertices.","category":"page"},{"location":"tutorials/MaxCut/#Problem-definition","page":"Cutting problem","title":"Problem definition","text":"","category":"section"},{"location":"tutorials/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"In graph theory, a cut is a partition of the vertices of a graph into two disjoint subsets. It is closely related to the spin-glass problem in physics. Finding the maximum cut is NP-Hard, where a maximum cut is a cut whose size is at least the size of any other cut, where the size of a cut is the number of edges (or the sum of weights on edges) crossing the cut.","category":"page"},{"location":"tutorials/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"using GraphTensorNetworks, Graphs","category":"page"},{"location":"tutorials/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"In the following, we are going to defined an cutting problem for the Petersen graph.","category":"page"},{"location":"tutorials/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"graph = Graphs.smallgraph(:petersen)","category":"page"},{"location":"tutorials/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"We can visualize this graph using the following function","category":"page"},{"location":"tutorials/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"rot15(a, b, i::Int) = cos(2i*π/5)*a + sin(2i*π/5)*b, cos(2i*π/5)*b - sin(2i*π/5)*a\n\nlocations = [[rot15(0.0, 1.0, i) for i=0:4]..., [rot15(0.0, 0.6, i) for i=0:4]...]\n\nshow_graph(graph; locs=locations)","category":"page"},{"location":"tutorials/MaxCut/#Tensor-network-representation","page":"Cutting problem","title":"Tensor network representation","text":"","category":"section"},{"location":"tutorials/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"For a vertex vin V, we define a boolean degree of freedom s_vin0 1. Then the maximum cutting problem can be encoded to tensor networks by mapping an edge (ij)in E to an edge matrix labelled by s_is_j","category":"page"},{"location":"tutorials/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"B(x_langle i jrangle) = left(beginmatrix\n    1  x_langle i jrangle\n    x_langle i jrangle  1\nendmatrixright)","category":"page"},{"location":"tutorials/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"where variable x_langle i jrangle represents a cut on edge (i j) or a domain wall of an Ising spin glass. Similar to other problems, we can define a polynomial about edges variables by setting x_langle i jrangle = x, where its k-th coefficient is two times the number of configurations of cut size k. We define the cutting problem as","category":"page"},{"location":"tutorials/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"problem = MaxCut(graph);\nnothing #hide","category":"page"},{"location":"tutorials/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"Its contraction time space complexity is 2^rm tw(G), where rm tw(G) is the tree-width of G.","category":"page"},{"location":"tutorials/MaxCut/#Solving-properties","page":"Cutting problem","title":"Solving properties","text":"","category":"section"},{"location":"tutorials/MaxCut/#Maximum-cut-size-\\gamma(G)","page":"Cutting problem","title":"Maximum cut size gamma(G)","text":"","category":"section"},{"location":"tutorials/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"max_cut_size = solve(problem, SizeMax())[]","category":"page"},{"location":"tutorials/MaxCut/#Counting-properties","page":"Cutting problem","title":"Counting properties","text":"","category":"section"},{"location":"tutorials/MaxCut/#graph-polynomial","page":"Cutting problem","title":"graph polynomial","text":"","category":"section"},{"location":"tutorials/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"The graph polynomial defined for the cutting problem is","category":"page"},{"location":"tutorials/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"C(G x) = sum_k=0^gamma(G) c_k x^k","category":"page"},{"location":"tutorials/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"where alpha(G) is the maximum independent set size, c_k2 is the number of cuts of size k in graph G=(VE). Since the variable x is defined on edges, the coefficients of the polynomial is the number of configurations having different number of anti-parallel edges.","category":"page"},{"location":"tutorials/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"max_config = solve(problem, GraphPolynomial())[]","category":"page"},{"location":"tutorials/MaxCut/#Configuration-properties","page":"Cutting problem","title":"Configuration properties","text":"","category":"section"},{"location":"tutorials/MaxCut/#finding-one-max-cut-solution","page":"Cutting problem","title":"finding one max cut solution","text":"","category":"section"},{"location":"tutorials/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"max_vertex_config = solve(problem, SingleConfigMax())[].c.data\n\nmax_cut_size_verify = cut_size(graph, max_vertex_config)","category":"page"},{"location":"tutorials/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"You should see a consistent result as above max_cut_size.","category":"page"},{"location":"tutorials/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"show_graph(graph; locs=locations, vertex_colors=[\n        iszero(max_vertex_config[i]) ? \"white\" : \"red\" for i=1:nv(graph)])","category":"page"},{"location":"tutorials/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"where red vertices and white vertices are seperated by the cut.","category":"page"},{"location":"tutorials/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"","category":"page"},{"location":"tutorials/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"EditURL = \"https://github.com/Happy-Diode/GraphTensorNetworks.jl/blob/master/examples/MaximalIS.jl\"","category":"page"},{"location":"tutorials/MaximalIS/#Maximal-independent-set-problem","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"","category":"section"},{"location":"tutorials/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"note: Note\nIt is recommended to read the Independent set problem tutorial first to know more abouthow to optimize the tensor network contraction order,\nwhat graph properties are available and how to select correct method to compute graph properties,\nhow to compute weighted graphs and handle open vertices.","category":"page"},{"location":"tutorials/MaximalIS/#Problem-definition","page":"Maximal independent set problem","title":"Problem definition","text":"","category":"section"},{"location":"tutorials/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"In graph theory, a maximal independent set is an independent set that is not a subset of any other independent set. It is different from maximum independent set because it does not require the set to have the max size. In the following, we are going to solve the maximal independent set problem on the Petersen graph.","category":"page"},{"location":"tutorials/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"using GraphTensorNetworks, Graphs, Compose\n\ngraph = Graphs.smallgraph(:petersen)","category":"page"},{"location":"tutorials/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"We can visualize this graph using the following function","category":"page"},{"location":"tutorials/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"rot15(a, b, i::Int) = cos(2i*π/5)*a + sin(2i*π/5)*b, cos(2i*π/5)*b - sin(2i*π/5)*a\n\nlocations = [[rot15(0.0, 1.0, i) for i=0:4]..., [rot15(0.0, 0.6, i) for i=0:4]...]\n\nshow_graph(graph; locs=locations)","category":"page"},{"location":"tutorials/MaximalIS/#Tensor-network-representation","page":"Maximal independent set problem","title":"Tensor network representation","text":"","category":"section"},{"location":"tutorials/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"Let G=(VE) be the target graph that we want to solve. The tensor network representation map a vertex vin V to a boolean degree of freedom s_vin0 1. We defined the restriction on its neighbourhood Nv:","category":"page"},{"location":"tutorials/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"T(x_v)_s_1s_2ldotss_N(v)s_v = begincases\n    s_vx_v  s_1=s_2=ldots=s_N(v)=0\n    1-s_v textotherwise\nendcases","category":"page"},{"location":"tutorials/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"Intuitively, it means if all the neighbourhood vertices are not in I_m, i.e., s_1=s_2=ldots=s_N(v)=0, then v should be in I_m and contribute a factor x_v, otherwise, if any of the neighbourhood vertices is in I_m, then v cannot be in I_m. We can use MaximalIS to construct the tensor network for solving the maximal independent set problem as","category":"page"},{"location":"tutorials/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"problem = MaximalIS(graph; optimizer=TreeSA());\nnothing #hide","category":"page"},{"location":"tutorials/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"Its contraction time space complexity of a MaximalIS instance is no longer determined by the tree-width of the original graph G. It is often harder to contract this tensor network than to contract the one for regular independent set problem.","category":"page"},{"location":"tutorials/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"timespacereadwrite_complexity(problem)","category":"page"},{"location":"tutorials/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"Results are log2 values.","category":"page"},{"location":"tutorials/MaximalIS/#Solving-properties","page":"Maximal independent set problem","title":"Solving properties","text":"","category":"section"},{"location":"tutorials/MaximalIS/#Counting-properties","page":"Maximal independent set problem","title":"Counting properties","text":"","category":"section"},{"location":"tutorials/MaximalIS/#maximal-independence-polynomial","page":"Maximal independent set problem","title":"maximal independence polynomial","text":"","category":"section"},{"location":"tutorials/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"The graph polynomial defined for the maximal independent set problem is","category":"page"},{"location":"tutorials/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"I_rm max(G x) = sum_k=0^alpha(G) b_k x^k","category":"page"},{"location":"tutorials/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"where b_k is the number of maximal independent sets of size k in graph G=(V E).","category":"page"},{"location":"tutorials/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"maximal_indenpendence_polynomial = solve(problem, GraphPolynomial())[]","category":"page"},{"location":"tutorials/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"One can see the first several coefficients are 0, because it only counts the maximal independent sets, The minimum maximal independent set size is also known as the independent domination number. It can be computed with the SizeMin property:","category":"page"},{"location":"tutorials/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"independent_domination_number = solve(problem, SizeMin())[]","category":"page"},{"location":"tutorials/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"Similarly, we have its counting CountingMin:","category":"page"},{"location":"tutorials/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"counting_min_maximal_independent_set = solve(problem, CountingMin())[]","category":"page"},{"location":"tutorials/MaximalIS/#Configuration-properties","page":"Maximal independent set problem","title":"Configuration properties","text":"","category":"section"},{"location":"tutorials/MaximalIS/#finding-all-maximal-independent-set","page":"Maximal independent set problem","title":"finding all maximal independent set","text":"","category":"section"},{"location":"tutorials/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"maximal_configs = solve(problem, ConfigsAll())[]\n\nall(c->is_maximal_independent_set(graph, c), maximal_configs)","category":"page"},{"location":"tutorials/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"imgs = ntuple(k->show_graph(graph;\n                locs=locations, scale=0.25,\n                vertex_colors=[iszero(maximal_configs[k][i]) ? \"white\" : \"red\"\n                for i=1:nv(graph)]), length(maximal_configs));\n\nCompose.set_default_graphic_size(18cm, 12cm); Compose.compose(context(),\n     ntuple(k->(context((mod1(k,5)-1)/5, ((k-1)÷5)/3, 1.2/5, 1.0/3), imgs[k]), 15)...)","category":"page"},{"location":"tutorials/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"This result should be consistent with that given by the Bron Kerbosch algorithm on the complement of Petersen graph.","category":"page"},{"location":"tutorials/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"cliques = maximal_cliques(complement(graph))","category":"page"},{"location":"tutorials/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"For sparse graphs, the generic tensor network approach is usually much faster and memory efficient than the Bron Kerbosch algorithm.","category":"page"},{"location":"tutorials/MaximalIS/#finding-minimum-maximal-independent-set","page":"Maximal independent set problem","title":"finding minimum maximal independent set","text":"","category":"section"},{"location":"tutorials/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"It is the ConfigsMin property in the program.","category":"page"},{"location":"tutorials/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"minimum_maximal_configs = solve(problem, ConfigsMin())[].c\n\nimgs2 = ntuple(k->show_graph(graph;\n                locs=locations, scale=0.25,\n                vertex_colors=[iszero(minimum_maximal_configs[k][i]) ? \"white\" : \"red\"\n                for i=1:nv(graph)]), length(minimum_maximal_configs));\n\nCompose.set_default_graphic_size(15cm, 12cm); Compose.compose(context(),\n     ntuple(k->(context((mod1(k,4)-1)/4, ((k-1)÷5)/3, 1.2/4, 1.0/3), imgs2[k]), 10)...)","category":"page"},{"location":"tutorials/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"Similarly, if one is only interested in computing one of the minimum sets, one can use the graph property SingleConfigMin.","category":"page"},{"location":"tutorials/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"","category":"page"},{"location":"tutorials/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"EditURL = \"https://github.com/Happy-Diode/GraphTensorNetworks.jl/blob/master/examples/IndependentSet.jl\"","category":"page"},{"location":"tutorials/IndependentSet/#Independent-set-problem","page":"Independent set problem","title":"Independent set problem","text":"","category":"section"},{"location":"tutorials/IndependentSet/#Problem-definition","page":"Independent set problem","title":"Problem definition","text":"","category":"section"},{"location":"tutorials/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"In graph theory, an independent set is a set of vertices in a graph, no two of which are adjacent. In the following, we are going to defined the independent set problem on the Petersen graph.","category":"page"},{"location":"tutorials/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"using GraphTensorNetworks, Graphs\n\ngraph = Graphs.smallgraph(:petersen)","category":"page"},{"location":"tutorials/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"We can visualize this graph using the following function","category":"page"},{"location":"tutorials/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"rot15(a, b, i::Int) = cos(2i*π/5)*a + sin(2i*π/5)*b, cos(2i*π/5)*b - sin(2i*π/5)*a\n\nlocations = [[rot15(0.0, 1.0, i) for i=0:4]..., [rot15(0.0, 0.6, i) for i=0:4]...]\n\nshow_graph(graph; locs=locations)","category":"page"},{"location":"tutorials/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"In order to display your plot with show_graph, you need to call this function in","category":"page"},{"location":"tutorials/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"a VSCode editor,\na Jupyter notebook,\nor a Pluto notebook,","category":"page"},{"location":"tutorials/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"rather than a Julia REPL that does not have a graphical display.","category":"page"},{"location":"tutorials/IndependentSet/#Tensor-network-representation","page":"Independent set problem","title":"Tensor network representation","text":"","category":"section"},{"location":"tutorials/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"Let G=(VE) be the target graph that we want to solve. The tensor network representation map a vertex iin V to a label s_i in 0 1 of dimension 2 in a tensor network, where we use 0 (1) to denote a vertex is absent (present) in the set. For each label s_i, we defined a parametrized rank-one vertex tensor W(x_i) as","category":"page"},{"location":"tutorials/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"W(x_i) = left(beginmatrix\n    1 \n    x_i\nendmatrixright)","category":"page"},{"location":"tutorials/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"We use subscripts to index tensor elements, e.g. W(x_i)_0=1 is the first element associated with s_i=0 and W(x_i)_1=x_i is the second element associated with s_i=1. Similarly, on each edge (u v), we define a matrix B indexed by s_u and s_v as","category":"page"},{"location":"tutorials/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"B = left(beginmatrix\n    1   1\n    1  0\nendmatrixright)","category":"page"},{"location":"tutorials/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"We can use IndependentSet to construct a tensor network corresponding to the independent set problem on our target graph.","category":"page"},{"location":"tutorials/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"problem = IndependentSet(graph; optimizer=TreeSA());\nnothing #hide","category":"page"},{"location":"tutorials/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"Key word argument optimizer specifies the contraction order optimizer of the tensor network. Here we use the local search based optimizer TreeSA. The return value problem contains a field code that specifies the tensor network and its contraction order. The optimal contraction time and space complexity of an independent set problem is 2^rm tw(G), where rm tw(G) is the tree-width of G. One can check the time, space and read-write complexity with the following function.","category":"page"},{"location":"tutorials/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"timespacereadwrite_complexity(problem)","category":"page"},{"location":"tutorials/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"The return values are log2 of the the number of iterations, the number elements in the largest tensor during contraction and the number of tensor element read-write operations. For more information about how to improve the contraction order, please check the Performance Tips.","category":"page"},{"location":"tutorials/IndependentSet/#Solving-properties","page":"Independent set problem","title":"Solving properties","text":"","category":"section"},{"location":"tutorials/IndependentSet/#Maximum-independent-set-size-\\alpha(G)","page":"Independent set problem","title":"Maximum independent set size alpha(G)","text":"","category":"section"},{"location":"tutorials/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"maximum_independent_set_size = solve(problem, SizeMax())[]","category":"page"},{"location":"tutorials/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"Function solve takes two positional arguments, the problem instance and the wanted property. Here SizeMax means finding the solution with maximum set size.","category":"page"},{"location":"tutorials/IndependentSet/#Counting-properties","page":"Independent set problem","title":"Counting properties","text":"","category":"section"},{"location":"tutorials/IndependentSet/#counting-all-independent-sets","page":"Independent set problem","title":"counting all independent sets","text":"","category":"section"},{"location":"tutorials/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"count_all_independent_sets = solve(problem, CountingAll())[]","category":"page"},{"location":"tutorials/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"Here CountingAll means finding all possible solutions.","category":"page"},{"location":"tutorials/IndependentSet/#counting-independent-sets-with-sizes-\\alpha(G)-and-\\alpha(G)-1","page":"Independent set problem","title":"counting independent sets with sizes alpha(G) and alpha(G)-1","text":"","category":"section"},{"location":"tutorials/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"count_max2_independent_sets = solve(problem, CountingMax(2))[]","category":"page"},{"location":"tutorials/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"Here CountingMax means finding solutions with largest-2 sizes, the positional argument has default value 1.","category":"page"},{"location":"tutorials/IndependentSet/#independence-polynomial","page":"Independent set problem","title":"independence polynomial","text":"","category":"section"},{"location":"tutorials/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"The graph polynomial for the independent set problem is known as the independence polynomial.","category":"page"},{"location":"tutorials/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"I(G x) = sum_k=0^alpha(G) a_k x^k","category":"page"},{"location":"tutorials/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"where alpha(G) is the maximum independent set size, a_k is the number of independent sets of size k. The total number of independent sets is thus equal to I(G 1). There are 3 methods to compute a graph polynomial, :finitefield, :fft and :polynomial. These methods are introduced in the docstring of GraphPolynomial.","category":"page"},{"location":"tutorials/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"independence_polynomial = solve(problem, GraphPolynomial(; method=:finitefield))[]","category":"page"},{"location":"tutorials/IndependentSet/#Configuration-properties","page":"Independent set problem","title":"Configuration properties","text":"","category":"section"},{"location":"tutorials/IndependentSet/#finding-one-maximum-independent-set-(MIS)","page":"Independent set problem","title":"finding one maximum independent set (MIS)","text":"","category":"section"},{"location":"tutorials/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"One can use SingleConfigMax to find one of the solution with largest set size, and it has two implementations. The unbounded (default) version uses ConfigSampler to sample one of the best solutions directly. The bounded version uses the binary gradient back-propagation (see our paper) to compute the gradients. It requires caching intermediate states, but is often faster (on CPU) because it can use TropicalGEMM (see Performance Tips).","category":"page"},{"location":"tutorials/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"max_config = solve(problem, SingleConfigMax(; bounded=false))[]","category":"page"},{"location":"tutorials/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"The return value contains a bit string, and one should read this bit string from left to right. Having value 1 at i-th bit means vertex i is in the maximum independent set. One can visualize this MIS with the following function.","category":"page"},{"location":"tutorials/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"show_graph(graph; locs=locations, vertex_colors=\n    [iszero(max_config.c.data[i]) ? \"white\" : \"red\" for i=1:nv(graph)])","category":"page"},{"location":"tutorials/IndependentSet/#enumeration-of-all-MISs","page":"Independent set problem","title":"enumeration of all MISs","text":"","category":"section"},{"location":"tutorials/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"One can use ConfigsMax to find all solutions with largest-K set sizes. It also has two implementations. The bounded (default) version is always prefered because it can significantly use the memory usage.","category":"page"},{"location":"tutorials/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"all_max_configs = solve(problem, ConfigsMax(1; bounded=true))[]\n\nusing Compose\n\nm = length(all_max_configs.c)\n\nimgs = ntuple(k->show_graph(graph;\n                    locs=locations, scale=0.25,\n                    vertex_colors=[iszero(all_max_configs.c[k][i]) ? \"white\" : \"red\"\n                    for i=1:nv(graph)]), m);\n\nCompose.set_default_graphic_size(18cm, 4cm)\n\nCompose.compose(context(),\n     ntuple(k->(context((k-1)/m, 0.0, 1.2/m, 1.0), imgs[k]), m)...)","category":"page"},{"location":"tutorials/IndependentSet/#enumeration-of-all-IS-configurations","page":"Independent set problem","title":"enumeration of all IS configurations","text":"","category":"section"},{"location":"tutorials/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"One can use ConfigsAll to enumerate all sets satisfying the problem constraint.","category":"page"},{"location":"tutorials/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"all_independent_sets = solve(problem, ConfigsAll())[]","category":"page"},{"location":"tutorials/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"It is often difficult to store all configurations in a vector. A more clever way to store the data is using the TreeConfigEnumerator format.","category":"page"},{"location":"tutorials/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"all_independent_sets_tree = solve(problem, ConfigsAll(; tree_storage=true))[]","category":"page"},{"location":"tutorials/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"The results encode the configurations in the sum-product-tree format. One can count and enumerate them explicitly by typing","category":"page"},{"location":"tutorials/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"length(all_independent_sets_tree)","category":"page"},{"location":"tutorials/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"collect(all_independent_sets_tree)","category":"page"},{"location":"tutorials/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"To save/read a set of configuration to disk, one can type the following","category":"page"},{"location":"tutorials/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"filename = tempname()\n\nsave_configs(filename, all_independent_sets; format=:binary)\n\nloaded_sets = load_configs(filename; format=:binary, bitlength=10)","category":"page"},{"location":"tutorials/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"note: Note\nWhen loading data, one needs to provide the bitlength if the data is saved in binary format. Because the bitstring length is not stored.","category":"page"},{"location":"tutorials/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"note: Note\nCheck section Maximal independent set problem for examples of finding graph properties related to minimum sizes:SizeMin for enumerating minimum set size,\nCountingMin for enumerating minimum set size,\nSingleConfigMin for enumerating minimum set size,\nConfigsMin for enumerating minimum set size,","category":"page"},{"location":"tutorials/IndependentSet/#Weights-and-open-vertices","page":"Independent set problem","title":"Weights and open vertices","text":"","category":"section"},{"location":"tutorials/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"IndependentSet accepts weights as a key word argument. The following code computes the weighted MIS problem.","category":"page"},{"location":"tutorials/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"problem = IndependentSet(graph; weights=collect(1:10))\n\nmax_config_weighted = solve(problem, SingleConfigMax())[]\n\nshow_graph(graph; locs=locations, vertex_colors=\n          [iszero(max_config_weighted.c.data[i]) ? \"white\" : \"red\" for i=1:nv(graph)])","category":"page"},{"location":"tutorials/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"The following code computes the MIS tropical tensor (reference to be added) with open vertices 1, 2 and 3.","category":"page"},{"location":"tutorials/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"problem = IndependentSet(graph; openvertices=[1,2,3])\n\nmis_tropical_tensor = solve(problem, SizeMax())","category":"page"},{"location":"tutorials/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"The MIS tropical tensor shows the MIS size under different configuration of open vertices. It is useful in MIS tropical tensor analysis. One can compatify (reference to be added) this MIS-Tropical tensor by typing","category":"page"},{"location":"tutorials/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"mis_compactify!(mis_tropical_tensor)","category":"page"},{"location":"tutorials/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"It will eliminate some entries having no contribution to the MIS size when embeding this local graph into a larger one.","category":"page"},{"location":"tutorials/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"","category":"page"},{"location":"tutorials/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"performancetips/#Performance-Tips","page":"Performance Tips","title":"Performance Tips","text":"","category":"section"},{"location":"performancetips/#Optimize-tensor-network-contraction-order","page":"Performance Tips","title":"Optimize tensor network contraction order","text":"","category":"section"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"julia> using GraphTensorNetworks, Graphs, Random\n\njulia> graph = random_regular_graph(120, 3)\n{120, 180} undirected simple Int64 graph\n\njulia> problem = IndependentSet(graph; optimizer=TreeSA(\n    sc_target=20, sc_weight=1.0, rw_weight=3.0, ntrials=10, βs=0.01:0.1:15.0, niters=20), simplifier=MergeGreedy());","category":"page"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"Key word argument optimizer decides the contraction order optimizer of the tensor network. Here, we choose the TreeSA optimizer to optimize the tensor network contraciton tree, it is a local search based algorithm. It is one of the state of the art tensor network contraction order optimizers, one may check arXiv: 2108.05665 to learn more about the algorithm. Other optimizers include","category":"page"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"GreedyMethod (default, fastest in searching speed but worse in contraction order)\nTreeSA\nKaHyParBipartite\nSABipartite","category":"page"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"One can type ?TreeSA in a Julia REPL for more information about how to configure the hyper-parameters of TreeSA method. simplifier keyword argument is not so important, it is a preprocessing routine to improve the searching speed of the optimizer.","category":"page"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"The returned instance problem contains a field code that specifies the tensor network contraction order. For an independent set problem, its contraction time space complexity is 2^rm tw(G), where rm tw(G) is the tree-width of G. One can check the time, space and read-write complexity with the following function.","category":"page"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"julia> timespacereadwrite_complexity(problem)\n(21.90683335864693, 17.0, 20.03588509836998)","category":"page"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"The return values are log2 of the the number of iterations, the number elements in the largest tensor during contraction and the number of read-write operations to tensor elements. In this example, the number of + and * operations are both \\sim 2^{21.9} and the number of read-write operations are \\sim 2^{20}. The largest tensor size is 2^17, one can check the element size by typing","category":"page"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"julia> sizeof(TropicalF64)\n8\n\njulia> sizeof(TropicalF32)\n4\n\njulia> sizeof(StaticBitVector{200,4})\n32\n\njulia> sizeof(TruncatedPoly{5,Float64,Float64})\n48","category":"page"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"note: Note\nThe actual run time memory can be several times larger than the size of the maximum tensor.There is no constant bound for the factor, an empirical value for it is 3x.For mutable types like Polynomial and ConfigEnumerator, the sizeof function does not measure the actual element size.","category":"page"},{"location":"performancetips/#GEMM-for-Tropical-numbers","page":"Performance Tips","title":"GEMM for Tropical numbers","text":"","category":"section"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"You can speed up the Tropical number matrix multiplication when computing SizeMax() by using the Tropical GEMM routines implemented in package TropicalGEMM.jl.","category":"page"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"julia> using BenchmarkTools\n\njulia> @btime solve(problem, SizeMax())\n  91.630 ms (19203 allocations: 23.72 MiB)\n0-dimensional Array{TropicalF64, 0}:\n53.0ₜ\n\njulia> using TropicalGEMM\n\njulia> @btime solve(problem, SizeMax())\n  8.960 ms (18532 allocations: 17.01 MiB)\n0-dimensional Array{TropicalF64, 0}:\n53.0ₜ","category":"page"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"The TropicalGEMM pirates the LinearAlgebra.mul! interface, hence it takes effect upon using. The GEMM routine can speed up the computation on CPU for one order, with multi-threading, it can be even faster. Benchmark shows the performance of TropicalGEMM is close to the theoretical optimal value.","category":"page"},{"location":"performancetips/#Make-use-of-GPUs","page":"Performance Tips","title":"Make use of GPUs","text":"","category":"section"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"To upload the computing to GPU, you just add need to use CUDA, and offer a new key word argument.","category":"page"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"julia> using CUDA\n[ Info: OMEinsum loaded the CUDA module successfully\n\njulia> solve(problem, SizeMax(), usecuda=true)\n0-dimensional CuArray{TropicalF64, 0, CUDA.Mem.DeviceBuffer}:\n53.0ₜ","category":"page"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"CUDA backended properties are","category":"page"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"SizeMax\nCountingAll\nCountingMax\nGraphPolynomial\nSingleConfigMax","category":"page"},{"location":"tutorials/Coloring/","page":"Coloring problem","title":"Coloring problem","text":"EditURL = \"https://github.com/Happy-Diode/GraphTensorNetworks.jl/blob/master/examples/Coloring.jl\"","category":"page"},{"location":"tutorials/Coloring/#Coloring-problem","page":"Coloring problem","title":"Coloring problem","text":"","category":"section"},{"location":"tutorials/Coloring/","page":"Coloring problem","title":"Coloring problem","text":"note: Note\nIt is recommended to read the Independent set problem tutorial first to know more abouthow to optimize the tensor network contraction order,\nwhat graph properties are available and how to select correct method to compute graph properties,\nhow to compute weighted graphs and handle open vertices.","category":"page"},{"location":"tutorials/Coloring/#Problem-definition","page":"Coloring problem","title":"Problem definition","text":"","category":"section"},{"location":"tutorials/Coloring/","page":"Coloring problem","title":"Coloring problem","text":"A vertex coloring is an assignment of labels or colors to each vertex of a graph such that no edge connects two identically colored vertices. In the following, we are going to defined a 3-coloring problem for the Petersen graph.","category":"page"},{"location":"tutorials/Coloring/","page":"Coloring problem","title":"Coloring problem","text":"using GraphTensorNetworks, Graphs\n\ngraph = Graphs.smallgraph(:petersen)","category":"page"},{"location":"tutorials/Coloring/","page":"Coloring problem","title":"Coloring problem","text":"We can visualize this graph using the following function","category":"page"},{"location":"tutorials/Coloring/","page":"Coloring problem","title":"Coloring problem","text":"rot15(a, b, i::Int) = cos(2i*π/5)*a + sin(2i*π/5)*b, cos(2i*π/5)*b - sin(2i*π/5)*a\n\nlocations = [[rot15(0.0, 1.0, i) for i=0:4]..., [rot15(0.0, 0.6, i) for i=0:4]...]\n\nshow_graph(graph; locs=locations)","category":"page"},{"location":"tutorials/Coloring/#Tensor-network-representation","page":"Coloring problem","title":"Tensor network representation","text":"","category":"section"},{"location":"tutorials/Coloring/","page":"Coloring problem","title":"Coloring problem","text":"Type Coloring can be used for constructing the tensor network with optimized contraction order for a coloring problem. Let us use 3-colouring problem defined on vertices as an example. For a vertex v, we define the degree of freedoms c_vin123 and a vertex tensor labelled by it as","category":"page"},{"location":"tutorials/Coloring/","page":"Coloring problem","title":"Coloring problem","text":"W(v) = left(beginmatrix\n    1\n    1\n    1\nendmatrixright)","category":"page"},{"location":"tutorials/Coloring/","page":"Coloring problem","title":"Coloring problem","text":"For an edge (u v), we define an edge tensor as a matrix labelled by (c_u c_v) to specify the constraint","category":"page"},{"location":"tutorials/Coloring/","page":"Coloring problem","title":"Coloring problem","text":"B = left(beginmatrix\n    1  x  x\n    x  1  x\n    x  x  1\nendmatrixright)","category":"page"},{"location":"tutorials/Coloring/","page":"Coloring problem","title":"Coloring problem","text":"The number of possible colouring can be obtained by contracting this tensor network by setting vertex tensor elements r_v g_v and b_v to 1.","category":"page"},{"location":"tutorials/Coloring/","page":"Coloring problem","title":"Coloring problem","text":"We construct the tensor network for the 3-coloring problem as","category":"page"},{"location":"tutorials/Coloring/","page":"Coloring problem","title":"Coloring problem","text":"problem = Coloring{3}(graph);\nnothing #hide","category":"page"},{"location":"tutorials/Coloring/#Solving-properties","page":"Coloring problem","title":"Solving properties","text":"","category":"section"},{"location":"tutorials/Coloring/#counting-all-possible-coloring","page":"Coloring problem","title":"counting all possible coloring","text":"","category":"section"},{"location":"tutorials/Coloring/","page":"Coloring problem","title":"Coloring problem","text":"num_of_coloring = solve(problem, CountingMax())[]","category":"page"},{"location":"tutorials/Coloring/#finding-one-best-coloring","page":"Coloring problem","title":"finding one best coloring","text":"","category":"section"},{"location":"tutorials/Coloring/","page":"Coloring problem","title":"Coloring problem","text":"single_solution = solve(problem, SingleConfigMax())[]\n\nis_good_vertex_coloring(graph, single_solution.c.data)\n\nvertex_color_map = Dict(0=>\"red\", 1=>\"green\", 2=>\"blue\")\n\nshow_graph(graph; locs=locations, vertex_colors=[vertex_color_map[Int(c)]\n     for c in single_solution.c.data])","category":"page"},{"location":"tutorials/Coloring/","page":"Coloring problem","title":"Coloring problem","text":"Let us try to solve the same issue on its line graph, a graph that generated by mapping an edge to a vertex and two edges sharing a common vertex will be connected.","category":"page"},{"location":"tutorials/Coloring/","page":"Coloring problem","title":"Coloring problem","text":"linegraph = line_graph(graph)\n\nshow_graph(linegraph; locs=[0.5 .* (locations[e.src] .+ locations[e.dst])\n     for e in edges(graph)])","category":"page"},{"location":"tutorials/Coloring/","page":"Coloring problem","title":"Coloring problem","text":"Let us construct the tensor network and see if there are solutions.","category":"page"},{"location":"tutorials/Coloring/","page":"Coloring problem","title":"Coloring problem","text":"lineproblem = Coloring{3}(linegraph);\n\nnum_of_coloring = solve(lineproblem, CountingMax())[]","category":"page"},{"location":"tutorials/Coloring/","page":"Coloring problem","title":"Coloring problem","text":"You will see the maximum size 28 is smaller than the number of edges in the linegraph, meaning no solution for the 3-coloring on edges of a Petersen graph.","category":"page"},{"location":"tutorials/Coloring/","page":"Coloring problem","title":"Coloring problem","text":"","category":"page"},{"location":"tutorials/Coloring/","page":"Coloring problem","title":"Coloring problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/Matching/","page":"Matching problem","title":"Matching problem","text":"EditURL = \"https://github.com/Happy-Diode/GraphTensorNetworks.jl/blob/master/examples/Matching.jl\"","category":"page"},{"location":"tutorials/Matching/#Vertex-matching-problem","page":"Matching problem","title":"Vertex matching problem","text":"","category":"section"},{"location":"tutorials/Matching/","page":"Matching problem","title":"Matching problem","text":"note: Note\nIt is recommended to read the Independent set problem tutorial first to know more abouthow to optimize the tensor network contraction order,\nwhat graph properties are available and how to select correct method to compute graph properties,\nhow to compute weighted graphs and handle open vertices.","category":"page"},{"location":"tutorials/Matching/#Problem-definition","page":"Matching problem","title":"Problem definition","text":"","category":"section"},{"location":"tutorials/Matching/","page":"Matching problem","title":"Matching problem","text":"A k-matching in a graph G is a set of k edges, no two of which have a vertex in common.","category":"page"},{"location":"tutorials/Matching/","page":"Matching problem","title":"Matching problem","text":"using GraphTensorNetworks, Graphs","category":"page"},{"location":"tutorials/Matching/","page":"Matching problem","title":"Matching problem","text":"In the following, we are going to defined a matching problem for the Petersen graph.","category":"page"},{"location":"tutorials/Matching/","page":"Matching problem","title":"Matching problem","text":"graph = Graphs.smallgraph(:petersen)","category":"page"},{"location":"tutorials/Matching/","page":"Matching problem","title":"Matching problem","text":"We can visualize this graph using the following function","category":"page"},{"location":"tutorials/Matching/","page":"Matching problem","title":"Matching problem","text":"rot15(a, b, i::Int) = cos(2i*π/5)*a + sin(2i*π/5)*b, cos(2i*π/5)*b - sin(2i*π/5)*a\n\nlocations = [[rot15(0.0, 1.0, i) for i=0:4]..., [rot15(0.0, 0.6, i) for i=0:4]...]\n\nshow_graph(graph; locs=locations)","category":"page"},{"location":"tutorials/Matching/#Tensor-network-representation","page":"Matching problem","title":"Tensor network representation","text":"","category":"section"},{"location":"tutorials/Matching/","page":"Matching problem","title":"Matching problem","text":"Type Matching can be used for constructing the tensor network with optimized contraction order for a matching problem. We map an edge (u v) in E to a label langle u vrangle in 0 1 in a tensor network, where 1 means two vertices of an edge are matched, 0 means otherwise. Then we define a tensor of rank d(v) = N(v) on vertex v such that,","category":"page"},{"location":"tutorials/Matching/","page":"Matching problem","title":"Matching problem","text":"W_langle v n_1rangle langle v n_2 rangle ldots langle v n_d(v)rangle = begincases\n    1  sum_i=1^d(v) langle v n_i rangle leq 1\n    0  textotherwise\nendcases","category":"page"},{"location":"tutorials/Matching/","page":"Matching problem","title":"Matching problem","text":"and a tensor of rank 1 on the bond","category":"page"},{"location":"tutorials/Matching/","page":"Matching problem","title":"Matching problem","text":"B_langle v wrangle = begincases\n1  langle v w rangle = 0 \nx  langle v w rangle = 1\nendcases","category":"page"},{"location":"tutorials/Matching/","page":"Matching problem","title":"Matching problem","text":"where label langle v w rangle is equivalent to langle wvrangle.","category":"page"},{"location":"tutorials/Matching/","page":"Matching problem","title":"Matching problem","text":"We construct the tensor network for the matching problem by typing","category":"page"},{"location":"tutorials/Matching/","page":"Matching problem","title":"Matching problem","text":"problem = Matching(graph);\nnothing #hide","category":"page"},{"location":"tutorials/Matching/#Solving-properties","page":"Matching problem","title":"Solving properties","text":"","category":"section"},{"location":"tutorials/Matching/#Maximum-matching","page":"Matching problem","title":"Maximum matching","text":"","category":"section"},{"location":"tutorials/Matching/#Configuration-properties","page":"Matching problem","title":"Configuration properties","text":"","category":"section"},{"location":"tutorials/Matching/","page":"Matching problem","title":"Matching problem","text":"max_matching = solve(problem, SizeMax())[]","category":"page"},{"location":"tutorials/Matching/","page":"Matching problem","title":"Matching problem","text":"The largest number of matching is 5, which means we have a perfect matching (vertices are all paired).","category":"page"},{"location":"tutorials/Matching/#matching-polynomial","page":"Matching problem","title":"matching polynomial","text":"","category":"section"},{"location":"tutorials/Matching/","page":"Matching problem","title":"Matching problem","text":"The graph polynomial defined for the matching problem is known as the matching polynomial. Here, we adopt the first definition in the wiki page.","category":"page"},{"location":"tutorials/Matching/","page":"Matching problem","title":"Matching problem","text":"M(G x) = sumlimits_k=1^V2 c_k x^k","category":"page"},{"location":"tutorials/Matching/","page":"Matching problem","title":"Matching problem","text":"where k is the number of matches, and coefficients c_k are the corresponding counting.","category":"page"},{"location":"tutorials/Matching/","page":"Matching problem","title":"Matching problem","text":"matching_poly = solve(problem, GraphPolynomial())[]","category":"page"},{"location":"tutorials/Matching/#Configuration-properties-2","page":"Matching problem","title":"Configuration properties","text":"","category":"section"},{"location":"tutorials/Matching/#one-of-the-perfect-matches","page":"Matching problem","title":"one of the perfect matches","text":"","category":"section"},{"location":"tutorials/Matching/","page":"Matching problem","title":"Matching problem","text":"match_config = solve(problem, SingleConfigMax())[]","category":"page"},{"location":"tutorials/Matching/","page":"Matching problem","title":"Matching problem","text":"Let us show the result by coloring the matched edges to red","category":"page"},{"location":"tutorials/Matching/","page":"Matching problem","title":"Matching problem","text":"show_graph(graph; locs=locations, edge_colors=\n    [isone(match_config.c.data[i]) ? \"red\" : \"black\" for i=1:ne(graph)])","category":"page"},{"location":"tutorials/Matching/","page":"Matching problem","title":"Matching problem","text":"where we use edges with red color to related pairs of matched vertices.","category":"page"},{"location":"tutorials/Matching/","page":"Matching problem","title":"Matching problem","text":"","category":"page"},{"location":"tutorials/Matching/","page":"Matching problem","title":"Matching problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/unitdisk_graph/","page":"Solving independent set for a weighted unit disk graph","title":"Solving independent set for a weighted unit disk graph","text":"EditURL = \"https://github.com/Happy-Diode/GraphTensorNetworks.jl/blob/master/examples/unitdisk_graph.jl\"","category":"page"},{"location":"tutorials/unitdisk_graph/#Solving-independent-set-for-a-weighted-unit-disk-graph","page":"Solving independent set for a weighted unit disk graph","title":"Solving independent set for a weighted unit disk graph","text":"","category":"section"},{"location":"tutorials/unitdisk_graph/","page":"Solving independent set for a weighted unit disk graph","title":"Solving independent set for a weighted unit disk graph","text":"using GraphTensorNetworks, Graphs","category":"page"},{"location":"tutorials/unitdisk_graph/","page":"Solving independent set for a weighted unit disk graph","title":"Solving independent set for a weighted unit disk graph","text":"This example shows how to check the MIS degeneracy (another way of saying counting) of a weight unit disk graph. Let us construct a unit disk graph by specifying the locations of nodes, the unit disk radius is 1.5, which means two vertices within distance 1.5 are connected. For each vertex, we assign a weight to it.","category":"page"},{"location":"tutorials/unitdisk_graph/","page":"Solving independent set for a weighted unit disk graph","title":"Solving independent set for a weighted unit disk graph","text":"locations = [(6,-3),(1, -1), (0,0), (6,-2), (1,1), (2,0),\n     (2,2), (2,-2), (3,1), (3,-2), (4,1), (4,-1),\n     (5, 1), (5, -1), (6,0), (6,-1), (7,-1), (7, -4),\n     (8, -2), (8, -4), (9,-3)]\n\n\nweights = [0.7439015222121296, 0.722970984162338,\n     0.9502792990276312, 0.6617352332568173,\n     0.8592866066961992, 1.0, 1.0, 1.0, 1.0,\n     1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,\n     1.0, 1.0, 1.0, 1.0, 1.0]\n\ngraph = unit_disk_graph(locations, 1.5)\n\nshow_graph(graph; locs=locations)","category":"page"},{"location":"tutorials/unitdisk_graph/#Find-the-best-configurations","page":"Solving independent set for a weighted unit disk graph","title":"Find the best configurations","text":"","category":"section"},{"location":"tutorials/unitdisk_graph/","page":"Solving independent set for a weighted unit disk graph","title":"Solving independent set for a weighted unit disk graph","text":"We can easily check the MIS degeneracy by computing the CountingMax property.","category":"page"},{"location":"tutorials/unitdisk_graph/","page":"Solving independent set for a weighted unit disk graph","title":"Solving independent set for a weighted unit disk graph","text":"counting_mapped = solve(IndependentSet(graph; weights=weights), CountingMax())[]","category":"page"},{"location":"tutorials/unitdisk_graph/","page":"Solving independent set for a weighted unit disk graph","title":"Solving independent set for a weighted unit disk graph","text":"The MIS degeneracy is the second field, which is 3. We can compute the ConfigsMax to enumerate all configurations with maximum independent set size.","category":"page"},{"location":"tutorials/unitdisk_graph/","page":"Solving independent set for a weighted unit disk graph","title":"Solving independent set for a weighted unit disk graph","text":"configs_mapped = solve(IndependentSet(graph; weights=weights), ConfigsMax())[]","category":"page"},{"location":"tutorials/unitdisk_graph/","page":"Solving independent set for a weighted unit disk graph","title":"Solving independent set for a weighted unit disk graph","text":"Solution 1","category":"page"},{"location":"tutorials/unitdisk_graph/","page":"Solving independent set for a weighted unit disk graph","title":"Solving independent set for a weighted unit disk graph","text":"show_graph(graph; locs=locations, vertex_colors=\n          [iszero(configs_mapped.c[1][i]) ? \"white\" : \"red\" for i=1:nv(graph)])","category":"page"},{"location":"tutorials/unitdisk_graph/","page":"Solving independent set for a weighted unit disk graph","title":"Solving independent set for a weighted unit disk graph","text":"Solution 2","category":"page"},{"location":"tutorials/unitdisk_graph/","page":"Solving independent set for a weighted unit disk graph","title":"Solving independent set for a weighted unit disk graph","text":"show_graph(graph; locs=locations, vertex_colors=\n          [iszero(configs_mapped.c[2][i]) ? \"white\" : \"red\" for i=1:nv(graph)])","category":"page"},{"location":"tutorials/unitdisk_graph/","page":"Solving independent set for a weighted unit disk graph","title":"Solving independent set for a weighted unit disk graph","text":"Solution 3","category":"page"},{"location":"tutorials/unitdisk_graph/","page":"Solving independent set for a weighted unit disk graph","title":"Solving independent set for a weighted unit disk graph","text":"show_graph(graph; locs=locations, vertex_colors=\n          [iszero(configs_mapped.c[3][i]) ? \"white\" : \"red\" for i=1:nv(graph)])","category":"page"},{"location":"tutorials/unitdisk_graph/","page":"Solving independent set for a weighted unit disk graph","title":"Solving independent set for a weighted unit disk graph","text":"","category":"page"},{"location":"tutorials/unitdisk_graph/","page":"Solving independent set for a weighted unit disk graph","title":"Solving independent set for a weighted unit disk graph","text":"This page was generated using Literate.jl.","category":"page"},{"location":"ref/#References","page":"References","title":"References","text":"","category":"section"},{"location":"ref/#Graph-problems","page":"References","title":"Graph problems","text":"","category":"section"},{"location":"ref/","page":"References","title":"References","text":"solve\nGraphProblem\nIndependentSet\nMaximalIS\nMatching\nColoring\nMaxCut\nPaintShop\nSatisfiability","category":"page"},{"location":"ref/#GraphTensorNetworks.solve","page":"References","title":"GraphTensorNetworks.solve","text":"solve(problem, property; usecuda=false, T=Float64)\n\nSolving a certain property of a graph problem.\n\nPositional Arguments\n\nproblem is the graph problem with tensor network information,\nproperty is string specifying the task. Using the maximum independent set problem as an example, it can be one of\nSizeMax for finding maximum set size,\nSizeMin for finding minimum set size,\nCountingMax for counting configurations with largest-K sizes,\nCountingMin for counting configurations with smallest-K sizes,\nCountingAll for counting all configurations,\nGraphPolynomial for evaluating the graph polynomial,\nSingleConfigMax for finding one maximum configuration,\nConfigsMax for enumerating configurations with largest-K sizes,\nConfigsMin for enumerating configurations with smallest-K sizes,\nConfigsAll for enumerating all configurations,\n\nKeyword arguments\n\nusecuda is a switch to use CUDA (if possible), user need to call statement using CUDA before turning on this switch.\nT is the \"base\" element type, sometimes can be used to reduce the memory cost.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GraphTensorNetworks.GraphProblem","page":"References","title":"GraphTensorNetworks.GraphProblem","text":"GraphProblem\n\nThe abstract base type of graph problems.\n\n\n\n\n\n","category":"type"},{"location":"ref/#GraphTensorNetworks.IndependentSet","page":"References","title":"GraphTensorNetworks.IndependentSet","text":"IndependentSet{CT<:AbstractEinsum,WT<:Union{NoWeight, Vector}} <: GraphProblem\nIndependentSet(graph; weights=NoWeight(), openvertices=(),\n             optimizer=GreedyMethod(), simplifier=nothing)\n\nThe independent set problem in graph theory. In the constructor, weights are the weights of vertices. openvertices specifies labels for the output tensor. optimizer and simplifier are for tensor network optimization, check optimize_code for details.\n\n\n\n\n\n","category":"type"},{"location":"ref/#GraphTensorNetworks.MaximalIS","page":"References","title":"GraphTensorNetworks.MaximalIS","text":"MaximalIS{CT<:AbstractEinsum,WT<:Union{NoWeight, Vector}} <: GraphProblem\nMaximalIS(graph; weights=NoWeight(), openvertices=(),\n             optimizer=GreedyMethod(), simplifier=nothing)\n\nThe maximal independent set problem. In the constructor, weights are the weights of vertices. optimizer and simplifier are for tensor network optimization, check optimize_code for details.\n\n\n\n\n\n","category":"type"},{"location":"ref/#GraphTensorNetworks.Matching","page":"References","title":"GraphTensorNetworks.Matching","text":"Matching{CT<:AbstractEinsum} <: GraphProblem\nMatching(graph; openvertices=(), optimizer=GreedyMethod(), simplifier=nothing)\n\nThe Vertex matching problem. optimizer and simplifier are for tensor network optimization, check optimize_code for details.\n\n\n\n\n\n","category":"type"},{"location":"ref/#GraphTensorNetworks.Coloring","page":"References","title":"GraphTensorNetworks.Coloring","text":"Coloring{K,CT<:AbstractEinsum} <: GraphProblem\nColoring{K}(graph; openvertices=(), optimizer=GreedyMethod(), simplifier=nothing)\n\nThe Vertex Coloring problem. optimizer and simplifier are for tensor network optimization, check optimize_code for details.\n\n\n\n\n\n","category":"type"},{"location":"ref/#GraphTensorNetworks.MaxCut","page":"References","title":"GraphTensorNetworks.MaxCut","text":"MaxCut{CT<:AbstractEinsum,WT<:Union{NoWieght, Vector}} <: GraphProblem\nMaxCut(graph; weights=NoWeight(), openvertices=(),\n            optimizer=GreedyMethod(), simplifier=nothing)\n\nThe cutting problem (or spin glass problem). In the constructor, weights are the weights of edges. optimizer and simplifier are for tensor network optimization, check optimize_code for details.\n\n\n\n\n\n","category":"type"},{"location":"ref/#GraphTensorNetworks.PaintShop","page":"References","title":"GraphTensorNetworks.PaintShop","text":"PaintShop{CT<:AbstractEinsum} <: GraphProblem\nPaintShop(sequence::AbstractVector; openvertices=(),\n         optimizer=GreedyMethod(), simplifier=nothing)\n\nThe binary paint shop problem. optimizer and simplifier are for tensor network optimization, check optimize_code for details.\n\nExample\n\nOne can encode the paint shop problem abaccb as the following\n\njulia> syms = collect(\"abaccb\");\n\njulia> pb = PaintShop(syms);\n\njulia> solve(pb, SizeMin())[]\n2.0ₜ\n\njulia> solve(pb, ConfigsMin())[].c.data\n2-element Vector{StaticBitVector{3, 1}}:\n 100\n 011\n\nIn our definition, we find the maximum number of unchanged color in this sequence, i.e. (n-1) - (minimum number of color changes) In the output of maximum configurations, the two configurations are defined on 5 bonds i.e. pairs of (i, i+1), 0 means color changed, while 1 means color not changed. If we denote two \"colors\" as r and b, then the optimal painting is rbbbrr or brrrbb, both change the colors twice.\n\n\n\n\n\n","category":"type"},{"location":"ref/#GraphTensorNetworks.Satisfiability","page":"References","title":"GraphTensorNetworks.Satisfiability","text":"Satisfiability{CT<:AbstractEinsum,WT<:Union{NoWeight, Vector}} <: GraphProblem\nSatisfiability(cnf::CNF; openvertices=(),\n             optimizer=GreedyMethod(), simplifier=nothing)\n\nThe satisfiability problem. In the constructor, cnf is a logical expresion in conjunctive normal form (CNF) for the satisfiability problems. optimizer and simplifier are for tensor network optimization, check optimize_code for details.\n\n\n\n\n\n","category":"type"},{"location":"ref/","page":"References","title":"References","text":"set_packing","category":"page"},{"location":"ref/#GraphTensorNetworks.set_packing","page":"References","title":"GraphTensorNetworks.set_packing","text":"set_packing(sets; openvertices=(), optimizer=GreedyMethod(), simplifier=nothing)\n\nSet packing is a generalization of independent set problem to hypergraphs. Calling this function will return you an IndependentSet instance. sets are a vector of vectors, each element being a vertex in the independent set problem. optimizer and simplifier are for tensor network optimization, check optimize_code for details.\n\nExample\n\njulia> sets = [[1, 2, 5], [1, 3], [2, 4], [3, 6], [2, 3, 6]];  # each set is a vertex\n\njulia> gp = set_packing(sets);\n\njulia> res = best_solutions(gp; all=true)[]\n(2, {10010, 00110, 01100})ₜ\n\n\n\n\n\n","category":"function"},{"location":"ref/#Graph-Problem-Interfaces","page":"References","title":"Graph Problem Interfaces","text":"","category":"section"},{"location":"ref/","page":"References","title":"References","text":"To subtype GraphProblem, a new type must contain a code field to represent the (optimized) tensor network. Interfaces GraphTensorNetworks.generate_tensors, labels, flavors and get_weights are required. nflavor is optional.","category":"page"},{"location":"ref/","page":"References","title":"References","text":"GraphTensorNetworks.generate_tensors\nlabels\nflavors\nget_weights\nnflavor","category":"page"},{"location":"ref/#GraphTensorNetworks.generate_tensors","page":"References","title":"GraphTensorNetworks.generate_tensors","text":"generate_tensors(func, problem::GraphProblem)\n\nGenerate a vector of tensors as the inputs of the tensor network contraction code problem.code. func is a function to customize the tensors. func(symbol) returns a vector of elements, the length of which is same as the number of flavors.\n\nExample\n\nThe following code gives your the maximum independent set size\n\njulia> using Graphs, GraphTensorNetworks\n\njulia> gp = IndependentSet(smallgraph(:petersen));\n\njulia> getixsv(gp.code)\n25-element Vector{Vector{Int64}}:\n [1]\n [2]\n [3]\n [4]\n [5]\n [6]\n [7]\n [8]\n [9]\n [10]\n ⋮\n [3, 8]\n [4, 5]\n [4, 9]\n [5, 10]\n [6, 8]\n [6, 9]\n [7, 9]\n [7, 10]\n [8, 10]\n\njulia> gp.code(GraphTensorNetworks.generate_tensors(Tropical(1.0), gp)...)\n0-dimensional Array{TropicalF64, 0}:\n4.0ₜ\n\n\n\n\n\n","category":"function"},{"location":"ref/#GraphTensorNetworks.labels","page":"References","title":"GraphTensorNetworks.labels","text":"labels(problem::GraphProblem)\n\nThe labels of a graph problem is defined as the degrees of freedoms in the graph problem. e.g. for the maximum independent set problems, they are the indices of vertices: 1, 2, 3..., while for the max cut problem, they are the edges.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GraphTensorNetworks.flavors","page":"References","title":"GraphTensorNetworks.flavors","text":"flavors(::Type{<:GraphProblem})\n\nIt returns a vector of integers as the flavors of a degree of freedom. Its size is the same as the degree of freedom on a single vertex/edge.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GraphTensorNetworks.get_weights","page":"References","title":"GraphTensorNetworks.get_weights","text":"get_weights(problem::GraphProblem, sym)\n\nThe weights for the degree of freedom specified by sym of the graph problem, where sym is a symbol. In graph polynomial, integer weights are the orders of x.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GraphTensorNetworks.nflavor","page":"References","title":"GraphTensorNetworks.nflavor","text":"nflavor(::Type{<:GraphProblem})\n\nBond size is equal to the number of flavors.\n\n\n\n\n\n","category":"function"},{"location":"ref/#Graph-Problem-Utilities","page":"References","title":"Graph Problem Utilities","text":"","category":"section"},{"location":"ref/","page":"References","title":"References","text":"is_independent_set\nmis_compactify!\n\nis_maximal_independent_set\n\ncut_size\n\nnum_paint_shop_color_switch\npaint_shop_coloring_from_config\n\nis_good_vertex_coloring\n\nCNF\nCNFClause\nBoolVar\nsatisfiable\n@bools\n∨\n¬\n∧","category":"page"},{"location":"ref/#GraphTensorNetworks.is_independent_set","page":"References","title":"GraphTensorNetworks.is_independent_set","text":"is_independent_set(g::SimpleGraph, config)\n\nReturn true if config (a vector of boolean numbers as the mask of vertices) is an independent set of graph g.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GraphTensorNetworks.mis_compactify!","page":"References","title":"GraphTensorNetworks.mis_compactify!","text":"mis_compactify!(tropicaltensor)\n\nCompactify tropical tensor for maximum independent set problem. It will eliminate some entries by setting them to zero, by the criteria that removing these entry does not change the MIS size of its parent graph (reference to be added).\n\n\n\n\n\n","category":"function"},{"location":"ref/#GraphTensorNetworks.is_maximal_independent_set","page":"References","title":"GraphTensorNetworks.is_maximal_independent_set","text":"is_maximal_independent_set(g::SimpleGraph, config)\n\nReturn true if config (a vector of boolean numbers as the mask of vertices) is a maximal independent set of graph g.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GraphTensorNetworks.cut_size","page":"References","title":"GraphTensorNetworks.cut_size","text":"cut_size(g::SimpleGraph, config; weights=NoWeight())\n\nCompute the cut size from vertex config (an iterator).\n\n\n\n\n\n","category":"function"},{"location":"ref/#GraphTensorNetworks.num_paint_shop_color_switch","page":"References","title":"GraphTensorNetworks.num_paint_shop_color_switch","text":"num_paint_shop_color_switch(sequence::AbstractVector, coloring)\n\nReturns the number of color switches.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GraphTensorNetworks.paint_shop_coloring_from_config","page":"References","title":"GraphTensorNetworks.paint_shop_coloring_from_config","text":"paint_shop_coloring_from_config(p::PaintShop, config)\n\nReturns a valid painting from the paint shop configuration (given by the configuration solvers). The config is a sequence of 0 and 1, where 0 means painting the first appearence of a car in blue, 1 otherwise.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GraphTensorNetworks.is_good_vertex_coloring","page":"References","title":"GraphTensorNetworks.is_good_vertex_coloring","text":"is_good_vertex_coloring(graph::SimpleGraph, config)\n\nReturns true if the coloring specified by config is a valid one, i.e. does not violate the contraints of vertices of an edges having different colors.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GraphTensorNetworks.CNF","page":"References","title":"GraphTensorNetworks.CNF","text":"CNF{T}\nCNF(clauses)\n\nBoolean expression in conjunctive normal form. clauses is a vector of CNFClause, if and only if all clauses are satisfied, this CNF is satisfied.\n\nExample\n\njulia> @bools x y z\n\njulia> cnf = (x ∨ y) ∧ (¬y ∨ z)\n(x ∨ y) ∧ (¬y ∨ z)\n\njulia> satisfiable(cnf, Dict([:x=>true, :y=>false, :z=>true]))\ntrue\n\njulia> satisfiable(cnf, Dict([:x=>false, :y=>false, :z=>true]))\nfalse\n\n\n\n\n\n","category":"type"},{"location":"ref/#GraphTensorNetworks.CNFClause","page":"References","title":"GraphTensorNetworks.CNFClause","text":"CNFClause{T}\nCNFClause(vars)\n\nA clause in CNF, its value is the logical or of vars, where vars is a vector of BoolVar.\n\n\n\n\n\n","category":"type"},{"location":"ref/#GraphTensorNetworks.BoolVar","page":"References","title":"GraphTensorNetworks.BoolVar","text":"BoolVar{T}\nBoolVar(name, neg)\n\nBoolean variable for constructing CNF clauses.\n\n\n\n\n\n","category":"type"},{"location":"ref/#GraphTensorNetworks.satisfiable","page":"References","title":"GraphTensorNetworks.satisfiable","text":"satisfiable(cnf::CNF, config::AbstractDict)\n\nReturns true if an assignment of variables satisfies a CNF.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GraphTensorNetworks.@bools","page":"References","title":"GraphTensorNetworks.@bools","text":"@bools(syms::Symbol...)\n\nCreate some boolean variables of type BoolVar in current scope that can be used in create a CNF.\n\nExample\n\njulia> @bools x y z\n\njulia> (x ∨ y) ∧ (¬y ∨ z)\n(x ∨ y) ∧ (¬y ∨ z)\n\n\n\n\n\n","category":"macro"},{"location":"ref/#GraphTensorNetworks.:∨","page":"References","title":"GraphTensorNetworks.:∨","text":"∨(vars...)\n\nLogical or applied on BoolVar and CNFClause. Returns a CNFClause.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GraphTensorNetworks.:¬","page":"References","title":"GraphTensorNetworks.:¬","text":"¬(var::BoolVar)\n\nNegation of a boolean variables of type BoolVar.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GraphTensorNetworks.:∧","page":"References","title":"GraphTensorNetworks.:∧","text":"∧(vars...)\n\nLogical and applied on CNFClause and CNF. Returns a new CNF.\n\n\n\n\n\n","category":"function"},{"location":"ref/#Properties","page":"References","title":"Properties","text":"","category":"section"},{"location":"ref/","page":"References","title":"References","text":"SizeMax\nSizeMin\nCountingAll\nCountingMax\nCountingMin\nGraphPolynomial\nSingleConfigMax\nSingleConfigMin\nConfigsAll\nConfigsMax\nConfigsMin","category":"page"},{"location":"ref/#GraphTensorNetworks.SizeMax","page":"References","title":"GraphTensorNetworks.SizeMax","text":"SizeMax <: AbstractProperty\nSizeMax()\n\nThe maximum set size. e.g. the largest size of the IndependentSet  problem is also know as the independence number.\n\nThe corresponding tensor element type is max-plus tropical number Tropical.\nIt is compatible with weighted graph problems.\nBLAS (on CPU) and GPU are supported,\n\n\n\n\n\n","category":"type"},{"location":"ref/#GraphTensorNetworks.SizeMin","page":"References","title":"GraphTensorNetworks.SizeMin","text":"SizeMin <: AbstractProperty\nSizeMin()\n\nThe maximum set size. e.g. the smallest size ofthe MaximalIS problem is also known as the independent domination number.\n\nThe corresponding tensor element type inverted max-plus tropical number Tropical, which is equivalent to the min-plus tropical number.\nIt is compatible with weighted graph problems.\nBLAS (on CPU) and GPU are supported,\n\n\n\n\n\n","category":"type"},{"location":"ref/#GraphTensorNetworks.CountingAll","page":"References","title":"GraphTensorNetworks.CountingAll","text":"CountingAll <: AbstractProperty\nCountingAll()\n\nCounting the total number of sets. e.g. for the IndependentSet problem, it counts the independent sets.\n\nThe corresponding tensor element type is Base.Real.\nThe weights on graph does not have effect.\nBLAS (GPU and CPU) and GPU are supported,\n\n\n\n\n\n","category":"type"},{"location":"ref/#GraphTensorNetworks.CountingMax","page":"References","title":"GraphTensorNetworks.CountingMax","text":"CountingMax{K} <: AbstractProperty\nCountingMax(K=1)\n\nCounting the number of sets with largest-K size. e.g. for IndependentSet problem, it counts independent sets of size alpha(G) alpha(G)-1 ldots alpha(G)-K+1.\n\nThe corresponding tensor element type is CountingTropical for K == 1, and TruncatedPoly{K} for K > 1.\nWeighted graph problems is only supported for K == 1.\nGPU is supported,\n\n\n\n\n\n","category":"type"},{"location":"ref/#GraphTensorNetworks.CountingMin","page":"References","title":"GraphTensorNetworks.CountingMin","text":"CountingMin{K} <: AbstractProperty\nCountingMin(K=1)\n\nCounting the number of sets with smallest-K size.\n\nThe corresponding tensor element type is inverted CountingTropical for K == 1, and TruncatedPoly{K} for K > 1.\nWeighted graph problems is only supported for K == 1.\nGPU is supported,\n\n\n\n\n\n","category":"type"},{"location":"ref/#GraphTensorNetworks.GraphPolynomial","page":"References","title":"GraphTensorNetworks.GraphPolynomial","text":"GraphPolynomial{METHOD} <: AbstractProperty\nGraphPolynomial(; method=:finitefield, kwargs...)\n\nCompute the graph polynomial, e.g. for IndependentSet problem, it is the independence polynomial. The METHOD type parameter can be one of the following symbols\n\nMethod Argument\n\n:finitefield, uses finite field algebra to fit the polynomial.\nThe corresponding tensor element type is Mods.Mod,\nIt does not have round-off error,\nGPU is supported,\nIt accepts keyword arguments maxorder (optional, e.g. the MIS size in the IndependentSet problem).\n:polynomial, use polynomial numbers to solve the polynomial directly.\nThe corresponding tensor element type is Polynomials.Polynomial.\nIt might have small round-off error depending on the data type for storing the counting.\nIt has memory overhead that linear to the graph size.\n:fft, use fast fourier transformation to fit the polynomial.\nThe corresponding tensor element type is Base.Complex.\nIt has (controllable) round-off error.\nBLAS and GPU are supported.\nIt accepts keyword arguments maxorder (optional) and r,   if r > 1, one has better precision for coefficients of large order, if r < 1,   one has better precision for coefficients of small order.\n\nGraph polynomials are not defined for weighted graph problems.\n\n\n\n\n\n","category":"type"},{"location":"ref/#GraphTensorNetworks.SingleConfigMax","page":"References","title":"GraphTensorNetworks.SingleConfigMax","text":"SingleConfigMax{BOUNDED} <: AbstractProperty\nSingleConfigMax(; bounded=false)\n\nFinding single best solution, e.g. for IndependentSet problem, it is one of the maximum independent sets.\n\nThe corresponding data type is CountingTropical{Float64,<:ConfigSampler} if BOUNDED is false, Tropical otherwise.\nWeighted graph problems is supported.\nGPU is supported,\n\nKeyword Arguments\n\nbounded, if it is true, use bounding trick (or boolean gradients) to reduce the working memory to store intermediate configurations.\n\n\n\n\n\n","category":"type"},{"location":"ref/#GraphTensorNetworks.SingleConfigMin","page":"References","title":"GraphTensorNetworks.SingleConfigMin","text":"SingleConfigMin{BOUNDED} <: AbstractProperty\nSingleConfigMin(; bounded=false)\n\nFinding single \"worst\" solution.\n\nThe corresponding data type is inverted CountingTropical{Float64,<:ConfigSampler} if BOUNDED is false, inverted Tropical otherwise.\nWeighted graph problems is supported.\nGPU is supported,\n\nKeyword Arguments\n\nbounded, if it is true, use bounding trick (or boolean gradients) to reduce the working memory to store intermediate configurations.\n\n\n\n\n\n","category":"type"},{"location":"ref/#GraphTensorNetworks.ConfigsAll","page":"References","title":"GraphTensorNetworks.ConfigsAll","text":"ConfigsAll{TREESTORAGE} <:AbstractProperty\nConfigsAll(; tree_storage=false)\n\nFind all valid configurations, e.g. for IndependentSet problem, it is finding all independent sets.\n\nThe corresponding data type is ConfigEnumerator.\nWeights do not take effect.\n\nKeyword Arguments\n\ntree_storage, if it is true, it uses more memory efficient tree-structure to store the configurations.\n\n\n\n\n\n","category":"type"},{"location":"ref/#GraphTensorNetworks.ConfigsMax","page":"References","title":"GraphTensorNetworks.ConfigsMax","text":"ConfigsMax{K, BOUNDED, TREESTORAGE} <:AbstractProperty\nConfigsMax(K=1; bounded=true, tree_storage=true)\n\nFind configurations with largest-K sizes, e.g. for IndependentSet problem, it is finding all independent sets of sizes alpha(G) alpha(G)-1 ldots alpha(G)-K+1.\n\nThe corresponding data type is CountingTropical{Float64,<:ConfigEnumerator} for K == 1 and TruncatedPoly{K,<:ConfigEnumerator} for K > 1.\nWeighted graph problems is only supported for K == 1.\n\nKeyword Arguments\n\nbounded, if it is true, use bounding trick (or boolean gradients) to reduce the working memory to store intermediate configurations.\ntree_storage, if it is true, it uses more memory efficient tree-structure to store the configurations.\n\n\n\n\n\n","category":"type"},{"location":"ref/#GraphTensorNetworks.ConfigsMin","page":"References","title":"GraphTensorNetworks.ConfigsMin","text":"ConfigsMin{K, BOUNDED, TREESTORAGE} <:AbstractProperty\nConfigsMin(K=1; bounded=true, tree_storage=false)\n\nFind configurations with smallest-K sizes.\n\nThe corresponding data type is inverted CountingTropical{Float64,<:ConfigEnumerator} for K == 1 and inverted TruncatedPoly{K,<:ConfigEnumerator} for K > 1.\nWeighted graph problems is only supported for K == 1.\n\nKeyword Arguments\n\nbounded, if it is true, use bounding trick (or boolean gradients) to reduce the working memory to store intermediate configurations.\ntree_storage, if it is true, it uses more memory efficient tree-structure to store the configurations.\n\n\n\n\n\n","category":"type"},{"location":"ref/#Element-Algebras","page":"References","title":"Element Algebras","text":"","category":"section"},{"location":"ref/","page":"References","title":"References","text":"is_commutative_semiring","category":"page"},{"location":"ref/#GraphTensorNetworks.is_commutative_semiring","page":"References","title":"GraphTensorNetworks.is_commutative_semiring","text":"is_commutative_semiring(a::T, b::T, c::T) where T\n\nCheck if elements a, b and c satisfied the commutative semiring requirements.\n\nbeginalign*\n(a oplus b) oplus c = a oplus (b oplus c)  hspace5emtrianglerighttextcommutative monoid oplus with identity mathbb0\na oplus mathbb0 = mathbb0 oplus a = a \na oplus b = b oplus a \n\n(a odot b) odot c = a odot (b odot c)     hspace5emtriangleright textcommutative monoid odot with identity mathbb1\na odot  mathbb1 =  mathbb1 odot a = a \na odot b = b odot a \n\na odot (boplus c) = aodot b oplus aodot c    hspace5emtriangleright textleft and right distributive\n(aoplus b) odot c = aodot c oplus bodot c \n\na odot mathbb0 = mathbb0 odot a = mathbb0\nendalign*\n\n\n\n\n\n","category":"function"},{"location":"ref/","page":"References","title":"References","text":"TropicalNumbers.Tropical\nTropicalNumbers.CountingTropical\nMods.Mod\nPolynomials.Polynomial\nTruncatedPoly\nMax2Poly\nConfigEnumerator\nTreeConfigEnumerator\nConfigSampler","category":"page"},{"location":"ref/#TropicalNumbers.Tropical","page":"References","title":"TropicalNumbers.Tropical","text":"Tropical{T} <: Number\n\nTropical number is a semiring algebra that maps\n\n+ in regular algebra to max,\n* in regular algebra to +,\n1 in regular algebra to 0,\n0 in regular algebra to -Inf (for integer content types, this is chosen as a mall integer).\n\nWe implemented fast tropical matrix multiplication in TropicalGEMM.\n\nExample\n\njulia> Tropical(1.0) + Tropical(3.0)\n3.0ₜ\n\njulia> Tropical(1.0) * Tropical(3.0)\n4.0ₜ\n\njulia> one(TropicalF64)\n0.0ₜ\n\njulia> zero(TropicalF64)\n-Infₜ\n\n\n\n\n\n","category":"type"},{"location":"ref/#TropicalNumbers.CountingTropical","page":"References","title":"TropicalNumbers.CountingTropical","text":"CountingTropical{T,CT} <: Number\n\nCounting tropical number type is also a semiring algebra. It is tropical algebra with one extra field for counting, it is introduced in arXiv:2008.06888.\n\nExample\n\njulia> CountingTropical(1.0, 5.0) + CountingTropical(3.0, 2.0)\n(3.0, 2.0)ₜ\n\njulia> CountingTropical(1.0, 5.0) * CountingTropical(3.0, 2.0)\n(4.0, 10.0)ₜ\n\njulia> one(CountingTropicalF64)\n(0.0, 1.0)ₜ\n\njulia> zero(CountingTropicalF64)\n(-Inf, 0.0)ₜ\n\n\n\n\n\n","category":"type"},{"location":"ref/#Mods.Mod","page":"References","title":"Mods.Mod","text":"Mod{m}(v) creates a modular number in mod m with value mod(v,m).\n\n\n\n\n\n","category":"type"},{"location":"ref/#Polynomials.Polynomial","page":"References","title":"Polynomials.Polynomial","text":"Polynomial{T, X}(coeffs::AbstractVector{T}, [var = :x])\n\nConstruct a polynomial from its coefficients coeffs, lowest order first, optionally in terms of the given variable var which may be a character, symbol, or a string.\n\nIf p = a_n x^n + ldots + a_2 x^2 + a_1 x + a_0, we construct this through Polynomial([a_0, a_1, ..., a_n]).\n\nThe usual arithmetic operators are overloaded to work with polynomials as well as with combinations of polynomials and scalars. However, operations involving two polynomials of different variables causes an error except those involving a constant polynomial.\n\nnote: Note\nPolynomial is not axis-aware, and it treats coeffs simply as a list of coefficients with the first index always corresponding to the constant term. In order to use the axis of coeffs as exponents, consider using a LaurentPolynomial or possibly a SparsePolynomial.\n\nExamples\n\njulia> using Polynomials\n\njulia> Polynomial([1, 0, 3, 4])\nPolynomial(1 + 3*x^2 + 4*x^3)\n\njulia> Polynomial([1, 2, 3], :s)\nPolynomial(1 + 2*s + 3*s^2)\n\njulia> one(Polynomial)\nPolynomial(1.0)\n\n\n\n\n\n","category":"type"},{"location":"ref/#GraphTensorNetworks.TruncatedPoly","page":"References","title":"GraphTensorNetworks.TruncatedPoly","text":"TruncatedPoly{K,T,TO} <: Number\nTruncatedPoly(coeffs::Tuple, maxorder)\n\nPolynomial truncated to largest K orders. T is the coefficients type and TO is the orders type.\n\nExample\n\njulia> TruncatedPoly((1,2,3), 6)\nx^4 + 2*x^5 + 3*x^6\n\njulia> TruncatedPoly((1,2,3), 6) * TruncatedPoly((5,2,1), 3)\n20*x^7 + 8*x^8 + 3*x^9\n\njulia> TruncatedPoly((1,2,3), 6) + TruncatedPoly((5,2,1), 3)\nx^4 + 2*x^5 + 3*x^6\n\n\n\n\n\n","category":"type"},{"location":"ref/#GraphTensorNetworks.Max2Poly","page":"References","title":"GraphTensorNetworks.Max2Poly","text":"Max2Poly{T,TO} = TruncatedPoly{2,T,TO}\nMax2Poly(a, b, maxorder)\n\nA shorthand of TruncatedPoly{2}.\n\n\n\n\n\n","category":"type"},{"location":"ref/#GraphTensorNetworks.ConfigEnumerator","page":"References","title":"GraphTensorNetworks.ConfigEnumerator","text":"ConfigEnumerator{N,S,C} <: AbstractSetNumber\n\nSet algebra for enumerating configurations, where N is the length of configurations, C is the size of storage in unit of UInt64, S is the bit width to store a single element in a configuration, i.e. log2(# of flavors), for bitstrings, it is 1`.\n\nExample\n\njulia> a = ConfigEnumerator([StaticBitVector([1,1,1,0,0]), StaticBitVector([1,0,0,0,1])])\n{11100, 10001}\n\njulia> b = ConfigEnumerator([StaticBitVector([0,0,0,0,0]), StaticBitVector([1,0,1,0,1])])\n{00000, 10101}\n\njulia> a + b\n{11100, 10001, 00000, 10101}\n\njulia> one(a)\n{00000}\n\njulia> zero(a)\n{}\n\n\n\n\n\n","category":"type"},{"location":"ref/#GraphTensorNetworks.TreeConfigEnumerator","page":"References","title":"GraphTensorNetworks.TreeConfigEnumerator","text":"TreeConfigEnumerator{N,S,C} <: AbstractSetNumber\n\nConfiguration enumerator encoded in a tree, it is the most natural representation given by a sum-product network and is often more memory efficient than putting the configurations in a vector. N, S and C are type parameters from the StaticElementVector{N,S,C}.\n\nFields\n\ntag is one of ZERO, LEAF, SUM, PROD.\ndata is the element stored in a LEAF node.\nleft and right are two operands of a SUM or PROD node.\n\nExample\n\njulia> s = TreeConfigEnumerator(bv\"00111\")\n00111\n\n\njulia> q = TreeConfigEnumerator(bv\"10000\")\n10000\n\n\njulia> x = s + q\n+\n├─ 00111\n└─ 10000\n\n\njulia> y = x * x\n*\n├─ +\n│  ├─ 00111\n│  └─ 10000\n└─ +\n   ├─ 00111\n   └─ 10000\n\n\njulia> collect(y)\n4-element Vector{StaticBitVector{5, 1}}:\n 00111\n 10111\n 10111\n 10000\n\njulia> zero(s)\n∅\n\n\n\njulia> one(s)\n00000\n\n\n\n\n\n\n\n","category":"type"},{"location":"ref/#GraphTensorNetworks.ConfigSampler","page":"References","title":"GraphTensorNetworks.ConfigSampler","text":"ConfigSampler{N,S,C} <: AbstractSetNumber\nConfigSampler(elements::StaticElementVector)\n\nThe algebra for sampling one configuration, where N is the length of configurations, C is the size of storage in unit of UInt64, S is the bit width to store a single element in a configuration, i.e. log2(# of flavors), for bitstrings, it is 1`.\n\nnote: Note\nConfigSampler is a probabilistic commutative semiring, adding two config samplers do not give you deterministic results.\n\nExample\n\njulia> ConfigSampler(StaticBitVector([1,1,1,0,0]))\nConfigSampler{5, 1, 1}(11100)\n\njulia> ConfigSampler(StaticBitVector([1,1,1,0,0])) + ConfigSampler(StaticBitVector([1,0,1,0,0]))\nConfigSampler{5, 1, 1}(10100)\n\njulia> ConfigSampler(StaticBitVector([1,1,1,0,0])) * ConfigSampler(StaticBitVector([0,0,0,0,1]))\nConfigSampler{5, 1, 1}(11101)\n\njulia> one(ConfigSampler{5, 1, 1})\nConfigSampler{5, 1, 1}(00000)\n\njulia> zero(ConfigSampler{5, 1, 1})\nConfigSampler{5, 1, 1}(11111)\n\n\n\n\n\n","category":"type"},{"location":"ref/","page":"References","title":"References","text":"StaticBitVector\nStaticElementVector\nsave_configs\nload_configs\n@bv_str\nonehotv","category":"page"},{"location":"ref/#GraphTensorNetworks.StaticBitVector","page":"References","title":"GraphTensorNetworks.StaticBitVector","text":"StaticBitVector{N,C} = StaticElementVector{N,1,C}\nStaticBitVector(x::AbstractVector)\n\nExample\n\njulia> sb = StaticBitVector([1,0,0,1,1])\n10011\n\njulia> sb[3]\n0x0000000000000000\n\n\n\n\n\n","category":"type"},{"location":"ref/#GraphTensorNetworks.StaticElementVector","page":"References","title":"GraphTensorNetworks.StaticElementVector","text":"StaticElementVector{N,S,C}\nStaticElementVector(nflavor::Int, x::AbstractVector)\n\nN is the length of vector, C is the size of storage in unit of UInt64, S is the stride defined as the log2(# of flavors). When the number of flavors is 2, it is a StaticBitVector.\n\nExample\n\njulia> ev = StaticElementVector(3, [1,2,0,1,2])\n12012\n\njulia> ev[2]\n0x0000000000000002\n\n\n\n\n\n","category":"type"},{"location":"ref/#GraphTensorNetworks.save_configs","page":"References","title":"GraphTensorNetworks.save_configs","text":"save_configs(filename, data::ConfigEnumerator; format=:binary)\n\nSave configurations data to file filename. The format is :binary or :text.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GraphTensorNetworks.load_configs","page":"References","title":"GraphTensorNetworks.load_configs","text":"load_configs(filename; format=:binary, bitlength=nothing, nflavors=2)\n\nLoad configurations from file filename. The format is :binary or :text. If the format is :binary, the bitstring length bitlength must be specified, nflavors specifies the degree of freedom.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GraphTensorNetworks.@bv_str","page":"References","title":"GraphTensorNetworks.@bv_str","text":"Constructing a static bit vector.\n\n\n\n\n\n","category":"macro"},{"location":"ref/#GraphTensorNetworks.onehotv","page":"References","title":"GraphTensorNetworks.onehotv","text":"onehotv(::Type{<:StaticElementVector}, i, v)\nonehotv(::Type{<:StaticBitVector, i)\n\nReturns a static element vector, with the value at location i being v (1 if not specified).\n\n\n\n\n\n","category":"function"},{"location":"ref/#Tensor-Network","page":"References","title":"Tensor Network","text":"","category":"section"},{"location":"ref/","page":"References","title":"References","text":"optimize_code\ngetixsv\ngetiyv\ntimespace_complexity\ntimespacereadwrite_complexity\n@ein_str\nGreedyMethod\nTreeSA\nSABipartite\nKaHyParBipartite\nMergeVectors\nMergeGreedy","category":"page"},{"location":"ref/#OMEinsumContractionOrders.optimize_code","page":"References","title":"OMEinsumContractionOrders.optimize_code","text":"optimize_code(eincode, size_dict, optimizer = GreedyMethod(), simplifier=nothing, permute=true)\n\nOptimize the einsum contraction code and reduce the time/space complexity of tensor network contraction. Returns a NestedEinsum instance. Input arguments are\n\neincode is an einsum contraction code instance, one of DynamicEinCode, StaticEinCode or NestedEinsum.\nsize is a dictionary of \"edge label=>edge size\" that contains the size information, one can use uniformsize(eincode, 2) to create a uniform size.\noptimizer is a CodeOptimizer instance, should be one of GreedyMethod, KaHyParBipartite, SABipartite or TreeSA. Check their docstrings for details.\nsimplifier is one of MergeVectors or MergeGreedy.\noptimize the permutation if permute is true.\n\n\n\n\n\n","category":"function"},{"location":"ref/#OMEinsum.getixsv","page":"References","title":"OMEinsum.getixsv","text":"getixsv(code)\n\nGet labels of input tensors for EinCode, NestedEinsum and some other einsum like objects. Returns a vector of vector.\n\njulia> getixsv(ein\"(ij,jk),k->i\")\n3-element Vector{Vector{Char}}:\n ['i', 'j']\n ['j', 'k']\n ['k']\n\n\n\n\n\n","category":"function"},{"location":"ref/#OMEinsum.getiyv","page":"References","title":"OMEinsum.getiyv","text":"getiy(code)\n\nGet labels of the output tensor for EinCode, NestedEinsum and some other einsum like objects. Returns a vector.\n\njulia> getiyv(ein\"(ij,jk),k->i\")\n1-element Vector{Char}:\n 'i': ASCII/Unicode U+0069 (category Ll: Letter, lowercase)\n\n\n\n\n\n","category":"function"},{"location":"ref/#OMEinsum.timespace_complexity","page":"References","title":"OMEinsum.timespace_complexity","text":"timespace_complexity(eincode, size_dict)\n\nReturns the time and space complexity of the einsum contraction. The time complexity is defined as log2(number of element multiplication). The space complexity is defined as log2(size of the maximum intermediate tensor).\n\n\n\n\n\n","category":"function"},{"location":"ref/#OMEinsum.timespacereadwrite_complexity","page":"References","title":"OMEinsum.timespacereadwrite_complexity","text":"timespacereadwrite_complexity(eincode, size_dict)\n\nReturns the time, space and read-write complexity of the einsum contraction. The time complexity is defined as log2(number of element-wise multiplication). The space complexity is defined as log2(size of the maximum intermediate tensor). The read-write complexity is defined as log2(the number of read-write operations).\n\n\n\n\n\n","category":"function"},{"location":"ref/#OMEinsum.@ein_str","page":"References","title":"OMEinsum.@ein_str","text":"ein\"ij,jk -> ik\"(A,B)\n\nString macro interface which understands numpy.einsum's notation. Translates strings into StaticEinCode-structs that can be called to evaluate an einsum. To control evaluation order, use parentheses - instead of an EinCode, a NestedEinsum is returned which evaluates the expression according to parens. The valid character ranges for index-labels are a-z and α-ω.\n\nexample\n\njulia> a, b, c = rand(10,10), rand(10,10), rand(10,1);\n\njulia> ein\"ij,jk,kl -> il\"(a,b,c) ≈ ein\"(ij,jk),kl -> il\"(a,b,c) ≈ a * b * c\ntrue\n\n\n\n\n\n","category":"macro"},{"location":"ref/#OMEinsumContractionOrders.GreedyMethod","page":"References","title":"OMEinsumContractionOrders.GreedyMethod","text":"GreedyMethod{MT}\nGreedyMethod(; method=MinSpaceOut(), nrepeat=10)\n\nThe fast but poor greedy optimizer. Input arguments are\n\nmethod is MinSpaceDiff() or MinSpaceOut.\nMinSpaceOut choose one of the contraction that produces a minimum output tensor size,\nMinSpaceDiff choose one of the contraction that decrease the space most.\nnrepeat is the number of repeatition, returns the best contraction order.\n\n\n\n\n\n","category":"type"},{"location":"ref/#OMEinsumContractionOrders.TreeSA","page":"References","title":"OMEinsumContractionOrders.TreeSA","text":"TreeSA{RT,IT,GM}\nTreeSA(; sc_target=20, βs=collect(0.01:0.05:15), ntrials=10, niters=50,\n    sc_weight=1.0, rw_weight=0.2, initializer=:greedy, greedy_config=GreedyMethod(; nrepeat=1))\n\nOptimize the einsum contraction pattern using the simulated annealing on tensor expression tree.\n\nsc_target is the target space complexity,\nntrials, βs and niters are annealing parameters, doing ntrials indepedent annealings, each has inverse tempteratures specified by βs, in each temperature, do niters updates of the tree.\nsc_weight is the relative importance factor of space complexity in the loss compared with the time complexity.\nrw_weight is the relative importance factor of memory read and write in the loss compared with the time complexity.\ninitializer specifies how to determine the initial configuration, it can be :greedy or :random. If it is using :greedy method to generate the initial configuration, it also uses two extra arguments greedy_method and greedy_nrepeat.\nnslices is the number of sliced legs, default is 0.\n\nReferences\n\nRecursive Multi-Tensor Contraction for XEB Verification of Quantum Circuits\n\n\n\n\n\n","category":"type"},{"location":"ref/#OMEinsumContractionOrders.SABipartite","page":"References","title":"OMEinsumContractionOrders.SABipartite","text":"SABipartite{RT,BT}\nSABipartite(; sc_target=25, ntrials=50, βs=0.1:0.2:15.0, niters=1000\n    max_group_size=40, greedy_config=GreedyMethod(), initializer=:random)\n\nOptimize the einsum code contraction order using the Simulated Annealing bipartition + Greedy approach. This program first recursively cuts the tensors into several groups using simulated annealing, with maximum group size specifed by max_group_size and maximum space complexity specified by sc_target, Then finds the contraction order inside each group with the greedy search algorithm. Other arguments are\n\nsize_dict, a dictionary that specifies leg dimensions,\nsc_target is the target space complexity, defined as log2(number of elements in the largest tensor),\nmax_group_size is the maximum size that allowed to used greedy search,\nβs is a list of inverse temperature 1/T,\nniters is the number of iteration in each temperature,\nntrials is the number of repetition (with different random seeds),\ngreedy_config configures the greedy method,\ninitializer, the partition configuration initializer, one can choose :random or :greedy (slow but better).\n\nReferences\n\nHyper-optimized tensor network contraction\n\n\n\n\n\n","category":"type"},{"location":"ref/#OMEinsumContractionOrders.KaHyParBipartite","page":"References","title":"OMEinsumContractionOrders.KaHyParBipartite","text":"KaHyParBipartite{RT,IT,GM}\nKaHyParBipartite(; sc_target, imbalances=collect(0.0:0.005:0.8),\n    max_group_size=40, greedy_config=GreedyMethod())\n\nOptimize the einsum code contraction order using the KaHyPar + Greedy approach. This program first recursively cuts the tensors into several groups using KaHyPar, with maximum group size specifed by max_group_size and maximum space complexity specified by sc_target, Then finds the contraction order inside each group with the greedy search algorithm. Other arguments are\n\nsc_target is the target space complexity, defined as log2(number of elements in the largest tensor),\nimbalances is a KaHyPar parameter that controls the group sizes in hierarchical bipartition,\nmax_group_size is the maximum size that allowed to used greedy search,\ngreedy_config is a greedy optimizer.\n\nReferences\n\nHyper-optimized tensor network contraction\nSimulating the Sycamore quantum supremacy circuits\n\n\n\n\n\n","category":"type"},{"location":"ref/#OMEinsumContractionOrders.MergeVectors","page":"References","title":"OMEinsumContractionOrders.MergeVectors","text":"MergeVectors <: CodeSimplifier\nMergeVectors()\n\nContraction code simplifier (in order to reduce the time of calling optimizers) that merges vectors to closest tensors.\n\n\n\n\n\n","category":"type"},{"location":"ref/#OMEinsumContractionOrders.MergeGreedy","page":"References","title":"OMEinsumContractionOrders.MergeGreedy","text":"MergeGreedy <: CodeSimplifier\nMergeGreedy(; threshhold=-1e-12)\n\nContraction code simplifier (in order to reduce the time of calling optimizers) that merges tensors greedily if the space complexity of merged tensors is reduced (difference smaller than the threshhold).\n\n\n\n\n\n","category":"type"},{"location":"ref/#Others","page":"References","title":"Others","text":"","category":"section"},{"location":"ref/#Graph","page":"References","title":"Graph","text":"","category":"section"},{"location":"ref/","page":"References","title":"References","text":"show_graph\nspring_layout\n\ndiagonal_coupled_graph\nsquare_lattice_graph\nunit_disk_graph\nline_graph\n\nrandom_diagonal_coupled_graph\nrandom_square_lattice_graph","category":"page"},{"location":"ref/#GraphTensorNetworks.show_graph","page":"References","title":"GraphTensorNetworks.show_graph","text":"show_graph(locations, edges;\n    vertex_colors=[\"black\", \"black\", ...],\n    edge_colors=[\"black\", \"black\", ...],\n    texts=[\"1\", \"2\", ...],\n    format=SVG,\n    edge_color=\"black\",\n    kwargs...\n    )\nshow_graph(graph::SimpleGraph; locs=spring_layout(graph), kwargs...)\n\nPlots vertices at locations with vertex colors specified by vertex_colors and texts specified by texts. You will need a VSCode, Pluto notebook or Jupyter notebook to show the image. If you want to write this image to the disk without displaying it in a frontend, please try\n\njulia> open(\"test.png\", \"w\") do f\n            viz_atoms(f, generate_sites(SquareLattice(), 5, 5))\n       end\n\nThe format keyword argument can be Compose.SVG or Compose.PDF.\n\nOther keyword arguments\n\nline, vertex and text\nscale::Float64 = 1.0\npad::Float64 = 1.5\nvertex\nvertex_text_color::String = \"black\"\nvertex_stroke_color = \"black\"\nvertex_fill_color = \"white\"\nedge\nedge_color::String = \"black\"\nimage size in cm\nimage_size::Float64 = 12\n\n\n\n\n\n","category":"function"},{"location":"ref/#GraphTensorNetworks.spring_layout","page":"References","title":"GraphTensorNetworks.spring_layout","text":"Spring layout for graph plotting, returns a vector of vertex locations.\n\nnote: Note\nThis function is copied from GraphPlot.jl, where you can find more information about his function.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GraphTensorNetworks.diagonal_coupled_graph","page":"References","title":"GraphTensorNetworks.diagonal_coupled_graph","text":"diagonal_coupled_graph(mask::AbstractMatrix{Bool})\n\nCreate a masked diagonal coupled square lattice graph from a specified mask.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GraphTensorNetworks.square_lattice_graph","page":"References","title":"GraphTensorNetworks.square_lattice_graph","text":"square_lattice_graph(mask::AbstractMatrix{Bool})\n\nCreate a masked square lattice graph.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GraphTensorNetworks.unit_disk_graph","page":"References","title":"GraphTensorNetworks.unit_disk_graph","text":"unit_disk_graph(locs::AbstractVector, unit::Real)\n\nCreate a unit disk graph with locations specified by locs and unit distance unit.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GraphTensorNetworks.line_graph","page":"References","title":"GraphTensorNetworks.line_graph","text":"line_graph(g::SimpleGraph)\n\nReturns the line graph of g. The line graph is generated by mapping an edge to a vertex and two edges sharing a common vertex will be connected.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GraphTensorNetworks.random_diagonal_coupled_graph","page":"References","title":"GraphTensorNetworks.random_diagonal_coupled_graph","text":"random_diagonal_coupled_graph(m::Int, n::Int, ρ::Real)\n\nCreate a random masked diagonal coupled square lattice graph, with number of vertices fixed to lfloor mnrho rceil.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GraphTensorNetworks.random_square_lattice_graph","page":"References","title":"GraphTensorNetworks.random_square_lattice_graph","text":"random_square_lattice_graph(m::Int, n::Int, ρ::Real)\n\nCreate a random masked square lattice graph, with number of vertices fixed to lfloor mnrho rceil.\n\n\n\n\n\n","category":"function"},{"location":"ref/","page":"References","title":"References","text":"One can also use random_regular_graph and smallgraph in Graphs to build special graphs.","category":"page"},{"location":"ref/#Shortcuts","page":"References","title":"Shortcuts","text":"","category":"section"},{"location":"ref/","page":"References","title":"References","text":"max_size\nmax_size_count","category":"page"},{"location":"ref/#GraphTensorNetworks.max_size","page":"References","title":"GraphTensorNetworks.max_size","text":"max_size(problem; usecuda=false)\n\nReturns the maximum size of the graph problem.  A shorthand of solve(problem, SizeMax(); usecuda=false).\n\n\n\n\n\n","category":"function"},{"location":"ref/#GraphTensorNetworks.max_size_count","page":"References","title":"GraphTensorNetworks.max_size_count","text":"max_size_count(problem; usecuda=false)\n\nReturns the maximum size and the counting of the graph problem. It is a shorthand of solve(problem, CountingMax(); usecuda=false).\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = GraphTensorNetworks","category":"page"},{"location":"#GraphTensorNetworks","page":"Home","title":"GraphTensorNetworks","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package uses generic tensor network to compute properties of combinatorial problems defined on graph. The properties includes the size of the maximum set size, the number of sets of a given size and the enumeration of configurations of a given set size.","category":"page"},{"location":"#Background-knowledge","page":"Home","title":"Background knowledge","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Please check our paper \"Computing properties of independent sets by generic programming tensor networks\". If you find our paper or software useful in your work, we would be grateful if you could cite our work. The CITATION.bib file in the root of this repository lists the relevant papers.","category":"page"},{"location":"#Quick-start","page":"Home","title":"Quick start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"You can find a good installation guide and a quick start in our README.","category":"page"},{"location":"","page":"Home","title":"Home","text":"A good example to start with is the Independent set problem.","category":"page"},{"location":"tutorials/Satisfiability/","page":"Satisfiability problem","title":"Satisfiability problem","text":"EditURL = \"https://github.com/Happy-Diode/GraphTensorNetworks.jl/blob/master/examples/Satisfiability.jl\"","category":"page"},{"location":"tutorials/Satisfiability/#Satisfiability-problem","page":"Satisfiability problem","title":"Satisfiability problem","text":"","category":"section"},{"location":"tutorials/Satisfiability/","page":"Satisfiability problem","title":"Satisfiability problem","text":"note: Note\nIt is recommended to read the Independent set problem tutorial first to know more abouthow to optimize the tensor network contraction order,\nwhat graph properties are available and how to select correct method to compute graph properties,\nhow to compute weighted graphs and handle open vertices.","category":"page"},{"location":"tutorials/Satisfiability/#Problem-definition","page":"Satisfiability problem","title":"Problem definition","text":"","category":"section"},{"location":"tutorials/Satisfiability/","page":"Satisfiability problem","title":"Satisfiability problem","text":"One can specify a satisfiable problem in the conjuctive normal form. In boolean logic, a formula is in conjunctive normal form (CNF) if it is a conjunction (∧) of one or more clauses, where a clause is a disjunction (∨) of literals.","category":"page"},{"location":"tutorials/Satisfiability/","page":"Satisfiability problem","title":"Satisfiability problem","text":"using GraphTensorNetworks\n\n@bools a b c d e f g\n\ncnf = ∧(∨(a, b, ¬d, ¬e), ∨(¬a, d, e, ¬f), ∨(f, g), ∨(¬b, c))","category":"page"},{"location":"tutorials/Satisfiability/","page":"Satisfiability problem","title":"Satisfiability problem","text":"To goal is to find an assignment to satisfy the above CNF. For a satisfiability problem at this size, we can find the following assignment to satisfy this assignment manually.","category":"page"},{"location":"tutorials/Satisfiability/","page":"Satisfiability problem","title":"Satisfiability problem","text":"assignment = Dict([:a=>true, :b=>false, :c=>false, :d=>true, :e=>false, :f=>false, :g=>true])\n\nsatisfiable(cnf, assignment)","category":"page"},{"location":"tutorials/Satisfiability/#Tensor-network-representation","page":"Satisfiability problem","title":"Tensor network representation","text":"","category":"section"},{"location":"tutorials/Satisfiability/","page":"Satisfiability problem","title":"Satisfiability problem","text":"We can contruct a Satisfiability problem to solve the above problem. To generate a tensor network, we map a boolean variable x and its negation neg x to a degree of freedom (label) s_x in 0 1, where 0 stands for variable x having value false while 1 stands for having value true. Then we map a clause to a tensor. For example, a clause x  y  z can be mapped to a tensor labeled by (s_x s_y s_z).","category":"page"},{"location":"tutorials/Satisfiability/","page":"Satisfiability problem","title":"Satisfiability problem","text":"C = left(beginmatrix\nleft(beginmatrix\nx  x \nx  x\nendmatrixright) \nleft(beginmatrix\nx  x \n1  x\nendmatrixright)\nendmatrixright)","category":"page"},{"location":"tutorials/Satisfiability/","page":"Satisfiability problem","title":"Satisfiability problem","text":"There is only one entry (s_x s_y s_z) = (1 0 1) that makes this clause unsatisfied. If we contract this tensor network, we will get a multiplicative factor x whenever there is a clause satisfied.","category":"page"},{"location":"tutorials/Satisfiability/","page":"Satisfiability problem","title":"Satisfiability problem","text":"problem = Satisfiability(cnf);\nnothing #hide","category":"page"},{"location":"tutorials/Satisfiability/#Solving-properties","page":"Satisfiability problem","title":"Solving properties","text":"","category":"section"},{"location":"tutorials/Satisfiability/#Satisfiability-and-its-counting","page":"Satisfiability problem","title":"Satisfiability and its counting","text":"","category":"section"},{"location":"tutorials/Satisfiability/","page":"Satisfiability problem","title":"Satisfiability problem","text":"The size of a satisfiability problem is defined by the number of satisfiable clauses.","category":"page"},{"location":"tutorials/Satisfiability/","page":"Satisfiability problem","title":"Satisfiability problem","text":"num_satisfiable = solve(problem, SizeMax())[]","category":"page"},{"location":"tutorials/Satisfiability/","page":"Satisfiability problem","title":"Satisfiability problem","text":"The GraphPolynomial of a satisfiability problem counts the number of solutions that k clauses satisfied.","category":"page"},{"location":"tutorials/Satisfiability/","page":"Satisfiability problem","title":"Satisfiability problem","text":"num_satisfiable_count = solve(problem, GraphPolynomial())[]","category":"page"},{"location":"tutorials/Satisfiability/#Find-one-of-the-solutions","page":"Satisfiability problem","title":"Find one of the solutions","text":"","category":"section"},{"location":"tutorials/Satisfiability/","page":"Satisfiability problem","title":"Satisfiability problem","text":"single_config = solve(problem, SingleConfigMax())[].c.data","category":"page"},{"location":"tutorials/Satisfiability/","page":"Satisfiability problem","title":"Satisfiability problem","text":"One will see a bit vector printed. One can create an assignment and check the validity with the following statement:","category":"page"},{"location":"tutorials/Satisfiability/","page":"Satisfiability problem","title":"Satisfiability problem","text":"satisfiable(cnf, Dict(zip(labels(problem), single_config)))","category":"page"},{"location":"tutorials/Satisfiability/","page":"Satisfiability problem","title":"Satisfiability problem","text":"","category":"page"},{"location":"tutorials/Satisfiability/","page":"Satisfiability problem","title":"Satisfiability problem","text":"This page was generated using Literate.jl.","category":"page"}]
}
