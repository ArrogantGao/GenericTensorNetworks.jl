var documenterSearchIndex = {"docs":
[{"location":"tutorials/MaxCut/","page":"Max-Cut Problem","title":"Max-Cut Problem","text":"EditURL = \"https://github.com/Happy-Diode/GraphTensorNetworks.jl/blob/master/examples/MaxCut/main.jl\"","category":"page"},{"location":"tutorials/MaxCut/#Max-Cut-problem","page":"Max-Cut Problem","title":"Max-Cut problem","text":"","category":"section"},{"location":"tutorials/MaxCut/#Problem-definition","page":"Max-Cut Problem","title":"Problem definition","text":"","category":"section"},{"location":"tutorials/MaxCut/#Solving-properties","page":"Max-Cut Problem","title":"Solving properties","text":"","category":"section"},{"location":"tutorials/MaxCut/","page":"Max-Cut Problem","title":"Max-Cut Problem","text":"using GraphTensorNetworks, Graphs","category":"page"},{"location":"tutorials/MaxCut/","page":"Max-Cut Problem","title":"Max-Cut Problem","text":"","category":"page"},{"location":"tutorials/MaxCut/","page":"Max-Cut Problem","title":"Max-Cut Problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/IndependentSet/","page":"Independent Set Problem","title":"Independent Set Problem","text":"EditURL = \"https://github.com/Happy-Diode/GraphTensorNetworks.jl/blob/master/examples/IndependentSet/main.jl\"","category":"page"},{"location":"tutorials/IndependentSet/#Independent-set-problem","page":"Independent Set Problem","title":"Independent set problem","text":"","category":"section"},{"location":"tutorials/IndependentSet/#Introduction","page":"Independent Set Problem","title":"Introduction","text":"","category":"section"},{"location":"tutorials/IndependentSet/","page":"Independent Set Problem","title":"Independent Set Problem","text":"using GraphTensorNetworks, Graphs","category":"page"},{"location":"tutorials/IndependentSet/","page":"Independent Set Problem","title":"Independent Set Problem","text":"Please check the docstring of Independence for the definition of independence problem.","category":"page"},{"location":"tutorials/IndependentSet/","page":"Independent Set Problem","title":"Independent Set Problem","text":"@doc Independence","category":"page"},{"location":"tutorials/IndependentSet/","page":"Independent Set Problem","title":"Independent Set Problem","text":"In the following, we are going to defined an independent set problem for the Petersen graph.","category":"page"},{"location":"tutorials/IndependentSet/","page":"Independent Set Problem","title":"Independent Set Problem","text":"graph = Graphs.smallgraph(:petersen)","category":"page"},{"location":"tutorials/IndependentSet/","page":"Independent Set Problem","title":"Independent Set Problem","text":"We can visualize this graph using the following function","category":"page"},{"location":"tutorials/IndependentSet/","page":"Independent Set Problem","title":"Independent Set Problem","text":"rot15(a, b, i::Int) = cos(2i*π/5)*a + sin(2i*π/5)*b, cos(2i*π/5)*b - sin(2i*π/5)*a\n\nlocations = [[rot15(0.0, 1.0, i) for i=0:4]..., [rot15(0.0, 0.6, i) for i=0:4]...]\n\nshow_graph(graph; locs=locations)","category":"page"},{"location":"tutorials/IndependentSet/","page":"Independent Set Problem","title":"Independent Set Problem","text":"Let us contruct the problem instance with optimized tensor network contraction order as bellow.","category":"page"},{"location":"tutorials/IndependentSet/","page":"Independent Set Problem","title":"Independent Set Problem","text":"problem = Independence(graph; optimizer=TreeSA(sc_weight=1.0, ntrials=10,\n                         βs=0.01:0.1:15.0, niters=20, rw_weight=0.2),\n                         simplifier=MergeGreedy());\nnothing #hide","category":"page"},{"location":"tutorials/IndependentSet/#Solving-properties","page":"Independent Set Problem","title":"Solving properties","text":"","category":"section"},{"location":"tutorials/IndependentSet/#Maximum-independent-set-size-\\alpha(G)","page":"Independent Set Problem","title":"Maximum independent set size alpha(G)","text":"","category":"section"},{"location":"tutorials/IndependentSet/","page":"Independent Set Problem","title":"Independent Set Problem","text":"maximum_independent_set_size = solve(problem, SizeMax())","category":"page"},{"location":"tutorials/IndependentSet/#Counting-properties","page":"Independent Set Problem","title":"Counting properties","text":"","category":"section"},{"location":"tutorials/IndependentSet/#counting-all-independent-sets","page":"Independent Set Problem","title":"counting all independent sets","text":"","category":"section"},{"location":"tutorials/IndependentSet/","page":"Independent Set Problem","title":"Independent Set Problem","text":"count_all_independent_sets = solve(problem, CountingAll())","category":"page"},{"location":"tutorials/IndependentSet/#counting-independent-sets-with-sizes-\\alpha(G)-and-\\alpha(G)-1","page":"Independent Set Problem","title":"counting independent sets with sizes alpha(G) and alpha(G)-1","text":"","category":"section"},{"location":"tutorials/IndependentSet/","page":"Independent Set Problem","title":"Independent Set Problem","text":"count_max2_independent_sets = solve(problem, CountingMax(2))","category":"page"},{"location":"tutorials/IndependentSet/#independence-polynomial","page":"Independent Set Problem","title":"independence polynomial","text":"","category":"section"},{"location":"tutorials/IndependentSet/","page":"Independent Set Problem","title":"Independent Set Problem","text":"For the definition of independence polynomial, please check the docstring of Independence or this wiki page. There are 3 methods to compute a graph polynomial, :finitefield, :fft and :polynomial. These methods are introduced in the docstring of GraphPolynomial.","category":"page"},{"location":"tutorials/IndependentSet/","page":"Independent Set Problem","title":"Independent Set Problem","text":"independence_polynomial = solve(problem, GraphPolynomial(; method=:finitefield))","category":"page"},{"location":"tutorials/IndependentSet/#Configuration-properties","page":"Independent Set Problem","title":"Configuration properties","text":"","category":"section"},{"location":"tutorials/IndependentSet/#finding-one-maximum-independent-set-(MIS)","page":"Independent Set Problem","title":"finding one maximum independent set (MIS)","text":"","category":"section"},{"location":"tutorials/IndependentSet/","page":"Independent Set Problem","title":"Independent Set Problem","text":"There are two approaches to find one of the best solution. The unbounded (default) version uses ConfigSampler to sample one of the best solutions directly. The bounded version uses the binary gradient back-propagation (see our paper) to compute the gradients. It requires caching intermediate states, but is often faster on CPU because it can use TropicalGEMM.","category":"page"},{"location":"tutorials/IndependentSet/","page":"Independent Set Problem","title":"Independent Set Problem","text":"max_config = solve(problem, SingleConfigMax(; bounded=false))[]","category":"page"},{"location":"tutorials/IndependentSet/","page":"Independent Set Problem","title":"Independent Set Problem","text":"The return value contains a bit string, and one should read this bit string from left to right. Having value 1 at i-th bit means vertex i is in the maximum independent set. One can visualize this MIS with the following function.","category":"page"},{"location":"tutorials/IndependentSet/","page":"Independent Set Problem","title":"Independent Set Problem","text":"show_graph(graph; locs=locations, colors=[iszero(max_config.c.data[i]) ? \"white\" : \"red\"\n                                 for i=1:nv(graph)])","category":"page"},{"location":"tutorials/IndependentSet/#enumeration-of-all-MISs","page":"Independent Set Problem","title":"enumeration of all MISs","text":"","category":"section"},{"location":"tutorials/IndependentSet/","page":"Independent Set Problem","title":"Independent Set Problem","text":"There are two approaches to enumerate all best-K solutions. The bounded (default) version is always prefered because it can significantly use the memory usage.","category":"page"},{"location":"tutorials/IndependentSet/","page":"Independent Set Problem","title":"Independent Set Problem","text":"all_max_configs = solve(problem, ConfigsMax(1; bounded=true))[]\n\nusing Compose\n\nm = length(all_max_configs.c)\n\nimgs = ntuple(k->(context((k-1)/m, 0.0, 1.2/m, 1.0), show_graph(graph;\n                            locs=locations, scale=0.25,\n                            colors=[iszero(all_max_configs.c[k][i]) ? \"white\" : \"red\"\n                                 for i=1:nv(graph)])), m)\n\nCompose.set_default_graphic_size(18cm, 4cm); Compose.compose(context(), imgs...)","category":"page"},{"location":"tutorials/IndependentSet/#enumeration-of-all-IS-configurations","page":"Independent Set Problem","title":"enumeration of all IS configurations","text":"","category":"section"},{"location":"tutorials/IndependentSet/","page":"Independent Set Problem","title":"Independent Set Problem","text":"all_independent_sets = solve(problem, ConfigsAll())[]","category":"page"},{"location":"tutorials/IndependentSet/","page":"Independent Set Problem","title":"Independent Set Problem","text":"","category":"page"},{"location":"tutorials/IndependentSet/","page":"Independent Set Problem","title":"Independent Set Problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/Others/","page":"Other Problems","title":"Other Problems","text":"EditURL = \"https://github.com/Happy-Diode/GraphTensorNetworks.jl/blob/master/examples/Others/main.jl\"","category":"page"},{"location":"tutorials/Others/#Other-problems-can-be-solved-by-GraphTensorNetworks","page":"Other Problems","title":"Other problems can be solved by GraphTensorNetworks","text":"","category":"section"},{"location":"tutorials/Others/#Set-packing-problem","page":"Other Problems","title":"Set packing problem","text":"","category":"section"},{"location":"tutorials/Others/","page":"Other Problems","title":"Other Problems","text":"It is a generalization of the independent set problem.","category":"page"},{"location":"tutorials/Others/#Vertex-cover-problem","page":"Other Problems","title":"Vertex cover problem","text":"","category":"section"},{"location":"tutorials/Others/","page":"Other Problems","title":"Other Problems","text":"A vertex cover is a complement of an independent set.","category":"page"},{"location":"tutorials/Others/#Maximal-clique-problem","page":"Other Problems","title":"Maximal clique problem","text":"","category":"section"},{"location":"tutorials/Others/","page":"Other Problems","title":"Other Problems","text":"The maximal clique of graph G is a maximal clique of G's complement graph.","category":"page"},{"location":"tutorials/Others/#Spin-glass-problem","page":"Other Problems","title":"Spin-glass problem","text":"","category":"section"},{"location":"tutorials/Others/","page":"Other Problems","title":"Other Problems","text":"It is another way of saying the Max-Cut problem.","category":"page"},{"location":"tutorials/Others/","page":"Other Problems","title":"Other Problems","text":"","category":"page"},{"location":"tutorials/Others/","page":"Other Problems","title":"Other Problems","text":"This page was generated using Literate.jl.","category":"page"},{"location":"ref/#References","page":"References","title":"References","text":"","category":"section"},{"location":"ref/#Graph-problems","page":"References","title":"Graph problems","text":"","category":"section"},{"location":"ref/","page":"References","title":"References","text":"solve\nGraphProblem\nIndependence\nMaximalIndependence\nMatching\nColoring\nMaxCut\nPaintShop","category":"page"},{"location":"ref/#GraphTensorNetworks.solve","page":"References","title":"GraphTensorNetworks.solve","text":"solve(problem, property; usecuda=false, T=Float64)\n\nSolving a certain property of a graph problem.\n\nPositional Arguments\n\nproblem is the graph problem with tensor network information,\nproperty is string specifying the task. Using the maximum independent set problem as an example, it can be one of\nSizeMax for finding maximum configuration size,\nCountingMax for counting configurations with top K sizes,\nCountingAll for counting all configurations,\nGraphPolynomial for evaluating the graph polynomial,\nSingleConfigMax for finding one maximum configuration,\nConfigsMax for enumerating configurations with top K sizes,\nConfigsAll for enumerating all configurations,\n\nKeyword arguments\n\nusecuda is a switch to use CUDA (if possible), user need to call statement using CUDA before turning on this switch.\nT is the \"base\" element type, sometimes can be used to reduce the memory cost.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GraphTensorNetworks.GraphProblem","page":"References","title":"GraphTensorNetworks.GraphProblem","text":"GraphProblem\n\nThe abstract base type of graph problems.\n\n\n\n\n\n","category":"type"},{"location":"ref/#GraphTensorNetworks.Independence","page":"References","title":"GraphTensorNetworks.Independence","text":"Independence{CT<:AbstractEinsum,WT<:Union{UnWeighted, Vector}} <: GraphProblem\nIndependence(graph; weights=UnWeighted(), openvertices=(),\n             optimizer=GreedyMethod(), simplifier=nothing)\n\nThe Independent set problem. In the constructor, weights are the weights of vertices. openvertices specifies labels for the output tensor. optimizer and simplifier are for tensor network optimization, check optimize_code for details.\n\nProblem definition\n\nAn independent set is defined in the monadic second order logic as\n\nexists x_ildotsx_Mleftbigwedge_ineq j (x_ineq x_j wedge neg textbfadj(x_i x_j))right\n\nGraph polynomial\n\nThe graph polynomial defined for the independence problem is known as the independence polynomial.\n\nI(G x) = sum_k=0^alpha(G) a_k x^k\n\nwhere alpha(G) is the maximum independent set size,  a_k is the number of independent sets of size k in graph G=(VE). The total number of independent sets is thus equal to I(G 1).\n\nTensor network\n\nIn tensor network representation of the independent set problem, we map a vertex iin V to a label s_i in 0 1 of dimension 2, where we use 0 (1) to denote a vertex is absent (present) in the set. For each label s_i, we defined a parametrized rank-one vertex tensor W(x_i) as\n\nW(x_i)_s_i = left(beginmatrix\n    1 \n    x_i\nendmatrixright)_s_i\n\nWe use subscripts to index tensor elements, e.g.W(x_i)_0=1 is the first element associated with s_i=0 and W(x_i)_1=x_i is the second element associated with s_i=1. Similarly, on each edge (u v), we define a matrix B indexed by s_u and s_v as\n\nB_s_i s_j = left(beginmatrix\n    1   1\n    1  0\nendmatrixright)_s_is_j\n\nIts contraction time space complexity is 2^rm tw(G), where rm tw(G) is the tree-width of G.\n\n\n\n\n\n","category":"type"},{"location":"ref/#GraphTensorNetworks.MaximalIndependence","page":"References","title":"GraphTensorNetworks.MaximalIndependence","text":"MaximalIndependence{CT<:AbstractEinsum,WT<:Union{UnWeighted, Vector}} <: GraphProblem\nMaximalIndependence(graph; weights=UnWeighted(), openvertices=(),\n             optimizer=GreedyMethod(), simplifier=nothing)\n\nMaximal independent set problem. In the constructor, weights are the weights of vertices. optimizer and simplifier are for tensor network optimization, check optimize_code for details.\n\nProblem definition\n\nIn graph theory, a maximal independent set is an independent set that is not a subset of any other independent set. It is different from maximum independent set because it does not require the set to have the max size.\n\nGraph polynomial\n\nThe graph polynomial defined for the maximal independent set problem is\n\nI_rm max(G x) = sum_k=0^alpha(G) b_k x^k\n\nwhere b_k is the number of maximal independent sets of size k in graph G=(V E).\n\nTensor network\n\nFor a vertex vin V, we define a boolean degree of freedom s_vin0 1. We defined the restriction on its neighbourhood Nv:\n\nT(x_v)_s_1s_2ldotss_N(v)s_v = begincases\n    s_vx_v  s_1=s_2=ldots=s_N(v)=0\n    1-s_v textotherwise\nendcases\n\nIntuitively, it means if all the neighbourhood vertices are not in I_m, i.e., s_1=s_2=ldots=s_N(v)=0, then v should be in I_m and contribute a factor x_v, otherwise, if any of the neighbourhood vertices is in I_m, then v cannot be in I_m.\n\nIts contraction time space complexity is no longer determined by the tree-width of the original graph G. It is often harder to contract this tensor network than to contract the one for regular independent set problem.\n\n\n\n\n\n","category":"type"},{"location":"ref/#GraphTensorNetworks.Matching","page":"References","title":"GraphTensorNetworks.Matching","text":"Matching{CT<:AbstractEinsum} <: GraphProblem\nMatching(graph; openvertices=(), optimizer=GreedyMethod(), simplifier=nothing)\n\nVertex matching problem. optimizer and simplifier are for tensor network optimization, check optimize_code for details.\n\nProblem definition\n\nA k-matching in a graph G is a set of k edges, no two of which have a vertex in common.\n\nGraph polynomial\n\nThe matching polynomial adopts the first definition in wiki page\n\nM(G x) = sumlimits_k=1^V2 c_k x^k\n\nwhere k is the number of matches, and coefficients c_k are the corresponding counting.\n\nTensor network\n\nWe map an edge (u v) in E to a label langle u vrangle in 0 1 in a tensor network, where 1 means two vertices of an edge are matched, 0 means otherwise. Then we define a tensor of rank d(v) = N(v) on vertex v such that,\n\nW_langle v n_1rangle langle v n_2 rangle ldots langle v n_d(v)rangle = begincases\n    1  sum_i=1^d(v) langle v n_i rangle leq 1\n    0  textotherwise\nendcases\n\nand a tensor of rank 1 on the bond\n\nB_langle v wrangle = begincases\n1  langle v w rangle = 0 \nx  langle v w rangle = 1\nendcases\n\nwhere label langle v w rangle is equivalent to langle wvrangle.\n\n\n\n\n\n","category":"type"},{"location":"ref/#GraphTensorNetworks.Coloring","page":"References","title":"GraphTensorNetworks.Coloring","text":"Coloring{K,CT<:AbstractEinsum} <: GraphProblem\nColoring{K}(graph; openvertices=(), optimizer=GreedyMethod(), simplifier=nothing)\n\nVertex Coloring problem. optimizer and simplifier are for tensor network optimization, check optimize_code for details.\n\nProblem definition\n\nA vertex coloring is an assignment of labels or colors to each vertex of a graph such that no edge connects two identically colored vertices. \n\nTensor network\n\nLet us use 3-colouring problem defined on vertices as an example. For a vertex v, we define the degree of freedoms c_vin123 and a vertex tensor labelled by it as\n\nW(v) = left(beginmatrix\n    r_v\n    g_v\n    b_v\nendmatrixright)\n\nFor an edge (u v), we define an edge tensor as a matrix labelled by (c_u c_v) to specify the constraint\n\nB = left(beginmatrix\n    0  1  1\n    1  0  1\n    1  1  0\nendmatrixright)\n\nThe number of possible colouring can be obtained by contracting this tensor network by setting vertex tensor elements r_v g_v and b_v to 1.\n\n\n\n\n\n","category":"type"},{"location":"ref/#GraphTensorNetworks.MaxCut","page":"References","title":"GraphTensorNetworks.MaxCut","text":"MaxCut{CT<:AbstractEinsum,WT<:Union{UnWeighted, Vector}} <: GraphProblem\nMaxCut(graph; weights=UnWeighted(), openvertices=(),\n            optimizer=GreedyMethod(), simplifier=nothing)\n\nCut problem (or spin glass problem). In the constructor, weights are the weights of edges. optimizer and simplifier are for tensor network optimization, check optimize_code for details.\n\nProblem definition\n\nIn graph theory, a cut is a partition of the vertices of a graph into two disjoint subsets. A maximum cut is a cut whose size is at least the size of any other cut, where the size of a cut is the number of edges (or the sum of weights on edges) crossing the cut.\n\nGraph polynomial\n\nThe graph polynomial defined for the cut problem is\n\nC(G x) = sum_k=0^gamma(G) c_k x^k\n\nwhere alpha(G) is the maximum independent set size,  c_k2 is the number of cuts of size k in graph G=(VE).\n\nTensor network\n\nFor a vertex vin V, we define a boolean degree of freedom s_vin0 1. Then the maximum cut problem can be encoded to tensor networks by mapping an edge (ij)in E to an edge matrix labelled by s_is_j\n\nB(x_langle i jrangle) = left(beginmatrix\n    1  x_langle i jrangle\n    x_langle i jrangle  1\nendmatrixright)\n\nwhere variable x_langle i jrangle represents a cut on edge (i j) or a domain wall of an Ising spin glass. Similar to other problems, we can define a polynomial about edges variables by setting x_langle i jrangle = x, where its k-th coefficient is two times the number of configurations of cut size k.\n\nIts contraction time space complexity is 2^rm tw(G), where rm tw(G) is the tree-width of G.\n\n\n\n\n\n","category":"type"},{"location":"ref/#GraphTensorNetworks.PaintShop","page":"References","title":"GraphTensorNetworks.PaintShop","text":"PaintShop{CT<:AbstractEinsum} <: GraphProblem\nPaintShop(labels::AbstractVector; openvertices=(),\n         optimizer=GreedyMethod(), simplifier=nothing)\n\nThe binary paint shop problem.\n\nExample\n\nOne can encode the paint shop problem abaccb as the following\n\njulia> symbols = collect(\"abaccb\");\n\njulia> pb = PaintShop(symbols);\n\njulia> solve(pb, SizeMax())[]\n3.0ₜ\n\njulia> solve(pb, ConfigsMax())[].c.data\n2-element Vector{StaticBitVector{5, 1}}:\n 01101\n 01101\n\nIn our definition, we find the maximum number of unchanged color in this sequence, i.e. (n-1) - (minimum number of color changes) In the output of maximum configurations, the two configurations are defined on 5 bonds i.e. pairs of (i, i+1), 0 means color changed, while 1 means color not changed. If we denote two \"colors\" as r and b, then the optimal painting is rbbbrr or brrrbb, both change the colors twice.\n\n\n\n\n\n","category":"type"},{"location":"ref/","page":"References","title":"References","text":"set_packing","category":"page"},{"location":"ref/#GraphTensorNetworks.set_packing","page":"References","title":"GraphTensorNetworks.set_packing","text":"set_packing(sets; openvertices=(), optimizer=GreedyMethod(), simplifier=nothing)\n\nSet packing is a generalization of independent set problem to hypergraphs. Calling this function will return you an Independence instance. sets are a vector of vectors, each element being a vertex in the independent set problem. optimizer and simplifier are for tensor network optimization, check optimize_code for details.\n\nExample\n\njulia> sets = [[1, 2, 5], [1, 3], [2, 4], [3, 6], [2, 3, 6]];  # each set is a vertex\n\njulia> gp = set_packing(sets);\n\njulia> res = best_solutions(gp; all=true)[]\n(2, {10010, 00110, 01100})ₜ\n\n\n\n\n\n","category":"function"},{"location":"ref/#Graph-Problem-Interfaces","page":"References","title":"Graph Problem Interfaces","text":"","category":"section"},{"location":"ref/","page":"References","title":"References","text":"generate_tensors\nsymbols\nflavors\nget_weights\nnflavor","category":"page"},{"location":"ref/#GraphTensorNetworks.symbols","page":"References","title":"GraphTensorNetworks.symbols","text":"symbols(problem::GraphProblem)\n\nThe symbols of a graph problem, they are the degrees of freedoms in the graph.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GraphTensorNetworks.flavors","page":"References","title":"GraphTensorNetworks.flavors","text":"flavors(::Type{<:GraphProblem})\n\nIt returns a vector of integers as the flavors of a degree of freedom. Its size is the same as the degree of freedom on a single vertex/edge.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GraphTensorNetworks.get_weights","page":"References","title":"GraphTensorNetworks.get_weights","text":"get_weights(problem::GraphProblem, sym)\n\nThe weights for the degree of freedom specified by sym of the graph problem, where sym is a symbol. In graph polynomial, integer weights are the orders of x.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GraphTensorNetworks.nflavor","page":"References","title":"GraphTensorNetworks.nflavor","text":"nflavor(::Type{<:GraphProblem})\n\nBond size is equal to the number of flavors.\n\n\n\n\n\n","category":"function"},{"location":"ref/","page":"References","title":"References","text":"To subtype GraphProblem, the new type must contain a code field to represent the (optimized) tensor network. Interfaces generate_tensors, symbols, flavors and [get_weights] are required. [nflavor] is optimal.","category":"page"},{"location":"ref/#Properties","page":"References","title":"Properties","text":"","category":"section"},{"location":"ref/","page":"References","title":"References","text":"SizeMax\nCountingAll\nCountingMax\nGraphPolynomial\nSingleConfigMax\nConfigsAll\nConfigsMax","category":"page"},{"location":"ref/#GraphTensorNetworks.SizeMax","page":"References","title":"GraphTensorNetworks.SizeMax","text":"SizeMax <: AbstractProperty\nSizeMax()\n\nThe maximum independent set size.\n\nThe corresponding tensor element type is Tropical.\nIt is compatible with weighted graph problems.\nBLAS (on CPU) and GPU are supported,\n\n\n\n\n\n","category":"type"},{"location":"ref/#GraphTensorNetworks.CountingAll","page":"References","title":"GraphTensorNetworks.CountingAll","text":"CountingAll <: AbstractProperty\nCountingAll()\n\nCounting the total number of sets. e.g. for Independence problem, it counts the independent sets.\n\nThe corresponding tensor element type is Base.Real.\nThe weights on graph does not have effect.\nBLAS (GPU and CPU) and GPU are supported,\n\n\n\n\n\n","category":"type"},{"location":"ref/#GraphTensorNetworks.CountingMax","page":"References","title":"GraphTensorNetworks.CountingMax","text":"CountingMax{K} <: AbstractProperty\nCountingMax(K=1)\n\nCounting the number of sets with K largest size. e.g. for Independence problem, it counts independent sets of size alpha(G) alpha(G)-1 ldots alpha(G)-K+1.\n\nThe corresponding tensor element type is CountingTropical for K == 1, and TruncatedPoly{K} for K > 1.\nWeighted graph problems is only supported for K == 1.\nGPU is supported,\n\n\n\n\n\n","category":"type"},{"location":"ref/#GraphTensorNetworks.GraphPolynomial","page":"References","title":"GraphTensorNetworks.GraphPolynomial","text":"GraphPolynomial{METHOD} <: AbstractProperty\nGraphPolynomial(; method=:finitefield, kwargs...)\n\nCompute the graph polynomial, e.g. for Independence problem, it is the independence polynomial. The METHOD type parameter can be one of the following symbols\n\n:finitefield, it uses finite field algebra to fit the polynomial.\nThe corresponding tensor element type is Mods.Mod,\nIt does not have round-off error,\nGPU is supported,\nIt accepts keyword arguments maxorder (optional, e.g. the MIS size in the Independence problem).\n:polynomial, the program uses polynomial numbers to solve the polynomial directly.\nThe corresponding tensor element type is Polynomials.Polynomial.\nIt might have small round-off error depending on the data type for storing the counting.\nIt has memory overhead that linear to the graph size.\n:fft, \nThe corresponding tensor element type is Base.Complex.\nIt has (controllable) round-off error.\nBLAS and GPU are supported.\nIt accepts keyword arguments maxorder (optional) and r,   if r > 1, one has better precision for coefficients of large order, if r < 1,   one has better precision for coefficients of small order.\n\nGraph polynomials are not defined for weighted graph problems.\n\n\n\n\n\n","category":"type"},{"location":"ref/#GraphTensorNetworks.SingleConfigMax","page":"References","title":"GraphTensorNetworks.SingleConfigMax","text":"SingleConfigMax{BOUNDED} <: AbstractProperty\nSingleConfigMax(; bounded=false)\n\nFinding single best solution, e.g. for Independence problem, it is one of the maximum independent sets.\n\nThe corresponding data type is CountingTropical{Float64,<:ConfigSampler} if BOUNDED is true, Tropical otherwise.\nWeighted graph problems is supported.\nGPU is supported,\n\n\n\n\n\n","category":"type"},{"location":"ref/#GraphTensorNetworks.ConfigsAll","page":"References","title":"GraphTensorNetworks.ConfigsAll","text":"ConfigsAll <:AbstractProperty\nConfigsAll()\n\nFind all valid configurations, e.g. for Independence problem, it is finding all independent sets.\n\nThe corresponding data type is ConfigEnumerator.\nWeights do not take effect.\n\n\n\n\n\n","category":"type"},{"location":"ref/#GraphTensorNetworks.ConfigsMax","page":"References","title":"GraphTensorNetworks.ConfigsMax","text":"ConfigsMax{K, BOUNDED} <:AbstractProperty\nConfigsMax(K=1; bounded=true)\n\nFind configurations with largest sizes, e.g. for Independence problem, it is finding all independent sets of sizes alpha(G) alpha(G)-1 ldots alpha(G)-K+1.\n\nThe corresponding data type is CountingTropical{Float64,<:ConfigEnumerator} for K == 1 and TruncatedPoly{K,<:ConfigEnumerator} for K > 1.\nWeighted graph problems is only supported for K == 1.\n\n\n\n\n\n","category":"type"},{"location":"ref/#Element-Algebras","page":"References","title":"Element Algebras","text":"","category":"section"},{"location":"ref/","page":"References","title":"References","text":"TropicalNumbers.Tropical\nTropicalNumbers.CountingTropical\nMods.Mod\nPolynomials.Polynomial\nTruncatedPoly\nMax2Poly\nConfigEnumerator\nConfigSampler","category":"page"},{"location":"ref/#TropicalNumbers.Tropical","page":"References","title":"TropicalNumbers.Tropical","text":"Tropical{T} <: Number\n\nTropical number is a semiring algebra that maps\n\n+ in regular algebra to max,\n* in regular algebra to +,\n1 in regular algebra to 0,\n0 in regular algebra to -Inf (for integer content types, this is chosen as a mall integer).\n\nWe implemented fast tropical matrix multiplication in TropicalGEMM.\n\n\n\n\n\n","category":"type"},{"location":"ref/#TropicalNumbers.CountingTropical","page":"References","title":"TropicalNumbers.CountingTropical","text":"CountingTropical{T,CT} <: Number\n\nCounting tropical number type is also a semiring algebra. It is tropical algebra with one extra field for counting, it is introduced in arXiv:2008.06888.\n\n\n\n\n\n","category":"type"},{"location":"ref/#Mods.Mod","page":"References","title":"Mods.Mod","text":"Mod{m}(v) creates a modular number in mod m with value mod(v,m).\n\n\n\n\n\n","category":"type"},{"location":"ref/#Polynomials.Polynomial","page":"References","title":"Polynomials.Polynomial","text":"Polynomial{T, X}(coeffs::AbstractVector{T}, [var = :x])\n\nConstruct a polynomial from its coefficients coeffs, lowest order first, optionally in terms of the given variable var which may be a character, symbol, or a string.\n\nIf p = a_n x^n + ldots + a_2 x^2 + a_1 x + a_0, we construct this through Polynomial([a_0, a_1, ..., a_n]).\n\nThe usual arithmetic operators are overloaded to work with polynomials as well as with combinations of polynomials and scalars. However, operations involving two polynomials of different variables causes an error except those involving a constant polynomial.\n\nnote: Note\nPolynomial is not axis-aware, and it treats coeffs simply as a list of coefficients with the first index always corresponding to the constant term. In order to use the axis of coeffs as exponents, consider using a LaurentPolynomial or possibly a SparsePolynomial.\n\nExamples\n\njulia> using Polynomials\n\njulia> Polynomial([1, 0, 3, 4])\nPolynomial(1 + 3*x^2 + 4*x^3)\n\njulia> Polynomial([1, 2, 3], :s)\nPolynomial(1 + 2*s + 3*s^2)\n\njulia> one(Polynomial)\nPolynomial(1.0)\n\n\n\n\n\n","category":"type"},{"location":"ref/#GraphTensorNetworks.TruncatedPoly","page":"References","title":"GraphTensorNetworks.TruncatedPoly","text":"TruncatedPoly{K,T,TO} <: Number\n\nPolynomial truncated to largest K orders. T is the coefficients type and TO is the orders type.\n\njulia> TruncatedPoly((1,2,3), 6)\nx^4 + 2*x^5 + 3*x^6\n\n\n\n\n\n","category":"type"},{"location":"ref/#GraphTensorNetworks.Max2Poly","page":"References","title":"GraphTensorNetworks.Max2Poly","text":"Max2Poly{T,TO} = TruncatedPoly{2,T,TO}\n\n\n\n\n\n","category":"type"},{"location":"ref/#GraphTensorNetworks.ConfigEnumerator","page":"References","title":"GraphTensorNetworks.ConfigEnumerator","text":"ConfigEnumerator{N,S,C}\n\nSet algebra for enumerating configurations, where N is the length of configurations, C is the size of storage in unit of UInt64, S is the bit width to store a single element in a configuration, i.e. log2(# of flavors), for bitstrings, it is 1`.\n\njulia> a = ConfigEnumerator([StaticBitVector([1,1,1,0,0]), StaticBitVector([1,0,0,0,1])])\n{11100, 10001}\n\njulia> b = ConfigEnumerator([StaticBitVector([0,0,0,0,0]), StaticBitVector([1,0,1,0,1])])\n{00000, 10101}\n\njulia> a + b\n{11100, 10001, 00000, 10101}\n\n\n\n\n\n","category":"type"},{"location":"ref/#GraphTensorNetworks.ConfigSampler","page":"References","title":"GraphTensorNetworks.ConfigSampler","text":"ConfigSampler{N,S,C}\n\nThe algebra for sampling one configuration, where N is the length of configurations, C is the size of storage in unit of UInt64, S is the bit width to store a single element in a configuration, i.e. log2(# of flavors), for bitstrings, it is 1`.\n\njulia> ConfigSampler(StaticBitVector([1,1,1,0,0]))\nConfigSampler{5, 1, 1}(11100)\n\n\n\n\n\n","category":"type"},{"location":"ref/","page":"References","title":"References","text":"StaticBitVector\nStaticElementVector\nsave_configs\nload_configs\n@bv_str\nonehotv\nis_commutative_semiring","category":"page"},{"location":"ref/#GraphTensorNetworks.StaticBitVector","page":"References","title":"GraphTensorNetworks.StaticBitVector","text":"StaticBitVector{N,C} = StaticElementVector{N,1,C}\n\n\n\n\n\n","category":"type"},{"location":"ref/#GraphTensorNetworks.StaticElementVector","page":"References","title":"GraphTensorNetworks.StaticElementVector","text":"StaticElementVector{N,S,C}\n\nN is the length of vector, C is the size of storage in unit of UInt64, S is the stride defined as the log2(# of flavors). When the number of flavors is 2, it is a StaticBitVector.\n\n\n\n\n\n","category":"type"},{"location":"ref/#GraphTensorNetworks.save_configs","page":"References","title":"GraphTensorNetworks.save_configs","text":"save_configs(filename, data::ConfigEnumerator; format=:binary)\n\nSave configurations data to file filename. The format is :binary or :text.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GraphTensorNetworks.load_configs","page":"References","title":"GraphTensorNetworks.load_configs","text":"load_configs(filename; format=:binary, bitlength=nothing, nflavors=2)\n\nLoad configurations from file filename. The format is :binary or :text. If the format is :binary, the bitstring length bitlength must be specified, nflavors specifies the degree of freedom.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GraphTensorNetworks.@bv_str","page":"References","title":"GraphTensorNetworks.@bv_str","text":"Constructing a static bit vector.\n\n\n\n\n\n","category":"macro"},{"location":"ref/#GraphTensorNetworks.onehotv","page":"References","title":"GraphTensorNetworks.onehotv","text":"onehotv(::Type{<:StaticElementVector}, i, v)\nonehotv(::Type{<:StaticBitVector, i)\n\nReturns a static element vector, with the value at location i being v (1 if not specified).\n\n\n\n\n\n","category":"function"},{"location":"ref/#GraphTensorNetworks.is_commutative_semiring","page":"References","title":"GraphTensorNetworks.is_commutative_semiring","text":"is_commutative_semiring(a::T, b::T, c::T) where T\n\nCheck if elements a, b and c satisfied the commutative semiring requirements.\n\nbeginalign*\n(a oplus b) oplus c = a oplus (b oplus c)  hspace5emtrianglerighttextcommutative monoid oplus with identity mathbb0\na oplus mathbb0 = mathbb0 oplus a = a \na oplus b = b oplus a \n\n(a odot b) odot c = a odot (b odot c)     hspace5emtriangleright textcommutative monoid odot with identity mathbb1\na odot  mathbb1 =  mathbb1 odot a = a \na odot b = b odot a \n\na odot (boplus c) = aodot b oplus aodot c    hspace5emtriangleright textleft and right distributive\n(aoplus b) odot c = aodot c oplus bodot c \n\na odot mathbb0 = mathbb0 odot a = mathbb0\nendalign*\n\n\n\n\n\n","category":"function"},{"location":"ref/#Tensor-Network","page":"References","title":"Tensor Network","text":"","category":"section"},{"location":"ref/","page":"References","title":"References","text":"optimize_code\ngetixsv\ngetiyv\ntimespace_complexity\ntimespacereadwrite_complexity\n@ein_str\nGreedyMethod\nTreeSA\nSABipartite\nKaHyParBipartite\nMergeVectors\nMergeGreedy","category":"page"},{"location":"ref/#OMEinsumContractionOrders.optimize_code","page":"References","title":"OMEinsumContractionOrders.optimize_code","text":"optimize_code(eincode, size_dict, optimizer = GreedyMethod(), simplifier=nothing)\n\nOptimize the einsum contraction code and reduce the time/space complexity of tensor network contraction. Returns a NestedEinsum instance. Input arguments are\n\neincode is an einsum contraction code instance, one of DynamicEinCode, StaticEinCode or NestedEinsum.\nsize is a dictionary of \"edge label=>edge size\" that contains the size information, one can use uniformsize(eincode, 2) to create a uniform size.\noptimizer is a CodeOptimizer instance, should be one of GreedyMethod, KaHyParBipartite, SABipartite or TreeSA. Check their docstrings for details.\nsimplifier is one of MergeVectors or MergeGreedy.\n\n\n\n\n\n","category":"function"},{"location":"ref/#OMEinsum.getixsv","page":"References","title":"OMEinsum.getixsv","text":"getixsv(code)\n\nGet labels of input tensors for EinCode, NestedEinsum and some other einsum like objects. Returns a vector of vector.\n\njulia> getixsv(ein\"(ij,jk),k->i\")\n3-element Vector{Vector{Char}}:\n ['i', 'j']\n ['j', 'k']\n ['k']\n\n\n\n\n\n","category":"function"},{"location":"ref/#OMEinsum.getiyv","page":"References","title":"OMEinsum.getiyv","text":"getiy(code)\n\nGet labels of the output tensor for EinCode, NestedEinsum and some other einsum like objects. Returns a vector.\n\njulia> getiyv(ein\"(ij,jk),k->i\")\n1-element Vector{Char}:\n 'i': ASCII/Unicode U+0069 (category Ll: Letter, lowercase)\n\n\n\n\n\n","category":"function"},{"location":"ref/#OMEinsum.timespace_complexity","page":"References","title":"OMEinsum.timespace_complexity","text":"timespace_complexity(eincode, size_dict)\n\nReturns the time and space complexity of the einsum contraction. The time complexity is defined as log2(number of element multiplication). The space complexity is defined as log2(size of the maximum intermediate tensor).\n\n\n\n\n\n","category":"function"},{"location":"ref/#OMEinsum.timespacereadwrite_complexity","page":"References","title":"OMEinsum.timespacereadwrite_complexity","text":"timespacereadwrite_complexity(eincode, size_dict)\n\nReturns the time, space and read-write complexity of the einsum contraction. The time complexity is defined as log2(number of element-wise multiplication). The space complexity is defined as log2(size of the maximum intermediate tensor). The read-write complexity is defined as log2(the number of read-write operations).\n\n\n\n\n\n","category":"function"},{"location":"ref/#OMEinsum.@ein_str","page":"References","title":"OMEinsum.@ein_str","text":"ein\"ij,jk -> ik\"(A,B)\n\nString macro interface which understands numpy.einsum's notation. Translates strings into StaticEinCode-structs that can be called to evaluate an einsum. To control evaluation order, use parentheses - instead of an EinCode, a NestedEinsum is returned which evaluates the expression according to parens. The valid character ranges for index-labels are a-z and α-ω.\n\nexample\n\njulia> a, b, c = rand(10,10), rand(10,10), rand(10,1);\n\njulia> ein\"ij,jk,kl -> il\"(a,b,c) ≈ ein\"(ij,jk),kl -> il\"(a,b,c) ≈ a * b * c\ntrue\n\n\n\n\n\n","category":"macro"},{"location":"ref/#OMEinsumContractionOrders.GreedyMethod","page":"References","title":"OMEinsumContractionOrders.GreedyMethod","text":"GreedyMethod{MT}\nGreedyMethod(; method=MinSpaceOut(), nrepeat=10)\n\nThe fast but poor greedy optimizer. Input arguments are\n\nmethod is MinSpaceDiff() or MinSpaceOut.\nMinSpaceOut choose one of the contraction that produces a minimum output tensor size,\nMinSpaceDiff choose one of the contraction that decrease the space most.\nnrepeat is the number of repeatition, returns the best contraction order.\n\n\n\n\n\n","category":"type"},{"location":"ref/#OMEinsumContractionOrders.TreeSA","page":"References","title":"OMEinsumContractionOrders.TreeSA","text":"TreeSA{RT,IT,GM}\nTreeSA(; sc_target=20, βs=collect(0.01:0.05:15), ntrials=10, niters=50,\n    sc_weight=1.0, rw_weight=0.2, initializer=:greedy, greedy_config=GreedyMethod(; nrepeat=1))\n\nOptimize the einsum contraction pattern using the simulated annealing on tensor expression tree.\n\nsc_target is the target space complexity,\nntrials, βs and niters are annealing parameters, doing ntrials indepedent annealings, each has inverse tempteratures specified by βs, in each temperature, do niters updates of the tree.\nsc_weight is the relative importance factor of space complexity in the loss compared with the time complexity.\nrw_weight is the relative importance factor of memory read and write in the loss compared with the time complexity.\ninitializer specifies how to determine the initial configuration, it can be :greedy or :random. If it is using :greedy method to generate the initial configuration, it also uses two extra arguments greedy_method and greedy_nrepeat.\nnslices is the number of sliced legs, default is 0.\n\nReferences\n\nRecursive Multi-Tensor Contraction for XEB Verification of Quantum Circuits\n\n\n\n\n\n","category":"type"},{"location":"ref/#OMEinsumContractionOrders.SABipartite","page":"References","title":"OMEinsumContractionOrders.SABipartite","text":"SABipartite{RT,BT}\nSABipartite(; sc_target=25, ntrials=50, βs=0.1:0.2:15.0, niters=1000\n    max_group_size=40, greedy_config=GreedyMethod(), initializer=:random)\n\nOptimize the einsum code contraction order using the Simulated Annealing bipartition + Greedy approach. This program first recursively cuts the tensors into several groups using simulated annealing, with maximum group size specifed by max_group_size and maximum space complexity specified by sc_target, Then finds the contraction order inside each group with the greedy search algorithm. Other arguments are\n\nsize_dict, a dictionary that specifies leg dimensions,\nsc_target is the target space complexity, defined as log2(number of elements in the largest tensor),\nmax_group_size is the maximum size that allowed to used greedy search,\nβs is a list of inverse temperature 1/T,\nniters is the number of iteration in each temperature,\nntrials is the number of repetition (with different random seeds),\ngreedy_config configures the greedy method,\ninitializer, the partition configuration initializer, one can choose :random or :greedy (slow but better).\n\nReferences\n\nHyper-optimized tensor network contraction\n\n\n\n\n\n","category":"type"},{"location":"ref/#OMEinsumContractionOrders.KaHyParBipartite","page":"References","title":"OMEinsumContractionOrders.KaHyParBipartite","text":"KaHyParBipartite{RT,IT,GM}\nKaHyParBipartite(; sc_target, imbalances=collect(0.0:0.005:0.8),\n    max_group_size=40, greedy_config=GreedyMethod())\n\nOptimize the einsum code contraction order using the KaHyPar + Greedy approach. This program first recursively cuts the tensors into several groups using KaHyPar, with maximum group size specifed by max_group_size and maximum space complexity specified by sc_target, Then finds the contraction order inside each group with the greedy search algorithm. Other arguments are\n\nsc_target is the target space complexity, defined as log2(number of elements in the largest tensor),\nimbalances is a KaHyPar parameter that controls the group sizes in hierarchical bipartition,\nmax_group_size is the maximum size that allowed to used greedy search,\ngreedy_config is a greedy optimizer.\n\nReferences\n\nHyper-optimized tensor network contraction\nSimulating the Sycamore quantum supremacy circuits\n\n\n\n\n\n","category":"type"},{"location":"ref/#Others","page":"References","title":"Others","text":"","category":"section"},{"location":"ref/#Graph","page":"References","title":"Graph","text":"","category":"section"},{"location":"ref/","page":"References","title":"References","text":"is_independent_set\nmis_compactify!\nshow_graph\n\ndiagonal_coupled_graph\nsquare_lattice_graph\nunitdisk_graph","category":"page"},{"location":"ref/#GraphTensorNetworks.is_independent_set","page":"References","title":"GraphTensorNetworks.is_independent_set","text":"is_independent_set(g::SimpleGraph, vertices)\n\nReturn true if vertices is an independent set of graph g.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GraphTensorNetworks.mis_compactify!","page":"References","title":"GraphTensorNetworks.mis_compactify!","text":"mis_compactify!(tropicaltensor)\n\nCompactify tropical tensor for maximum independent set problem. It will eliminate some entries by setting them to zero, by the criteria that even these entries are removed, the MIS size is not changed.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GraphTensorNetworks.show_graph","page":"References","title":"GraphTensorNetworks.show_graph","text":"show_graph(locations, edges;\n    colors=[\"black\", \"black\", ...],\n    texts=[\"1\", \"2\", ...],\n    format=SVG,\n    bond_color=\"black\",\n    )\n\nPlots vertices at locations with colors specified by colors and texts specified by texts. You will need a VSCode, Pluto notebook or Jupyter notebook to show the image. If you want to write this image to the disk without displaying it in a frontend, please try\n\njulia> open(\"test.png\", \"w\") do f\n            viz_atoms(f, generate_sites(SquareLattice(), 5, 5))\n       end\n\nThe format keyword argument can also be Compose.SVG or Compose.PDF.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GraphTensorNetworks.diagonal_coupled_graph","page":"References","title":"GraphTensorNetworks.diagonal_coupled_graph","text":"diagonal_coupled_graph(mask::AbstractMatrix{Bool})\n\nCreate a masked diagonal coupled square lattice graph from a specified mask.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GraphTensorNetworks.square_lattice_graph","page":"References","title":"GraphTensorNetworks.square_lattice_graph","text":"square_lattice_graph(mask::AbstractMatrix{Bool})\n\nCreate a masked square lattice graph.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GraphTensorNetworks.unitdisk_graph","page":"References","title":"GraphTensorNetworks.unitdisk_graph","text":"unitdisk_graph(locs::AbstractVector, unit::Real)\n\nCreate a unit disk graph with locations specified by locs and unit distance unit.\n\n\n\n\n\n","category":"function"},{"location":"ref/","page":"References","title":"References","text":"One can also use random_regular_graph and smallgraph in Graphs to build special graphs.","category":"page"},{"location":"ref/#Lower-level-APIs","page":"References","title":"Lower level APIs","text":"","category":"section"},{"location":"ref/","page":"References","title":"References","text":"best_solutions\nbest2_solutions\nsolutions\nall_solutions\ngraph_polynomial\nmax_size\nmax_size_count","category":"page"},{"location":"ref/#GraphTensorNetworks.best_solutions","page":"References","title":"GraphTensorNetworks.best_solutions","text":"best_solutions(problem; all=false, usecuda=false)\n\nFind optimal solutions with bounding.\n\nWhen all is true, the program will use set for enumerate all possible solutions, otherwise, it will return one solution for each size.\nusecuda can not be true if you want to use set to enumerate all possible solutions.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GraphTensorNetworks.best2_solutions","page":"References","title":"GraphTensorNetworks.best2_solutions","text":"best2_solutions(problem; all=true, usecuda=false)\n\nFinding optimal and suboptimal solutions.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GraphTensorNetworks.solutions","page":"References","title":"GraphTensorNetworks.solutions","text":"solutions(problem, basetype; all, usecuda=false)\n\nGeneral routine to find solutions without bounding,\n\nbasetype can be a type with counting field,\nCountingTropical{Float64,Float64} for finding optimal solutions,\nPolynomial{Float64, :x} for enumerating all solutions,\nMax2Poly{Float64,Float64} for optimal and suboptimal solutions.\nWhen all is true, the program will use set for enumerate all possible solutions, otherwise, it will return one solution for each size.\nusecuda can not be true if you want to use set to enumerate all possible solutions.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GraphTensorNetworks.all_solutions","page":"References","title":"GraphTensorNetworks.all_solutions","text":"all_solutions(problem)\n\nFinding all solutions grouped by size. e.g. when the problem is MaximalIndependence, it computes all maximal independent sets, or the maximal cliques of it complement.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GraphTensorNetworks.graph_polynomial","page":"References","title":"GraphTensorNetworks.graph_polynomial","text":"graph_polynomial(problem, method; usecuda=false, kwargs...)\n\nComputing the graph polynomial for specific problem.\n\nproblem can be one of the following instances,\nIndependence for the independence polynomial,\nMaximalIndependence for the maximal independence polynomial,\nMatching for the matching polynomial,\nmethod can be one of the following inputs,\nVal(:finitefield), compute exactly with the finite field method.   It consumes additional kwargs [max_iter, maxorder], where maxorder is maximum order of polynomial   and max_iter is the maximum number of primes numbers to use in the finitefield algebra.   max_iter can be determined automatically in most cases.\nVal(:polynomial), compute directly with Polynomial number type,\nVal(:fft), compute with the fast fourier transformation approach, fast but needs to tune the hyperparameter r.   It Consumes additional kwargs [maxorder, r]. The larger r is,   the more accurate the factors of high order terms, and the less accurate the factors of low order terms.\nVal(:fitting), compute with the polynomial fitting approach, fast but inaccurate for large graphs.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GraphTensorNetworks.max_size","page":"References","title":"GraphTensorNetworks.max_size","text":"max_size(problem; usecuda=false)\n\nReturns the maximum size of the graph problem.  A shorthand of solve(problem, SizeMax(); usecuda=false).\n\n\n\n\n\n","category":"function"},{"location":"ref/#GraphTensorNetworks.max_size_count","page":"References","title":"GraphTensorNetworks.max_size_count","text":"max_size_count(problem; usecuda=false)\n\nReturns the maximum size and the counting of the graph problem. It is a shorthand of solve(problem, CountingMax(); usecuda=false).\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = GraphTensorNetworks","category":"page"},{"location":"#GraphTensorNetworks","page":"Home","title":"GraphTensorNetworks","text":"","category":"section"},{"location":"#Background-knowledge","page":"Home","title":"Background knowledge","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Please check our paper \"Computing properties of independent sets by generic programming tensor networks\". If you find our paper or software useful in your work, please cite us.","category":"page"},{"location":"#Quick-start","page":"Home","title":"Quick start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"You can find a good installation guide and a quick start in our README.","category":"page"}]
}
