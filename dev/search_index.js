var documenterSearchIndex = {"docs":
[{"location":"tutorials/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"EditURL = \"https://github.com/Happy-Diode/GraphTensorNetworks.jl/blob/master/examples/MaxCut/main.jl\"","category":"page"},{"location":"tutorials/MaxCut/#Cutting-problem-(Spin-glass-problem)","page":"Cutting problem","title":"Cutting problem (Spin-glass problem)","text":"","category":"section"},{"location":"tutorials/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"note: Note\nThis tutorial only covers the cutting problem specific features, It is recommended to read the Independent set problem tutorial too to know more abouthow to optimize the tensor network contraction order,\nwhat are the other graph properties computable,\nhow to select correct method to compute graph properties,\nhow to compute weighted graphs and handle open vertices.","category":"page"},{"location":"tutorials/MaxCut/#Introduction","page":"Cutting problem","title":"Introduction","text":"","category":"section"},{"location":"tutorials/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"using GraphTensorNetworks, Graphs","category":"page"},{"location":"tutorials/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"Please check the docstring of MaxCut for the definition of the vertex cutting problem.","category":"page"},{"location":"tutorials/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"@doc MaxCut","category":"page"},{"location":"tutorials/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"In the following, we are going to defined an cutting problem for the Petersen graph.","category":"page"},{"location":"tutorials/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"graph = Graphs.smallgraph(:petersen)","category":"page"},{"location":"tutorials/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"We can visualize this graph using the following function","category":"page"},{"location":"tutorials/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"rot15(a, b, i::Int) = cos(2i*π/5)*a + sin(2i*π/5)*b, cos(2i*π/5)*b - sin(2i*π/5)*a\n\nlocations = [[rot15(0.0, 1.0, i) for i=0:4]..., [rot15(0.0, 0.6, i) for i=0:4]...]\n\nshow_graph(graph; locs=locations)","category":"page"},{"location":"tutorials/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"Then we define the cutting problem as","category":"page"},{"location":"tutorials/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"problem = MaxCut(graph);\nnothing #hide","category":"page"},{"location":"tutorials/MaxCut/#Solving-properties","page":"Cutting problem","title":"Solving properties","text":"","category":"section"},{"location":"tutorials/MaxCut/#Maximum-cut-size-\\gamma(G)","page":"Cutting problem","title":"Maximum cut size gamma(G)","text":"","category":"section"},{"location":"tutorials/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"max_cut_size = solve(problem, SizeMax())[]","category":"page"},{"location":"tutorials/MaxCut/#Counting-properties","page":"Cutting problem","title":"Counting properties","text":"","category":"section"},{"location":"tutorials/MaxCut/#graph-polynomial","page":"Cutting problem","title":"graph polynomial","text":"","category":"section"},{"location":"tutorials/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"Since the variable x is defined on edges, hence the coefficients of the polynomial is the number of configurations having different number of anti-parallel edges.","category":"page"},{"location":"tutorials/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"max_config = solve(problem, GraphPolynomial())[]","category":"page"},{"location":"tutorials/MaxCut/#Configuration-properties","page":"Cutting problem","title":"Configuration properties","text":"","category":"section"},{"location":"tutorials/MaxCut/#finding-one-max-cut-solution","page":"Cutting problem","title":"finding one max cut solution","text":"","category":"section"},{"location":"tutorials/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"max_edge_config = solve(problem, SingleConfigMax())[]","category":"page"},{"location":"tutorials/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"These configurations are defined on edges, we need to find a valid assignment on vertices","category":"page"},{"location":"tutorials/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"max_vertex_config = cut_assign(graph, max_edge_config.c.data)\n\nmax_cut_size_verify = cut_size(graph, max_vertex_config)","category":"page"},{"location":"tutorials/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"You should see a consistent result as above max_cut_size.","category":"page"},{"location":"tutorials/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"show_graph(graph; locs=locations, colors=[\n        iszero(max_vertex_config[i]) ? \"white\" : \"red\" for i=1:nv(graph)])","category":"page"},{"location":"tutorials/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"","category":"page"},{"location":"tutorials/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/Coloring/","page":"Matching problem","title":"Matching problem","text":"EditURL = \"https://github.com/Happy-Diode/GraphTensorNetworks.jl/blob/master/examples/Coloring/main.jl\"","category":"page"},{"location":"tutorials/Coloring/#Coloring-problem","page":"Matching problem","title":"Coloring problem","text":"","category":"section"},{"location":"tutorials/Coloring/","page":"Matching problem","title":"Matching problem","text":"note: Note\nThis tutorial only covers the coloring problem specific features, It is recommended to read the Independent set problem tutorial too to know more abouthow to optimize the tensor network contraction order,\nwhat are the other graph properties computable,\nhow to select correct method to compute graph properties,\nhow to compute weighted graphs and handle open vertices.","category":"page"},{"location":"tutorials/Coloring/#Introduction","page":"Matching problem","title":"Introduction","text":"","category":"section"},{"location":"tutorials/Coloring/","page":"Matching problem","title":"Matching problem","text":"using GraphTensorNetworks, Graphs","category":"page"},{"location":"tutorials/Coloring/","page":"Matching problem","title":"Matching problem","text":"Please check the docstring of Coloring for the definition of the vertex cutting problem.","category":"page"},{"location":"tutorials/Coloring/","page":"Matching problem","title":"Matching problem","text":"@doc Coloring","category":"page"},{"location":"tutorials/Coloring/","page":"Matching problem","title":"Matching problem","text":"In the following, we are going to defined a 3-coloring problem for the Petersen graph.","category":"page"},{"location":"tutorials/Coloring/","page":"Matching problem","title":"Matching problem","text":"graph = Graphs.smallgraph(:petersen)","category":"page"},{"location":"tutorials/Coloring/","page":"Matching problem","title":"Matching problem","text":"We can visualize this graph using the following function","category":"page"},{"location":"tutorials/Coloring/","page":"Matching problem","title":"Matching problem","text":"rot15(a, b, i::Int) = cos(2i*π/5)*a + sin(2i*π/5)*b, cos(2i*π/5)*b - sin(2i*π/5)*a\n\nlocations = [[rot15(0.0, 1.0, i) for i=0:4]..., [rot15(0.0, 0.6, i) for i=0:4]...]\n\nshow_graph(graph; locs=locations)","category":"page"},{"location":"tutorials/Coloring/","page":"Matching problem","title":"Matching problem","text":"Then we define the cutting problem as","category":"page"},{"location":"tutorials/Coloring/","page":"Matching problem","title":"Matching problem","text":"problem = Coloring{3}(graph);\nnothing #hide","category":"page"},{"location":"tutorials/Coloring/#Solving-properties","page":"Matching problem","title":"Solving properties","text":"","category":"section"},{"location":"tutorials/Coloring/","page":"Matching problem","title":"Matching problem","text":"","category":"page"},{"location":"tutorials/Coloring/","page":"Matching problem","title":"Matching problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/Matching/","page":"Vertex matching problem","title":"Vertex matching problem","text":"EditURL = \"https://github.com/Happy-Diode/GraphTensorNetworks.jl/blob/master/examples/Matching/main.jl\"","category":"page"},{"location":"tutorials/Matching/#Vertex-matching-problem","page":"Vertex matching problem","title":"Vertex matching problem","text":"","category":"section"},{"location":"tutorials/Matching/","page":"Vertex matching problem","title":"Vertex matching problem","text":"note: Note\nThis tutorial only covers the vertex matching problem specific features, It is recommended to read the Independent set problem tutorial too to know more abouthow to optimize the tensor network contraction order,\nwhat are the other graph properties computable,\nhow to select correct method to compute graph properties,\nhow to compute weighted graphs and handle open vertices.","category":"page"},{"location":"tutorials/Matching/#Introduction","page":"Vertex matching problem","title":"Introduction","text":"","category":"section"},{"location":"tutorials/Matching/","page":"Vertex matching problem","title":"Vertex matching problem","text":"using GraphTensorNetworks, Graphs","category":"page"},{"location":"tutorials/Matching/","page":"Vertex matching problem","title":"Vertex matching problem","text":"Please check the docstring of Matching for the definition of the vertex matching problem.","category":"page"},{"location":"tutorials/Matching/","page":"Vertex matching problem","title":"Vertex matching problem","text":"@doc Matching","category":"page"},{"location":"tutorials/Matching/","page":"Vertex matching problem","title":"Vertex matching problem","text":"In the following, we are going to defined a matching problem for the Petersen graph.","category":"page"},{"location":"tutorials/Matching/","page":"Vertex matching problem","title":"Vertex matching problem","text":"graph = Graphs.smallgraph(:petersen)","category":"page"},{"location":"tutorials/Matching/","page":"Vertex matching problem","title":"Vertex matching problem","text":"We can visualize this graph using the following function","category":"page"},{"location":"tutorials/Matching/","page":"Vertex matching problem","title":"Vertex matching problem","text":"rot15(a, b, i::Int) = cos(2i*π/5)*a + sin(2i*π/5)*b, cos(2i*π/5)*b - sin(2i*π/5)*a\n\nlocations = [[rot15(0.0, 1.0, i) for i=0:4]..., [rot15(0.0, 0.6, i) for i=0:4]...]\n\nshow_graph(graph; locs=locations)","category":"page"},{"location":"tutorials/Matching/","page":"Vertex matching problem","title":"Vertex matching problem","text":"Then we define the matching problem as","category":"page"},{"location":"tutorials/Matching/","page":"Vertex matching problem","title":"Vertex matching problem","text":"problem = Matching(graph);\nnothing #hide","category":"page"},{"location":"tutorials/Matching/#Solving-properties","page":"Vertex matching problem","title":"Solving properties","text":"","category":"section"},{"location":"tutorials/Matching/","page":"Vertex matching problem","title":"Vertex matching problem","text":"","category":"page"},{"location":"tutorials/Matching/","page":"Vertex matching problem","title":"Vertex matching problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/MaximalIndependence/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"EditURL = \"https://github.com/Happy-Diode/GraphTensorNetworks.jl/blob/master/examples/MaximalIndependence/main.jl\"","category":"page"},{"location":"tutorials/MaximalIndependence/#Maximal-independent-set-problem","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"","category":"section"},{"location":"tutorials/MaximalIndependence/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"note: Note\nThis tutorial only covers the maximal independent set problem specific features, It is recommended to read the Independent set problem tutorial too to know more abouthow to optimize the tensor network contraction order,\nwhat are the other graph properties computable,\nhow to select correct method to compute graph properties,\nhow to compute weighted graphs and handle open vertices.","category":"page"},{"location":"tutorials/MaximalIndependence/#Introduction","page":"Maximal independent set problem","title":"Introduction","text":"","category":"section"},{"location":"tutorials/MaximalIndependence/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"using GraphTensorNetworks, Graphs","category":"page"},{"location":"tutorials/MaximalIndependence/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"Please check the docstring of MaximalIndependence for the definition of the maximal independence problem.","category":"page"},{"location":"tutorials/MaximalIndependence/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"@doc MaximalIndependence","category":"page"},{"location":"tutorials/MaximalIndependence/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"In the following, we are going to defined an cutting problem for the Petersen graph.","category":"page"},{"location":"tutorials/MaximalIndependence/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"graph = Graphs.smallgraph(:petersen)","category":"page"},{"location":"tutorials/MaximalIndependence/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"We can visualize this graph using the following function","category":"page"},{"location":"tutorials/MaximalIndependence/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"rot15(a, b, i::Int) = cos(2i*π/5)*a + sin(2i*π/5)*b, cos(2i*π/5)*b - sin(2i*π/5)*a\n\nlocations = [[rot15(0.0, 1.0, i) for i=0:4]..., [rot15(0.0, 0.6, i) for i=0:4]...]\n\nshow_graph(graph; locs=locations)","category":"page"},{"location":"tutorials/MaximalIndependence/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"Then we define the maximal independent set problem as","category":"page"},{"location":"tutorials/MaximalIndependence/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"problem = MaximalIndependence(graph);\nnothing #hide","category":"page"},{"location":"tutorials/MaximalIndependence/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"The tensor network structure is different from that of Independence, Its tensor is defined on a vertex and its neighbourhood, and it makes the contraction of MaximalIndependence much harder.","category":"page"},{"location":"tutorials/MaximalIndependence/#Solving-properties","page":"Maximal independent set problem","title":"Solving properties","text":"","category":"section"},{"location":"tutorials/MaximalIndependence/#Counting-properties","page":"Maximal independent set problem","title":"Counting properties","text":"","category":"section"},{"location":"tutorials/MaximalIndependence/#maximal-independence-polynomial","page":"Maximal independent set problem","title":"maximal independence polynomial","text":"","category":"section"},{"location":"tutorials/MaximalIndependence/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"max_config = solve(problem, GraphPolynomial())[]","category":"page"},{"location":"tutorials/MaximalIndependence/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"Since it only counts the maximal independent sets, the first several coefficients are 0.","category":"page"},{"location":"tutorials/MaximalIndependence/#Configuration-properties","page":"Maximal independent set problem","title":"Configuration properties","text":"","category":"section"},{"location":"tutorials/MaximalIndependence/#finding-all-maximal-independent-set","page":"Maximal independent set problem","title":"finding all maximal independent set","text":"","category":"section"},{"location":"tutorials/MaximalIndependence/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"max_edge_config = solve(problem, ConfigsAll())[]","category":"page"},{"location":"tutorials/MaximalIndependence/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"This result should be consistent with that given by the Bron Kerbosch algorithm on the complement of Petersen graph.","category":"page"},{"location":"tutorials/MaximalIndependence/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"maximal_cliques = maximal_cliques(complement(graph))","category":"page"},{"location":"tutorials/MaximalIndependence/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"For sparse graphs, the generic tensor network approach is usually much faster and memory efficient.","category":"page"},{"location":"tutorials/MaximalIndependence/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"","category":"page"},{"location":"tutorials/MaximalIndependence/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"EditURL = \"https://github.com/Happy-Diode/GraphTensorNetworks.jl/blob/master/examples/PaintShop/main.jl\"","category":"page"},{"location":"tutorials/PaintShop/#Binary-paint-shop-problem","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"","category":"section"},{"location":"tutorials/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"note: Note\nThis tutorial only covers the binary paint shop problem specific features, It is recommended to read the Independent set problem tutorial too to know more abouthow to optimize the tensor network contraction order,\nwhat are the other graph properties computable,\nhow to select correct method to compute graph properties,\nhow to compute weighted graphs and handle open vertices.","category":"page"},{"location":"tutorials/PaintShop/#Introduction","page":"Binary paint shop problem","title":"Introduction","text":"","category":"section"},{"location":"tutorials/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"using GraphTensorNetworks, Graphs","category":"page"},{"location":"tutorials/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"Please check the docstring of PaintShop for the definition of the binary paint shop problem.","category":"page"},{"location":"tutorials/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"@doc PaintShop","category":"page"},{"location":"tutorials/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"In the following, we are going to defined a binary paint shop problem for the following string","category":"page"},{"location":"tutorials/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"sequence = \"abaccb\"","category":"page"},{"location":"tutorials/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"","category":"page"},{"location":"tutorials/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/Others/","page":"Other problems","title":"Other problems","text":"EditURL = \"https://github.com/Happy-Diode/GraphTensorNetworks.jl/blob/master/examples/Others/main.jl\"","category":"page"},{"location":"tutorials/Others/#Other-problems-can-be-solved-by-GraphTensorNetworks","page":"Other problems","title":"Other problems can be solved by GraphTensorNetworks","text":"","category":"section"},{"location":"tutorials/Others/#Set-packing-problem","page":"Other problems","title":"Set packing problem","text":"","category":"section"},{"location":"tutorials/Others/","page":"Other problems","title":"Other problems","text":"It is a generalization of the independent set problem.","category":"page"},{"location":"tutorials/Others/#Vertex-cover-problem","page":"Other problems","title":"Vertex cover problem","text":"","category":"section"},{"location":"tutorials/Others/","page":"Other problems","title":"Other problems","text":"A vertex cover is a complement of an independent set.","category":"page"},{"location":"tutorials/Others/#Maximal-clique-problem","page":"Other problems","title":"Maximal clique problem","text":"","category":"section"},{"location":"tutorials/Others/","page":"Other problems","title":"Other problems","text":"The maximal clique of graph G is a maximal clique of G's complement graph.","category":"page"},{"location":"tutorials/Others/","page":"Other problems","title":"Other problems","text":"","category":"page"},{"location":"tutorials/Others/","page":"Other problems","title":"Other problems","text":"This page was generated using Literate.jl.","category":"page"},{"location":"ref/#References","page":"References","title":"References","text":"","category":"section"},{"location":"ref/#Graph-problems","page":"References","title":"Graph problems","text":"","category":"section"},{"location":"ref/","page":"References","title":"References","text":"solve\nGraphProblem\nIndependence\nMaximalIndependence\nMatching\nColoring\nMaxCut\nPaintShop","category":"page"},{"location":"ref/#GraphTensorNetworks.solve","page":"References","title":"GraphTensorNetworks.solve","text":"solve(problem, property; usecuda=false, T=Float64)\n\nSolving a certain property of a graph problem.\n\nPositional Arguments\n\nproblem is the graph problem with tensor network information,\nproperty is string specifying the task. Using the maximum independent set problem as an example, it can be one of\nSizeMax for finding maximum configuration size,\nCountingMax for counting configurations with top K sizes,\nCountingAll for counting all configurations,\nGraphPolynomial for evaluating the graph polynomial,\nSingleConfigMax for finding one maximum configuration,\nConfigsMax for enumerating configurations with top K sizes,\nConfigsAll for enumerating all configurations,\n\nKeyword arguments\n\nusecuda is a switch to use CUDA (if possible), user need to call statement using CUDA before turning on this switch.\nT is the \"base\" element type, sometimes can be used to reduce the memory cost.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GraphTensorNetworks.GraphProblem","page":"References","title":"GraphTensorNetworks.GraphProblem","text":"GraphProblem\n\nThe abstract base type of graph problems.\n\n\n\n\n\n","category":"type"},{"location":"ref/#GraphTensorNetworks.Independence","page":"References","title":"GraphTensorNetworks.Independence","text":"Independence{CT<:AbstractEinsum,WT<:Union{UnWeighted, Vector}} <: GraphProblem\nIndependence(graph; weights=UnWeighted(), openvertices=(),\n             optimizer=GreedyMethod(), simplifier=nothing)\n\nThe Independent set problem. In the constructor, weights are the weights of vertices. openvertices specifies labels for the output tensor. optimizer and simplifier are for tensor network optimization, check optimize_code for details.\n\nProblem definition\n\nIn graph theory, an independent set is a set of vertices in a graph, no two of which are adjacent.\n\nGraph polynomial\n\nThe graph polynomial defined for the independence problem is known as the independence polynomial.\n\nI(G x) = sum_k=0^alpha(G) a_k x^k\n\nwhere alpha(G) is the maximum independent set size,  a_k is the number of independent sets of size k in graph G=(VE). The total number of independent sets is thus equal to I(G 1).\n\nTensor network\n\nIn tensor network representation of the independent set problem, we map a vertex iin V to a label s_i in 0 1 of dimension 2, where we use 0 (1) to denote a vertex is absent (present) in the set. For each label s_i, we defined a parametrized rank-one vertex tensor W(x_i) as\n\nW(x_i)_s_i = left(beginmatrix\n    1 \n    x_i\nendmatrixright)_s_i\n\nWe use subscripts to index tensor elements, e.g.W(x_i)_0=1 is the first element associated with s_i=0 and W(x_i)_1=x_i is the second element associated with s_i=1. Similarly, on each edge (u v), we define a matrix B indexed by s_u and s_v as\n\nB_s_i s_j = left(beginmatrix\n    1   1\n    1  0\nendmatrixright)_s_is_j\n\nIts contraction time space complexity is 2^rm tw(G), where rm tw(G) is the tree-width of G.\n\n\n\n\n\n","category":"type"},{"location":"ref/#GraphTensorNetworks.MaximalIndependence","page":"References","title":"GraphTensorNetworks.MaximalIndependence","text":"MaximalIndependence{CT<:AbstractEinsum,WT<:Union{UnWeighted, Vector}} <: GraphProblem\nMaximalIndependence(graph; weights=UnWeighted(), openvertices=(),\n             optimizer=GreedyMethod(), simplifier=nothing)\n\nMaximal independent set problem. In the constructor, weights are the weights of vertices. optimizer and simplifier are for tensor network optimization, check optimize_code for details.\n\nProblem definition\n\nIn graph theory, a maximal independent set is an independent set that is not a subset of any other independent set. It is different from maximum independent set because it does not require the set to have the max size.\n\nGraph polynomial\n\nThe graph polynomial defined for the maximal independent set problem is\n\nI_rm max(G x) = sum_k=0^alpha(G) b_k x^k\n\nwhere b_k is the number of maximal independent sets of size k in graph G=(V E).\n\nTensor network\n\nFor a vertex vin V, we define a boolean degree of freedom s_vin0 1. We defined the restriction on its neighbourhood Nv:\n\nT(x_v)_s_1s_2ldotss_N(v)s_v = begincases\n    s_vx_v  s_1=s_2=ldots=s_N(v)=0\n    1-s_v textotherwise\nendcases\n\nIntuitively, it means if all the neighbourhood vertices are not in I_m, i.e., s_1=s_2=ldots=s_N(v)=0, then v should be in I_m and contribute a factor x_v, otherwise, if any of the neighbourhood vertices is in I_m, then v cannot be in I_m.\n\nIts contraction time space complexity is no longer determined by the tree-width of the original graph G. It is often harder to contract this tensor network than to contract the one for regular independent set problem.\n\n\n\n\n\n","category":"type"},{"location":"ref/#GraphTensorNetworks.Matching","page":"References","title":"GraphTensorNetworks.Matching","text":"Matching{CT<:AbstractEinsum} <: GraphProblem\nMatching(graph; openvertices=(), optimizer=GreedyMethod(), simplifier=nothing)\n\nVertex matching problem. optimizer and simplifier are for tensor network optimization, check optimize_code for details.\n\nProblem definition\n\nA k-matching in a graph G is a set of k edges, no two of which have a vertex in common.\n\nGraph polynomial\n\nThe matching polynomial adopts the first definition in wiki page\n\nM(G x) = sumlimits_k=1^V2 c_k x^k\n\nwhere k is the number of matches, and coefficients c_k are the corresponding counting.\n\nTensor network\n\nWe map an edge (u v) in E to a label langle u vrangle in 0 1 in a tensor network, where 1 means two vertices of an edge are matched, 0 means otherwise. Then we define a tensor of rank d(v) = N(v) on vertex v such that,\n\nW_langle v n_1rangle langle v n_2 rangle ldots langle v n_d(v)rangle = begincases\n    1  sum_i=1^d(v) langle v n_i rangle leq 1\n    0  textotherwise\nendcases\n\nand a tensor of rank 1 on the bond\n\nB_langle v wrangle = begincases\n1  langle v w rangle = 0 \nx  langle v w rangle = 1\nendcases\n\nwhere label langle v w rangle is equivalent to langle wvrangle.\n\n\n\n\n\n","category":"type"},{"location":"ref/#GraphTensorNetworks.Coloring","page":"References","title":"GraphTensorNetworks.Coloring","text":"Coloring{K,CT<:AbstractEinsum} <: GraphProblem\nColoring{K}(graph; openvertices=(), optimizer=GreedyMethod(), simplifier=nothing)\n\nVertex Coloring problem. optimizer and simplifier are for tensor network optimization, check optimize_code for details.\n\nProblem definition\n\nA vertex coloring is an assignment of labels or colors to each vertex of a graph such that no edge connects two identically colored vertices. \n\nTensor network\n\nLet us use 3-colouring problem defined on vertices as an example. For a vertex v, we define the degree of freedoms c_vin123 and a vertex tensor labelled by it as\n\nW(v) = left(beginmatrix\n    r_v\n    g_v\n    b_v\nendmatrixright)\n\nFor an edge (u v), we define an edge tensor as a matrix labelled by (c_u c_v) to specify the constraint\n\nB = left(beginmatrix\n    0  1  1\n    1  0  1\n    1  1  0\nendmatrixright)\n\nThe number of possible colouring can be obtained by contracting this tensor network by setting vertex tensor elements r_v g_v and b_v to 1.\n\n\n\n\n\n","category":"type"},{"location":"ref/#GraphTensorNetworks.MaxCut","page":"References","title":"GraphTensorNetworks.MaxCut","text":"MaxCut{CT<:AbstractEinsum,WT<:Union{UnWeighted, Vector}} <: GraphProblem\nMaxCut(graph; weights=UnWeighted(), openvertices=(),\n            optimizer=GreedyMethod(), simplifier=nothing)\n\nCut problem (or spin glass problem). In the constructor, weights are the weights of edges. optimizer and simplifier are for tensor network optimization, check optimize_code for details.\n\nProblem definition\n\nIn graph theory, a cut is a partition of the vertices of a graph into two disjoint subsets. A maximum cut is a cut whose size is at least the size of any other cut, where the size of a cut is the number of edges (or the sum of weights on edges) crossing the cut.\n\nGraph polynomial\n\nThe graph polynomial defined for the cut problem is\n\nC(G x) = sum_k=0^gamma(G) c_k x^k\n\nwhere alpha(G) is the maximum independent set size,  c_k2 is the number of cuts of size k in graph G=(VE).\n\nTensor network\n\nFor a vertex vin V, we define a boolean degree of freedom s_vin0 1. Then the maximum cut problem can be encoded to tensor networks by mapping an edge (ij)in E to an edge matrix labelled by s_is_j\n\nB(x_langle i jrangle) = left(beginmatrix\n    1  x_langle i jrangle\n    x_langle i jrangle  1\nendmatrixright)\n\nwhere variable x_langle i jrangle represents a cut on edge (i j) or a domain wall of an Ising spin glass. Similar to other problems, we can define a polynomial about edges variables by setting x_langle i jrangle = x, where its k-th coefficient is two times the number of configurations of cut size k.\n\nIts contraction time space complexity is 2^rm tw(G), where rm tw(G) is the tree-width of G.\n\n\n\n\n\n","category":"type"},{"location":"ref/#GraphTensorNetworks.PaintShop","page":"References","title":"GraphTensorNetworks.PaintShop","text":"PaintShop{CT<:AbstractEinsum} <: GraphProblem\nPaintShop(labels::AbstractVector; openvertices=(),\n         optimizer=GreedyMethod(), simplifier=nothing)\n\nThe binary paint shop problem.\n\nExample\n\nOne can encode the paint shop problem abaccb as the following\n\njulia> symbols = collect(\"abaccb\");\n\njulia> pb = PaintShop(symbols);\n\njulia> solve(pb, SizeMax())[]\n3.0ₜ\n\njulia> solve(pb, ConfigsMax())[].c.data\n2-element Vector{StaticBitVector{5, 1}}:\n 01101\n 01101\n\nIn our definition, we find the maximum number of unchanged color in this sequence, i.e. (n-1) - (minimum number of color changes) In the output of maximum configurations, the two configurations are defined on 5 bonds i.e. pairs of (i, i+1), 0 means color changed, while 1 means color not changed. If we denote two \"colors\" as r and b, then the optimal painting is rbbbrr or brrrbb, both change the colors twice.\n\n\n\n\n\n","category":"type"},{"location":"ref/","page":"References","title":"References","text":"set_packing","category":"page"},{"location":"ref/#GraphTensorNetworks.set_packing","page":"References","title":"GraphTensorNetworks.set_packing","text":"set_packing(sets; openvertices=(), optimizer=GreedyMethod(), simplifier=nothing)\n\nSet packing is a generalization of independent set problem to hypergraphs. Calling this function will return you an Independence instance. sets are a vector of vectors, each element being a vertex in the independent set problem. optimizer and simplifier are for tensor network optimization, check optimize_code for details.\n\nExample\n\njulia> sets = [[1, 2, 5], [1, 3], [2, 4], [3, 6], [2, 3, 6]];  # each set is a vertex\n\njulia> gp = set_packing(sets);\n\njulia> res = best_solutions(gp; all=true)[]\n(2, {10010, 00110, 01100})ₜ\n\n\n\n\n\n","category":"function"},{"location":"ref/#Graph-Problem-Interfaces","page":"References","title":"Graph Problem Interfaces","text":"","category":"section"},{"location":"ref/","page":"References","title":"References","text":"GraphTensorNetworks.generate_tensors\nsymbols\nflavors\nget_weights\nnflavor","category":"page"},{"location":"ref/#GraphTensorNetworks.generate_tensors","page":"References","title":"GraphTensorNetworks.generate_tensors","text":"generate_tensors(func, problem::GraphProblem)\n\nGenerate a vector of tensors as the inputs of the tensor network contraction code problem.code. func is a function to customize the tensors. func(symbol) returns a vector of elements, the length of which is same as the number of flavors.\n\nExample\n\nThe following code gives your the maximum independent set size\n\njulia> using Graphs, GraphTensorNetworks\n\njulia> gp = Independence(smallgraph(:petersen));\n\njulia> f(x) = Tropical.([0, 1.0])\nf (generic function with 1 method)\n\njulia> getixsv(gp.code)\n25-element Vector{Vector{Int64}}:\n [1]\n [2]\n [3]\n [4]\n [5]\n [6]\n [7]\n [8]\n [9]\n [10]\n ⋮\n [3, 8]\n [4, 5]\n [4, 9]\n [5, 10]\n [6, 8]\n [6, 9]\n [7, 9]\n [7, 10]\n [8, 10]\n\njulia> gp.code(GraphTensorNetworks.generate_tensors(f, gp)...)\n0-dimensional Array{TropicalNumbers.TropicalF64, 0}:\n4.0ₜ\n\n\n\n\n\n","category":"function"},{"location":"ref/#GraphTensorNetworks.symbols","page":"References","title":"GraphTensorNetworks.symbols","text":"symbols(problem::GraphProblem)\n\nThe symbols of a graph problem, they are the degrees of freedoms in the graph.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GraphTensorNetworks.flavors","page":"References","title":"GraphTensorNetworks.flavors","text":"flavors(::Type{<:GraphProblem})\n\nIt returns a vector of integers as the flavors of a degree of freedom. Its size is the same as the degree of freedom on a single vertex/edge.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GraphTensorNetworks.get_weights","page":"References","title":"GraphTensorNetworks.get_weights","text":"get_weights(problem::GraphProblem, sym)\n\nThe weights for the degree of freedom specified by sym of the graph problem, where sym is a symbol. In graph polynomial, integer weights are the orders of x.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GraphTensorNetworks.nflavor","page":"References","title":"GraphTensorNetworks.nflavor","text":"nflavor(::Type{<:GraphProblem})\n\nBond size is equal to the number of flavors.\n\n\n\n\n\n","category":"function"},{"location":"ref/","page":"References","title":"References","text":"To subtype GraphProblem, the new type must contain a code field to represent the (optimized) tensor network. Interfaces GraphTensorNetworks.generate_tensors, symbols, flavors and [get_weights] are required. [nflavor] is optimal.","category":"page"},{"location":"ref/#Graph-Problem-Utilities","page":"References","title":"Graph Problem Utilities","text":"","category":"section"},{"location":"ref/","page":"References","title":"References","text":"is_independent_set\nmis_compactify!\n\ncut_size\ncut_assign","category":"page"},{"location":"ref/#GraphTensorNetworks.is_independent_set","page":"References","title":"GraphTensorNetworks.is_independent_set","text":"is_independent_set(g::SimpleGraph, vertices)\n\nReturn true if vertices is an independent set of graph g.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GraphTensorNetworks.mis_compactify!","page":"References","title":"GraphTensorNetworks.mis_compactify!","text":"mis_compactify!(tropicaltensor)\n\nCompactify tropical tensor for maximum independent set problem. It will eliminate some entries by setting them to zero, by the criteria that even these entries are removed, the MIS size is not changed.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GraphTensorNetworks.cut_size","page":"References","title":"GraphTensorNetworks.cut_size","text":"cut_size(g::SimpleGraph, config; weights=UnWeighted())\n\nCompute the cut size from vertex config (an iterator).\n\n\n\n\n\n","category":"function"},{"location":"ref/#GraphTensorNetworks.cut_assign","page":"References","title":"GraphTensorNetworks.cut_assign","text":"cut_assign(g::SimpleGraph, config)\n\nReturns a valid vertex configurations (a vector of size nv(g)) from config (an iterator) defined on edges:\n\nassign two vertices with the same values if they are connected by an edge with configuration 0.\nassign two vertices with the different values if they are connected by an edge with configuration 1.\nerror if there is no valid assignment.\n\n\n\n\n\n","category":"function"},{"location":"ref/#Properties","page":"References","title":"Properties","text":"","category":"section"},{"location":"ref/","page":"References","title":"References","text":"SizeMax\nCountingAll\nCountingMax\nGraphPolynomial\nSingleConfigMax\nConfigsAll\nConfigsMax","category":"page"},{"location":"ref/#GraphTensorNetworks.SizeMax","page":"References","title":"GraphTensorNetworks.SizeMax","text":"SizeMax <: AbstractProperty\nSizeMax()\n\nThe maximum independent set size.\n\nThe corresponding tensor element type is Tropical.\nIt is compatible with weighted graph problems.\nBLAS (on CPU) and GPU are supported,\n\n\n\n\n\n","category":"type"},{"location":"ref/#GraphTensorNetworks.CountingAll","page":"References","title":"GraphTensorNetworks.CountingAll","text":"CountingAll <: AbstractProperty\nCountingAll()\n\nCounting the total number of sets. e.g. for Independence problem, it counts the independent sets.\n\nThe corresponding tensor element type is Base.Real.\nThe weights on graph does not have effect.\nBLAS (GPU and CPU) and GPU are supported,\n\n\n\n\n\n","category":"type"},{"location":"ref/#GraphTensorNetworks.CountingMax","page":"References","title":"GraphTensorNetworks.CountingMax","text":"CountingMax{K} <: AbstractProperty\nCountingMax(K=1)\n\nCounting the number of sets with K largest size. e.g. for Independence problem, it counts independent sets of size alpha(G) alpha(G)-1 ldots alpha(G)-K+1.\n\nThe corresponding tensor element type is CountingTropical for K == 1, and TruncatedPoly{K} for K > 1.\nWeighted graph problems is only supported for K == 1.\nGPU is supported,\n\n\n\n\n\n","category":"type"},{"location":"ref/#GraphTensorNetworks.GraphPolynomial","page":"References","title":"GraphTensorNetworks.GraphPolynomial","text":"GraphPolynomial{METHOD} <: AbstractProperty\nGraphPolynomial(; method=:finitefield, kwargs...)\n\nCompute the graph polynomial, e.g. for Independence problem, it is the independence polynomial. The METHOD type parameter can be one of the following symbols\n\n:finitefield, it uses finite field algebra to fit the polynomial.\nThe corresponding tensor element type is Mods.Mod,\nIt does not have round-off error,\nGPU is supported,\nIt accepts keyword arguments maxorder (optional, e.g. the MIS size in the Independence problem).\n:polynomial, the program uses polynomial numbers to solve the polynomial directly.\nThe corresponding tensor element type is Polynomials.Polynomial.\nIt might have small round-off error depending on the data type for storing the counting.\nIt has memory overhead that linear to the graph size.\n:fft, \nThe corresponding tensor element type is Base.Complex.\nIt has (controllable) round-off error.\nBLAS and GPU are supported.\nIt accepts keyword arguments maxorder (optional) and r,   if r > 1, one has better precision for coefficients of large order, if r < 1,   one has better precision for coefficients of small order.\n\nGraph polynomials are not defined for weighted graph problems.\n\n\n\n\n\n","category":"type"},{"location":"ref/#GraphTensorNetworks.SingleConfigMax","page":"References","title":"GraphTensorNetworks.SingleConfigMax","text":"SingleConfigMax{BOUNDED} <: AbstractProperty\nSingleConfigMax(; bounded=false)\n\nFinding single best solution, e.g. for Independence problem, it is one of the maximum independent sets.\n\nThe corresponding data type is CountingTropical{Float64,<:ConfigSampler} if BOUNDED is true, Tropical otherwise.\nWeighted graph problems is supported.\nGPU is supported,\n\n\n\n\n\n","category":"type"},{"location":"ref/#GraphTensorNetworks.ConfigsAll","page":"References","title":"GraphTensorNetworks.ConfigsAll","text":"ConfigsAll <:AbstractProperty\nConfigsAll()\n\nFind all valid configurations, e.g. for Independence problem, it is finding all independent sets.\n\nThe corresponding data type is ConfigEnumerator.\nWeights do not take effect.\n\n\n\n\n\n","category":"type"},{"location":"ref/#GraphTensorNetworks.ConfigsMax","page":"References","title":"GraphTensorNetworks.ConfigsMax","text":"ConfigsMax{K, BOUNDED} <:AbstractProperty\nConfigsMax(K=1; bounded=true)\n\nFind configurations with largest sizes, e.g. for Independence problem, it is finding all independent sets of sizes alpha(G) alpha(G)-1 ldots alpha(G)-K+1.\n\nThe corresponding data type is CountingTropical{Float64,<:ConfigEnumerator} for K == 1 and TruncatedPoly{K,<:ConfigEnumerator} for K > 1.\nWeighted graph problems is only supported for K == 1.\n\n\n\n\n\n","category":"type"},{"location":"ref/#Element-Algebras","page":"References","title":"Element Algebras","text":"","category":"section"},{"location":"ref/","page":"References","title":"References","text":"TropicalNumbers.Tropical\nTropicalNumbers.CountingTropical\nMods.Mod\nPolynomials.Polynomial\nTruncatedPoly\nMax2Poly\nConfigEnumerator\nConfigSampler","category":"page"},{"location":"ref/#TropicalNumbers.Tropical","page":"References","title":"TropicalNumbers.Tropical","text":"Tropical{T} <: Number\n\nTropical number is a semiring algebra that maps\n\n+ in regular algebra to max,\n* in regular algebra to +,\n1 in regular algebra to 0,\n0 in regular algebra to -Inf (for integer content types, this is chosen as a mall integer).\n\nWe implemented fast tropical matrix multiplication in TropicalGEMM.\n\n\n\n\n\n","category":"type"},{"location":"ref/#TropicalNumbers.CountingTropical","page":"References","title":"TropicalNumbers.CountingTropical","text":"CountingTropical{T,CT} <: Number\n\nCounting tropical number type is also a semiring algebra. It is tropical algebra with one extra field for counting, it is introduced in arXiv:2008.06888.\n\n\n\n\n\n","category":"type"},{"location":"ref/#Mods.Mod","page":"References","title":"Mods.Mod","text":"Mod{m}(v) creates a modular number in mod m with value mod(v,m).\n\n\n\n\n\n","category":"type"},{"location":"ref/#Polynomials.Polynomial","page":"References","title":"Polynomials.Polynomial","text":"Polynomial{T, X}(coeffs::AbstractVector{T}, [var = :x])\n\nConstruct a polynomial from its coefficients coeffs, lowest order first, optionally in terms of the given variable var which may be a character, symbol, or a string.\n\nIf p = a_n x^n + ldots + a_2 x^2 + a_1 x + a_0, we construct this through Polynomial([a_0, a_1, ..., a_n]).\n\nThe usual arithmetic operators are overloaded to work with polynomials as well as with combinations of polynomials and scalars. However, operations involving two polynomials of different variables causes an error except those involving a constant polynomial.\n\nnote: Note\nPolynomial is not axis-aware, and it treats coeffs simply as a list of coefficients with the first index always corresponding to the constant term. In order to use the axis of coeffs as exponents, consider using a LaurentPolynomial or possibly a SparsePolynomial.\n\nExamples\n\njulia> using Polynomials\n\njulia> Polynomial([1, 0, 3, 4])\nPolynomial(1 + 3*x^2 + 4*x^3)\n\njulia> Polynomial([1, 2, 3], :s)\nPolynomial(1 + 2*s + 3*s^2)\n\njulia> one(Polynomial)\nPolynomial(1.0)\n\n\n\n\n\n","category":"type"},{"location":"ref/#GraphTensorNetworks.TruncatedPoly","page":"References","title":"GraphTensorNetworks.TruncatedPoly","text":"TruncatedPoly{K,T,TO} <: Number\n\nPolynomial truncated to largest K orders. T is the coefficients type and TO is the orders type.\n\njulia> TruncatedPoly((1,2,3), 6)\nx^4 + 2*x^5 + 3*x^6\n\n\n\n\n\n","category":"type"},{"location":"ref/#GraphTensorNetworks.Max2Poly","page":"References","title":"GraphTensorNetworks.Max2Poly","text":"Max2Poly{T,TO} = TruncatedPoly{2,T,TO}\n\n\n\n\n\n","category":"type"},{"location":"ref/#GraphTensorNetworks.ConfigEnumerator","page":"References","title":"GraphTensorNetworks.ConfigEnumerator","text":"ConfigEnumerator{N,S,C}\n\nSet algebra for enumerating configurations, where N is the length of configurations, C is the size of storage in unit of UInt64, S is the bit width to store a single element in a configuration, i.e. log2(# of flavors), for bitstrings, it is 1`.\n\njulia> a = ConfigEnumerator([StaticBitVector([1,1,1,0,0]), StaticBitVector([1,0,0,0,1])])\n{11100, 10001}\n\njulia> b = ConfigEnumerator([StaticBitVector([0,0,0,0,0]), StaticBitVector([1,0,1,0,1])])\n{00000, 10101}\n\njulia> a + b\n{11100, 10001, 00000, 10101}\n\n\n\n\n\n","category":"type"},{"location":"ref/#GraphTensorNetworks.ConfigSampler","page":"References","title":"GraphTensorNetworks.ConfigSampler","text":"ConfigSampler{N,S,C}\n\nThe algebra for sampling one configuration, where N is the length of configurations, C is the size of storage in unit of UInt64, S is the bit width to store a single element in a configuration, i.e. log2(# of flavors), for bitstrings, it is 1`.\n\njulia> ConfigSampler(StaticBitVector([1,1,1,0,0]))\nConfigSampler{5, 1, 1}(11100)\n\n\n\n\n\n","category":"type"},{"location":"ref/","page":"References","title":"References","text":"StaticBitVector\nStaticElementVector\nsave_configs\nload_configs\n@bv_str\nonehotv\nis_commutative_semiring","category":"page"},{"location":"ref/#GraphTensorNetworks.StaticBitVector","page":"References","title":"GraphTensorNetworks.StaticBitVector","text":"StaticBitVector{N,C} = StaticElementVector{N,1,C}\n\n\n\n\n\n","category":"type"},{"location":"ref/#GraphTensorNetworks.StaticElementVector","page":"References","title":"GraphTensorNetworks.StaticElementVector","text":"StaticElementVector{N,S,C}\n\nN is the length of vector, C is the size of storage in unit of UInt64, S is the stride defined as the log2(# of flavors). When the number of flavors is 2, it is a StaticBitVector.\n\n\n\n\n\n","category":"type"},{"location":"ref/#GraphTensorNetworks.save_configs","page":"References","title":"GraphTensorNetworks.save_configs","text":"save_configs(filename, data::ConfigEnumerator; format=:binary)\n\nSave configurations data to file filename. The format is :binary or :text.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GraphTensorNetworks.load_configs","page":"References","title":"GraphTensorNetworks.load_configs","text":"load_configs(filename; format=:binary, bitlength=nothing, nflavors=2)\n\nLoad configurations from file filename. The format is :binary or :text. If the format is :binary, the bitstring length bitlength must be specified, nflavors specifies the degree of freedom.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GraphTensorNetworks.@bv_str","page":"References","title":"GraphTensorNetworks.@bv_str","text":"Constructing a static bit vector.\n\n\n\n\n\n","category":"macro"},{"location":"ref/#GraphTensorNetworks.onehotv","page":"References","title":"GraphTensorNetworks.onehotv","text":"onehotv(::Type{<:StaticElementVector}, i, v)\nonehotv(::Type{<:StaticBitVector, i)\n\nReturns a static element vector, with the value at location i being v (1 if not specified).\n\n\n\n\n\n","category":"function"},{"location":"ref/#GraphTensorNetworks.is_commutative_semiring","page":"References","title":"GraphTensorNetworks.is_commutative_semiring","text":"is_commutative_semiring(a::T, b::T, c::T) where T\n\nCheck if elements a, b and c satisfied the commutative semiring requirements.\n\nbeginalign*\n(a oplus b) oplus c = a oplus (b oplus c)  hspace5emtrianglerighttextcommutative monoid oplus with identity mathbb0\na oplus mathbb0 = mathbb0 oplus a = a \na oplus b = b oplus a \n\n(a odot b) odot c = a odot (b odot c)     hspace5emtriangleright textcommutative monoid odot with identity mathbb1\na odot  mathbb1 =  mathbb1 odot a = a \na odot b = b odot a \n\na odot (boplus c) = aodot b oplus aodot c    hspace5emtriangleright textleft and right distributive\n(aoplus b) odot c = aodot c oplus bodot c \n\na odot mathbb0 = mathbb0 odot a = mathbb0\nendalign*\n\n\n\n\n\n","category":"function"},{"location":"ref/#Tensor-Network","page":"References","title":"Tensor Network","text":"","category":"section"},{"location":"ref/","page":"References","title":"References","text":"optimize_code\ngetixsv\ngetiyv\ntimespace_complexity\ntimespacereadwrite_complexity\n@ein_str\nGreedyMethod\nTreeSA\nSABipartite\nKaHyParBipartite\nMergeVectors\nMergeGreedy","category":"page"},{"location":"ref/#OMEinsumContractionOrders.optimize_code","page":"References","title":"OMEinsumContractionOrders.optimize_code","text":"optimize_code(eincode, size_dict, optimizer = GreedyMethod(), simplifier=nothing)\n\nOptimize the einsum contraction code and reduce the time/space complexity of tensor network contraction. Returns a NestedEinsum instance. Input arguments are\n\neincode is an einsum contraction code instance, one of DynamicEinCode, StaticEinCode or NestedEinsum.\nsize is a dictionary of \"edge label=>edge size\" that contains the size information, one can use uniformsize(eincode, 2) to create a uniform size.\noptimizer is a CodeOptimizer instance, should be one of GreedyMethod, KaHyParBipartite, SABipartite or TreeSA. Check their docstrings for details.\nsimplifier is one of MergeVectors or MergeGreedy.\n\n\n\n\n\n","category":"function"},{"location":"ref/#OMEinsum.getixsv","page":"References","title":"OMEinsum.getixsv","text":"getixsv(code)\n\nGet labels of input tensors for EinCode, NestedEinsum and some other einsum like objects. Returns a vector of vector.\n\njulia> getixsv(ein\"(ij,jk),k->i\")\n3-element Vector{Vector{Char}}:\n ['i', 'j']\n ['j', 'k']\n ['k']\n\n\n\n\n\n","category":"function"},{"location":"ref/#OMEinsum.getiyv","page":"References","title":"OMEinsum.getiyv","text":"getiy(code)\n\nGet labels of the output tensor for EinCode, NestedEinsum and some other einsum like objects. Returns a vector.\n\njulia> getiyv(ein\"(ij,jk),k->i\")\n1-element Vector{Char}:\n 'i': ASCII/Unicode U+0069 (category Ll: Letter, lowercase)\n\n\n\n\n\n","category":"function"},{"location":"ref/#OMEinsum.timespace_complexity","page":"References","title":"OMEinsum.timespace_complexity","text":"timespace_complexity(eincode, size_dict)\n\nReturns the time and space complexity of the einsum contraction. The time complexity is defined as log2(number of element multiplication). The space complexity is defined as log2(size of the maximum intermediate tensor).\n\n\n\n\n\n","category":"function"},{"location":"ref/#OMEinsum.timespacereadwrite_complexity","page":"References","title":"OMEinsum.timespacereadwrite_complexity","text":"timespacereadwrite_complexity(eincode, size_dict)\n\nReturns the time, space and read-write complexity of the einsum contraction. The time complexity is defined as log2(number of element-wise multiplication). The space complexity is defined as log2(size of the maximum intermediate tensor). The read-write complexity is defined as log2(the number of read-write operations).\n\n\n\n\n\n","category":"function"},{"location":"ref/#OMEinsum.@ein_str","page":"References","title":"OMEinsum.@ein_str","text":"ein\"ij,jk -> ik\"(A,B)\n\nString macro interface which understands numpy.einsum's notation. Translates strings into StaticEinCode-structs that can be called to evaluate an einsum. To control evaluation order, use parentheses - instead of an EinCode, a NestedEinsum is returned which evaluates the expression according to parens. The valid character ranges for index-labels are a-z and α-ω.\n\nexample\n\njulia> a, b, c = rand(10,10), rand(10,10), rand(10,1);\n\njulia> ein\"ij,jk,kl -> il\"(a,b,c) ≈ ein\"(ij,jk),kl -> il\"(a,b,c) ≈ a * b * c\ntrue\n\n\n\n\n\n","category":"macro"},{"location":"ref/#OMEinsumContractionOrders.GreedyMethod","page":"References","title":"OMEinsumContractionOrders.GreedyMethod","text":"GreedyMethod{MT}\nGreedyMethod(; method=MinSpaceOut(), nrepeat=10)\n\nThe fast but poor greedy optimizer. Input arguments are\n\nmethod is MinSpaceDiff() or MinSpaceOut.\nMinSpaceOut choose one of the contraction that produces a minimum output tensor size,\nMinSpaceDiff choose one of the contraction that decrease the space most.\nnrepeat is the number of repeatition, returns the best contraction order.\n\n\n\n\n\n","category":"type"},{"location":"ref/#OMEinsumContractionOrders.TreeSA","page":"References","title":"OMEinsumContractionOrders.TreeSA","text":"TreeSA{RT,IT,GM}\nTreeSA(; sc_target=20, βs=collect(0.01:0.05:15), ntrials=10, niters=50,\n    sc_weight=1.0, rw_weight=0.2, initializer=:greedy, greedy_config=GreedyMethod(; nrepeat=1))\n\nOptimize the einsum contraction pattern using the simulated annealing on tensor expression tree.\n\nsc_target is the target space complexity,\nntrials, βs and niters are annealing parameters, doing ntrials indepedent annealings, each has inverse tempteratures specified by βs, in each temperature, do niters updates of the tree.\nsc_weight is the relative importance factor of space complexity in the loss compared with the time complexity.\nrw_weight is the relative importance factor of memory read and write in the loss compared with the time complexity.\ninitializer specifies how to determine the initial configuration, it can be :greedy or :random. If it is using :greedy method to generate the initial configuration, it also uses two extra arguments greedy_method and greedy_nrepeat.\nnslices is the number of sliced legs, default is 0.\n\nReferences\n\nRecursive Multi-Tensor Contraction for XEB Verification of Quantum Circuits\n\n\n\n\n\n","category":"type"},{"location":"ref/#OMEinsumContractionOrders.SABipartite","page":"References","title":"OMEinsumContractionOrders.SABipartite","text":"SABipartite{RT,BT}\nSABipartite(; sc_target=25, ntrials=50, βs=0.1:0.2:15.0, niters=1000\n    max_group_size=40, greedy_config=GreedyMethod(), initializer=:random)\n\nOptimize the einsum code contraction order using the Simulated Annealing bipartition + Greedy approach. This program first recursively cuts the tensors into several groups using simulated annealing, with maximum group size specifed by max_group_size and maximum space complexity specified by sc_target, Then finds the contraction order inside each group with the greedy search algorithm. Other arguments are\n\nsize_dict, a dictionary that specifies leg dimensions,\nsc_target is the target space complexity, defined as log2(number of elements in the largest tensor),\nmax_group_size is the maximum size that allowed to used greedy search,\nβs is a list of inverse temperature 1/T,\nniters is the number of iteration in each temperature,\nntrials is the number of repetition (with different random seeds),\ngreedy_config configures the greedy method,\ninitializer, the partition configuration initializer, one can choose :random or :greedy (slow but better).\n\nReferences\n\nHyper-optimized tensor network contraction\n\n\n\n\n\n","category":"type"},{"location":"ref/#OMEinsumContractionOrders.KaHyParBipartite","page":"References","title":"OMEinsumContractionOrders.KaHyParBipartite","text":"KaHyParBipartite{RT,IT,GM}\nKaHyParBipartite(; sc_target, imbalances=collect(0.0:0.005:0.8),\n    max_group_size=40, greedy_config=GreedyMethod())\n\nOptimize the einsum code contraction order using the KaHyPar + Greedy approach. This program first recursively cuts the tensors into several groups using KaHyPar, with maximum group size specifed by max_group_size and maximum space complexity specified by sc_target, Then finds the contraction order inside each group with the greedy search algorithm. Other arguments are\n\nsc_target is the target space complexity, defined as log2(number of elements in the largest tensor),\nimbalances is a KaHyPar parameter that controls the group sizes in hierarchical bipartition,\nmax_group_size is the maximum size that allowed to used greedy search,\ngreedy_config is a greedy optimizer.\n\nReferences\n\nHyper-optimized tensor network contraction\nSimulating the Sycamore quantum supremacy circuits\n\n\n\n\n\n","category":"type"},{"location":"ref/#Others","page":"References","title":"Others","text":"","category":"section"},{"location":"ref/#Graph","page":"References","title":"Graph","text":"","category":"section"},{"location":"ref/","page":"References","title":"References","text":"show_graph\n\ndiagonal_coupled_graph\nsquare_lattice_graph\nunit_disk_graph\n\nrandom_diagonal_coupled_graph\nrandom_square_lattice_graph","category":"page"},{"location":"ref/#GraphTensorNetworks.show_graph","page":"References","title":"GraphTensorNetworks.show_graph","text":"show_graph(locations, edges;\n    colors=[\"black\", \"black\", ...],\n    texts=[\"1\", \"2\", ...],\n    format=SVG,\n    bond_color=\"black\",\n    )\n\nPlots vertices at locations with colors specified by colors and texts specified by texts. You will need a VSCode, Pluto notebook or Jupyter notebook to show the image. If you want to write this image to the disk without displaying it in a frontend, please try\n\njulia> open(\"test.png\", \"w\") do f\n            viz_atoms(f, generate_sites(SquareLattice(), 5, 5))\n       end\n\nThe format keyword argument can also be Compose.SVG or Compose.PDF.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GraphTensorNetworks.diagonal_coupled_graph","page":"References","title":"GraphTensorNetworks.diagonal_coupled_graph","text":"diagonal_coupled_graph(mask::AbstractMatrix{Bool})\n\nCreate a masked diagonal coupled square lattice graph from a specified mask.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GraphTensorNetworks.square_lattice_graph","page":"References","title":"GraphTensorNetworks.square_lattice_graph","text":"square_lattice_graph(mask::AbstractMatrix{Bool})\n\nCreate a masked square lattice graph.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GraphTensorNetworks.unit_disk_graph","page":"References","title":"GraphTensorNetworks.unit_disk_graph","text":"unit_disk_graph(locs::AbstractVector, unit::Real)\n\nCreate a unit disk graph with locations specified by locs and unit distance unit.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GraphTensorNetworks.random_diagonal_coupled_graph","page":"References","title":"GraphTensorNetworks.random_diagonal_coupled_graph","text":"random_diagonal_coupled_graph(m::Int, n::Int, ρ::Real)\n\nCreate a random masked diagonal coupled square lattice graph, with number of vertices fixed to lfloor mnrho rceil.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GraphTensorNetworks.random_square_lattice_graph","page":"References","title":"GraphTensorNetworks.random_square_lattice_graph","text":"random_square_lattice_graph(m::Int, n::Int, ρ::Real)\n\nCreate a random masked square lattice graph, with number of vertices fixed to lfloor mnrho rceil.\n\n\n\n\n\n","category":"function"},{"location":"ref/","page":"References","title":"References","text":"One can also use random_regular_graph and smallgraph in Graphs to build special graphs.","category":"page"},{"location":"ref/#Lower-level-APIs","page":"References","title":"Lower level APIs","text":"","category":"section"},{"location":"ref/","page":"References","title":"References","text":"best_solutions\nbest2_solutions\nsolutions\nall_solutions\ngraph_polynomial\nmax_size\nmax_size_count","category":"page"},{"location":"ref/#GraphTensorNetworks.best_solutions","page":"References","title":"GraphTensorNetworks.best_solutions","text":"best_solutions(problem; all=false, usecuda=false)\n\nFind optimal solutions with bounding.\n\nWhen all is true, the program will use set for enumerate all possible solutions, otherwise, it will return one solution for each size.\nusecuda can not be true if you want to use set to enumerate all possible solutions.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GraphTensorNetworks.best2_solutions","page":"References","title":"GraphTensorNetworks.best2_solutions","text":"best2_solutions(problem; all=true, usecuda=false)\n\nFinding optimal and suboptimal solutions.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GraphTensorNetworks.solutions","page":"References","title":"GraphTensorNetworks.solutions","text":"solutions(problem, basetype; all, usecuda=false)\n\nGeneral routine to find solutions without bounding,\n\nbasetype can be a type with counting field,\nCountingTropical{Float64,Float64} for finding optimal solutions,\nPolynomial{Float64, :x} for enumerating all solutions,\nMax2Poly{Float64,Float64} for optimal and suboptimal solutions.\nWhen all is true, the program will use set for enumerate all possible solutions, otherwise, it will return one solution for each size.\nusecuda can not be true if you want to use set to enumerate all possible solutions.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GraphTensorNetworks.all_solutions","page":"References","title":"GraphTensorNetworks.all_solutions","text":"all_solutions(problem)\n\nFinding all solutions grouped by size. e.g. when the problem is MaximalIndependence, it computes all maximal independent sets, or the maximal cliques of it complement.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GraphTensorNetworks.graph_polynomial","page":"References","title":"GraphTensorNetworks.graph_polynomial","text":"graph_polynomial(problem, method; usecuda=false, kwargs...)\n\nComputing the graph polynomial for specific problem.\n\nproblem can be one of the following instances,\nIndependence for the independence polynomial,\nMaximalIndependence for the maximal independence polynomial,\nMatching for the matching polynomial,\nmethod can be one of the following inputs,\nVal(:finitefield), compute exactly with the finite field method.   It consumes additional kwargs [max_iter, maxorder], where maxorder is maximum order of polynomial   and max_iter is the maximum number of primes numbers to use in the finitefield algebra.   max_iter can be determined automatically in most cases.\nVal(:polynomial), compute directly with Polynomial number type,\nVal(:fft), compute with the fast fourier transformation approach, fast but needs to tune the hyperparameter r.   It Consumes additional kwargs [maxorder, r]. The larger r is,   the more accurate the factors of high order terms, and the less accurate the factors of low order terms.\nVal(:fitting), compute with the polynomial fitting approach, fast but inaccurate for large graphs.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GraphTensorNetworks.max_size","page":"References","title":"GraphTensorNetworks.max_size","text":"max_size(problem; usecuda=false)\n\nReturns the maximum size of the graph problem.  A shorthand of solve(problem, SizeMax(); usecuda=false).\n\n\n\n\n\n","category":"function"},{"location":"ref/#GraphTensorNetworks.max_size_count","page":"References","title":"GraphTensorNetworks.max_size_count","text":"max_size_count(problem; usecuda=false)\n\nReturns the maximum size and the counting of the graph problem. It is a shorthand of solve(problem, CountingMax(); usecuda=false).\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = GraphTensorNetworks","category":"page"},{"location":"#GraphTensorNetworks","page":"Home","title":"GraphTensorNetworks","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package uses generic tensor network to compute properties of combinatorial problems defined on graph. The properties includes the size of the maximum set size, the number of sets of a given size and the enumeration of configurations of a given set size.","category":"page"},{"location":"#Background-knowledge","page":"Home","title":"Background knowledge","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Please check our paper \"Computing properties of independent sets by generic programming tensor networks\". If you find our paper or software useful in your work, please cite us:","category":"page"},{"location":"","page":"Home","title":"Home","text":"(bibtex to be added)","category":"page"},{"location":"#Quick-start","page":"Home","title":"Quick start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"You can find a good installation guide and a quick start in our README.","category":"page"},{"location":"","page":"Home","title":"Home","text":"A good example to start with is the Independent set problem.","category":"page"},{"location":"tutorials/Independence/","page":"Independent set problem","title":"Independent set problem","text":"EditURL = \"https://github.com/Happy-Diode/GraphTensorNetworks.jl/blob/master/examples/Independence/main.jl\"","category":"page"},{"location":"tutorials/Independence/#Independent-set-problem","page":"Independent set problem","title":"Independent set problem","text":"","category":"section"},{"location":"tutorials/Independence/#Introduction","page":"Independent set problem","title":"Introduction","text":"","category":"section"},{"location":"tutorials/Independence/","page":"Independent set problem","title":"Independent set problem","text":"using GraphTensorNetworks, Graphs","category":"page"},{"location":"tutorials/Independence/","page":"Independent set problem","title":"Independent set problem","text":"Please check the docstring of Independence for the definition of independence problem.","category":"page"},{"location":"tutorials/Independence/","page":"Independent set problem","title":"Independent set problem","text":"@doc Independence","category":"page"},{"location":"tutorials/Independence/","page":"Independent set problem","title":"Independent set problem","text":"In the following, we are going to defined an independent set problem for the Petersen graph.","category":"page"},{"location":"tutorials/Independence/","page":"Independent set problem","title":"Independent set problem","text":"graph = Graphs.smallgraph(:petersen)","category":"page"},{"location":"tutorials/Independence/","page":"Independent set problem","title":"Independent set problem","text":"We can visualize this graph using the following function","category":"page"},{"location":"tutorials/Independence/","page":"Independent set problem","title":"Independent set problem","text":"rot15(a, b, i::Int) = cos(2i*π/5)*a + sin(2i*π/5)*b, cos(2i*π/5)*b - sin(2i*π/5)*a\n\nlocations = [[rot15(0.0, 1.0, i) for i=0:4]..., [rot15(0.0, 0.6, i) for i=0:4]...]\n\nshow_graph(graph; locs=locations)","category":"page"},{"location":"tutorials/Independence/","page":"Independent set problem","title":"Independent set problem","text":"Let us contruct the problem instance with optimized tensor network contraction order as bellow.","category":"page"},{"location":"tutorials/Independence/","page":"Independent set problem","title":"Independent set problem","text":"problem = Independence(graph; optimizer=TreeSA(sc_weight=1.0, ntrials=10,\n                         βs=0.01:0.1:15.0, niters=20, rw_weight=0.2),\n                         simplifier=MergeGreedy());\nnothing #hide","category":"page"},{"location":"tutorials/Independence/","page":"Independent set problem","title":"Independent set problem","text":"The optimizer is for optimizing the contraction orders. Here we use the local search based optimizer in arXiv:2108.05665. If no optimizer is specified, the default fast (in terms of the speed of searching contraction order) but worst (in term of contraction complexity) GreedyMethod will be used. simplifier is a preprocessing routine to speed up the optimizer. Please check section Tensor Network for more details. One can check the time, space and read-write complexity with the following function.","category":"page"},{"location":"tutorials/Independence/","page":"Independent set problem","title":"Independent set problem","text":"timespacereadwrite_complexity(problem)","category":"page"},{"location":"tutorials/Independence/","page":"Independent set problem","title":"Independent set problem","text":"The return values are log2 of the the number of iterations, the number elements in the max tensor and the number of read-write operations to tensor elements.","category":"page"},{"location":"tutorials/Independence/#Solving-properties","page":"Independent set problem","title":"Solving properties","text":"","category":"section"},{"location":"tutorials/Independence/#Maximum-independent-set-size-\\alpha(G)","page":"Independent set problem","title":"Maximum independent set size alpha(G)","text":"","category":"section"},{"location":"tutorials/Independence/","page":"Independent set problem","title":"Independent set problem","text":"maximum_independent_set_size = solve(problem, SizeMax())[]","category":"page"},{"location":"tutorials/Independence/#Counting-properties","page":"Independent set problem","title":"Counting properties","text":"","category":"section"},{"location":"tutorials/Independence/#counting-all-independent-sets","page":"Independent set problem","title":"counting all independent sets","text":"","category":"section"},{"location":"tutorials/Independence/","page":"Independent set problem","title":"Independent set problem","text":"count_all_independent_sets = solve(problem, CountingAll())[]","category":"page"},{"location":"tutorials/Independence/#counting-independent-sets-with-sizes-\\alpha(G)-and-\\alpha(G)-1","page":"Independent set problem","title":"counting independent sets with sizes alpha(G) and alpha(G)-1","text":"","category":"section"},{"location":"tutorials/Independence/","page":"Independent set problem","title":"Independent set problem","text":"count_max2_independent_sets = solve(problem, CountingMax(2))[]","category":"page"},{"location":"tutorials/Independence/#independence-polynomial","page":"Independent set problem","title":"independence polynomial","text":"","category":"section"},{"location":"tutorials/Independence/","page":"Independent set problem","title":"Independent set problem","text":"For the definition of independence polynomial, please check the docstring of Independence or this wiki page. There are 3 methods to compute a graph polynomial, :finitefield, :fft and :polynomial. These methods are introduced in the docstring of GraphPolynomial.","category":"page"},{"location":"tutorials/Independence/","page":"Independent set problem","title":"Independent set problem","text":"independence_polynomial = solve(problem, GraphPolynomial(; method=:finitefield))[]","category":"page"},{"location":"tutorials/Independence/#Configuration-properties","page":"Independent set problem","title":"Configuration properties","text":"","category":"section"},{"location":"tutorials/Independence/#finding-one-maximum-independent-set-(MIS)","page":"Independent set problem","title":"finding one maximum independent set (MIS)","text":"","category":"section"},{"location":"tutorials/Independence/","page":"Independent set problem","title":"Independent set problem","text":"There are two approaches to find one of the best solution. The unbounded (default) version uses ConfigSampler to sample one of the best solutions directly. The bounded version uses the binary gradient back-propagation (see our paper) to compute the gradients. It requires caching intermediate states, but is often faster on CPU because it can use TropicalGEMM.","category":"page"},{"location":"tutorials/Independence/","page":"Independent set problem","title":"Independent set problem","text":"max_config = solve(problem, SingleConfigMax(; bounded=false))[]","category":"page"},{"location":"tutorials/Independence/","page":"Independent set problem","title":"Independent set problem","text":"The return value contains a bit string, and one should read this bit string from left to right. Having value 1 at i-th bit means vertex i is in the maximum independent set. One can visualize this MIS with the following function.","category":"page"},{"location":"tutorials/Independence/","page":"Independent set problem","title":"Independent set problem","text":"show_graph(graph; locs=locations, colors=[iszero(max_config.c.data[i]) ? \"white\" : \"red\"\n                                 for i=1:nv(graph)])","category":"page"},{"location":"tutorials/Independence/#enumeration-of-all-MISs","page":"Independent set problem","title":"enumeration of all MISs","text":"","category":"section"},{"location":"tutorials/Independence/","page":"Independent set problem","title":"Independent set problem","text":"There are two approaches to enumerate all best-K solutions. The bounded (default) version is always prefered because it can significantly use the memory usage.","category":"page"},{"location":"tutorials/Independence/","page":"Independent set problem","title":"Independent set problem","text":"all_max_configs = solve(problem, ConfigsMax(1; bounded=true))[]\n\nusing Compose\n\nm = length(all_max_configs.c)\n\nimgs = ntuple(k->(context((k-1)/m, 0.0, 1.2/m, 1.0), show_graph(graph;\n                            locs=locations, scale=0.25,\n                            colors=[iszero(all_max_configs.c[k][i]) ? \"white\" : \"red\"\n                                 for i=1:nv(graph)])), m)\n\nCompose.set_default_graphic_size(18cm, 4cm); Compose.compose(context(), imgs...)","category":"page"},{"location":"tutorials/Independence/#enumeration-of-all-IS-configurations","page":"Independent set problem","title":"enumeration of all IS configurations","text":"","category":"section"},{"location":"tutorials/Independence/","page":"Independent set problem","title":"Independent set problem","text":"all_independent_sets = solve(problem, ConfigsAll())[]","category":"page"},{"location":"tutorials/Independence/","page":"Independent set problem","title":"Independent set problem","text":"To save/read a set of configuration to disk, one can type the following","category":"page"},{"location":"tutorials/Independence/","page":"Independent set problem","title":"Independent set problem","text":"filename = tempname()\n\nsave_configs(filename, all_independent_sets; format=:binary)\n\nloaded_sets = load_configs(filename; format=:binary, bitlength=10)","category":"page"},{"location":"tutorials/Independence/","page":"Independent set problem","title":"Independent set problem","text":"note: Note\nWhen loading data, one needs to provide the bitlength if the data is saved in binary format. Because the bitstring length is not stored.","category":"page"},{"location":"tutorials/Independence/#Weights-and-open-vertices","page":"Independent set problem","title":"Weights and open vertices","text":"","category":"section"},{"location":"tutorials/Independence/","page":"Independent set problem","title":"Independent set problem","text":"[Independence] accepts weights as a key word argument. The following code computes the weighted MIS problem.","category":"page"},{"location":"tutorials/Independence/","page":"Independent set problem","title":"Independent set problem","text":"problem = Independence(graph; weights=collect(1:10))\n\nmax_config_weighted = solve(problem, SingleConfigMax())[]\n\nshow_graph(graph; locs=locations, colors=\n          [iszero(max_config_weighted.c.data[i]) ? \"white\" : \"red\" for i=1:nv(graph)])","category":"page"},{"location":"tutorials/Independence/","page":"Independent set problem","title":"Independent set problem","text":"The following code computes the MIS tropical tensor (reference to be added) with open vertices 1 and 2.","category":"page"},{"location":"tutorials/Independence/","page":"Independent set problem","title":"Independent set problem","text":"problem = Independence(graph; openvertices=[1,2,3])\n\nmis_tropical_tensor = solve(problem, SizeMax())","category":"page"},{"location":"tutorials/Independence/","page":"Independent set problem","title":"Independent set problem","text":"The MIS tropical tensor shows the MIS size under different configuration of open vertices. It is useful in MIS tropical tensor analysis. One can compatify this MIS-Tropical tensor by typing","category":"page"},{"location":"tutorials/Independence/","page":"Independent set problem","title":"Independent set problem","text":"mis_compactify!(mis_tropical_tensor)","category":"page"},{"location":"tutorials/Independence/","page":"Independent set problem","title":"Independent set problem","text":"It will eliminate some entries having no contribution to the MIS size when embeding this local graph into a larger one.","category":"page"},{"location":"tutorials/Independence/","page":"Independent set problem","title":"Independent set problem","text":"","category":"page"},{"location":"tutorials/Independence/","page":"Independent set problem","title":"Independent set problem","text":"This page was generated using Literate.jl.","category":"page"}]
}
