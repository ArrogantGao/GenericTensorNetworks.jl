var documenterSearchIndex = {"docs":
[{"location":"tutorials/MaxCut/","page":"Max-Cut Problem","title":"Max-Cut Problem","text":"EditURL = \"https://github.com/Happy-Diode/GraphTensorNetworks.jl/blob/master/examples/MaxCut/main.jl\"","category":"page"},{"location":"tutorials/MaxCut/#Max-Cut-problem","page":"Max-Cut Problem","title":"Max-Cut problem","text":"","category":"section"},{"location":"tutorials/MaxCut/#Problem-definition","page":"Max-Cut Problem","title":"Problem definition","text":"","category":"section"},{"location":"tutorials/MaxCut/#Solving-properties","page":"Max-Cut Problem","title":"Solving properties","text":"","category":"section"},{"location":"tutorials/MaxCut/","page":"Max-Cut Problem","title":"Max-Cut Problem","text":"using GraphTensorNetworks, Graphs","category":"page"},{"location":"tutorials/MaxCut/","page":"Max-Cut Problem","title":"Max-Cut Problem","text":"","category":"page"},{"location":"tutorials/MaxCut/","page":"Max-Cut Problem","title":"Max-Cut Problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"methodselection/","page":"Method Selection Guide","title":"Method Selection Guide","text":"CurrentModule = GraphTensorNetworks","category":"page"},{"location":"methodselection/#Method-Selection-Guide","page":"Method Selection Guide","title":"Method Selection Guide","text":"","category":"section"},{"location":"methodselection/#Tensor-network-contraction-tree-optimizer","page":"Method Selection Guide","title":"Tensor network contraction tree optimizer","text":"","category":"section"},{"location":"methodselection/#Independence-polynomial","page":"Method Selection Guide","title":"Independence polynomial","text":"","category":"section"},{"location":"methodselection/#Configuration-enumeration","page":"Method Selection Guide","title":"Configuration enumeration","text":"","category":"section"},{"location":"tutorials/IndependentSet/","page":"Independent Set Problem","title":"Independent Set Problem","text":"EditURL = \"https://github.com/Happy-Diode/GraphTensorNetworks.jl/blob/master/examples/IndependentSet/main.jl\"","category":"page"},{"location":"tutorials/IndependentSet/#Independent-set-problem","page":"Independent Set Problem","title":"Independent set problem","text":"","category":"section"},{"location":"tutorials/IndependentSet/#Problem-definition","page":"Independent Set Problem","title":"Problem definition","text":"","category":"section"},{"location":"tutorials/IndependentSet/","page":"Independent Set Problem","title":"Independent Set Problem","text":"Please check the docstring of Independence for the definition of independence problem. In the following, we are going to defined an independent set problem for the Petersen graph.","category":"page"},{"location":"tutorials/IndependentSet/","page":"Independent Set Problem","title":"Independent Set Problem","text":"using GraphTensorNetworks, Graphs\n\ngraph = Graphs.smallgraph(:petersen)","category":"page"},{"location":"tutorials/IndependentSet/","page":"Independent Set Problem","title":"Independent Set Problem","text":"We can visualize this graph using the following function","category":"page"},{"location":"tutorials/IndependentSet/","page":"Independent Set Problem","title":"Independent Set Problem","text":"rot15(a, b, i::Int) = cos(2i*π/5)*a + sin(2i*π/5)*b, cos(2i*π/5)*b - sin(2i*π/5)*a\n\nlocations = [[rot15(0.0, 1.0, i) for i=0:4]..., [rot15(0.0, 0.6, i) for i=0:4]...]\n\nshow_graph(graph; locs=locations)","category":"page"},{"location":"tutorials/IndependentSet/","page":"Independent Set Problem","title":"Independent Set Problem","text":"Let us contruct the problem instance with optimized tensor network contraction order as bellow.","category":"page"},{"location":"tutorials/IndependentSet/","page":"Independent Set Problem","title":"Independent Set Problem","text":"problem = Independence(graph; optimizer=TreeSA(sc_weight=1.0, ntrials=10,\n                         βs=0.01:0.1:15.0, niters=20, rw_weight=0.2));\nnothing #hide","category":"page"},{"location":"tutorials/IndependentSet/#Solving-properties","page":"Independent Set Problem","title":"Solving properties","text":"","category":"section"},{"location":"tutorials/IndependentSet/#The-decision-problem","page":"Independent Set Problem","title":"The decision problem","text":"","category":"section"},{"location":"tutorials/IndependentSet/#maximum-independent-set-size-\\alpha(G)","page":"Independent Set Problem","title":"maximum independent set size alpha(G)","text":"","category":"section"},{"location":"tutorials/IndependentSet/","page":"Independent Set Problem","title":"Independent Set Problem","text":"maximum_independent_set_size = solve(problem, SizeMax())","category":"page"},{"location":"tutorials/IndependentSet/#Counting-properties","page":"Independent Set Problem","title":"Counting properties","text":"","category":"section"},{"location":"tutorials/IndependentSet/#counting-all-independent-sets","page":"Independent Set Problem","title":"counting all independent sets","text":"","category":"section"},{"location":"tutorials/IndependentSet/","page":"Independent Set Problem","title":"Independent Set Problem","text":"count_all_independent_sets = solve(problem, CountingAll())","category":"page"},{"location":"tutorials/IndependentSet/#counting-independent-sets-with-sizes-\\alpha(G)-and-\\alpha(G)-1","page":"Independent Set Problem","title":"counting independent sets with sizes alpha(G) and alpha(G)-1","text":"","category":"section"},{"location":"tutorials/IndependentSet/","page":"Independent Set Problem","title":"Independent Set Problem","text":"count_max2_independent_sets = solve(problem, CountingMax(2))","category":"page"},{"location":"tutorials/IndependentSet/#computing-the-independence-polynomial","page":"Independent Set Problem","title":"computing the independence polynomial","text":"","category":"section"},{"location":"tutorials/IndependentSet/","page":"Independent Set Problem","title":"Independent Set Problem","text":"For the definition of independence polynomial, please check the docstring of Independence or this wiki page.","category":"page"},{"location":"tutorials/IndependentSet/","page":"Independent Set Problem","title":"Independent Set Problem","text":"independence_polynomial = solve(problem, GraphPolynomial(; method=:finitefield))","category":"page"},{"location":"tutorials/IndependentSet/#Configuration-properties","page":"Independent Set Problem","title":"Configuration properties","text":"","category":"section"},{"location":"tutorials/IndependentSet/#finding-one-maximum-independent-set-(MIS)","page":"Independent Set Problem","title":"finding one maximum independent set (MIS)","text":"","category":"section"},{"location":"tutorials/IndependentSet/","page":"Independent Set Problem","title":"Independent Set Problem","text":"max_config = solve(problem, SingleConfigMax(; bounded=false))[]","category":"page"},{"location":"tutorials/IndependentSet/","page":"Independent Set Problem","title":"Independent Set Problem","text":"The return value contains a bit string, and one should read this bit string from left to right. Having value 1 at i-th bit means vertex i is in the maximum independent set. One can visualize this MIS with the following function.","category":"page"},{"location":"tutorials/IndependentSet/","page":"Independent Set Problem","title":"Independent Set Problem","text":"show_graph(graph; locs=locations, colors=[iszero(max_config.c.data[i]) ? \"white\" : \"red\"\n                                 for i=1:nv(graph)])","category":"page"},{"location":"tutorials/IndependentSet/#enumeration-of-all-MISs","page":"Independent Set Problem","title":"enumeration of all MISs","text":"","category":"section"},{"location":"tutorials/IndependentSet/","page":"Independent Set Problem","title":"Independent Set Problem","text":"all_max_configs = solve(problem, ConfigsMax(; bounded=true))[]\n\nusing Compose\n\nm = length(all_max_configs.c)\n\nimgs = ntuple(k->(context((k-1)/m, 0.0, 1.2/m, 1.0), show_graph(graph;\n                            locs=locations, scale=0.25,\n                            colors=[iszero(all_max_configs.c[k][i]) ? \"white\" : \"red\"\n                                 for i=1:nv(graph)])), m)\n\nCompose.set_default_graphic_size(18cm, 4cm); Compose.compose(context(), imgs...)","category":"page"},{"location":"tutorials/IndependentSet/#enumeration-of-all-IS-configurations","page":"Independent Set Problem","title":"enumeration of all IS configurations","text":"","category":"section"},{"location":"tutorials/IndependentSet/","page":"Independent Set Problem","title":"Independent Set Problem","text":"all_independent_sets = solve(problem, ConfigsAll())[]","category":"page"},{"location":"tutorials/IndependentSet/","page":"Independent Set Problem","title":"Independent Set Problem","text":"","category":"page"},{"location":"tutorials/IndependentSet/","page":"Independent Set Problem","title":"Independent Set Problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/Others/","page":"Other Problems","title":"Other Problems","text":"EditURL = \"https://github.com/Happy-Diode/GraphTensorNetworks.jl/blob/master/examples/Others/main.jl\"","category":"page"},{"location":"tutorials/Others/#Other-problems-can-be-solved-by-GraphTensorNetworks","page":"Other Problems","title":"Other problems can be solved by GraphTensorNetworks","text":"","category":"section"},{"location":"tutorials/Others/#Set-packing-problem","page":"Other Problems","title":"Set packing problem","text":"","category":"section"},{"location":"tutorials/Others/","page":"Other Problems","title":"Other Problems","text":"It is a generalization of the independent set problem.","category":"page"},{"location":"tutorials/Others/#Vertex-cover-problem","page":"Other Problems","title":"Vertex cover problem","text":"","category":"section"},{"location":"tutorials/Others/","page":"Other Problems","title":"Other Problems","text":"A vertex cover is a complement of an independent set.","category":"page"},{"location":"tutorials/Others/#Maximal-clique-problem","page":"Other Problems","title":"Maximal clique problem","text":"","category":"section"},{"location":"tutorials/Others/","page":"Other Problems","title":"Other Problems","text":"The maximal clique of graph G is a maximal clique of G's complement graph.","category":"page"},{"location":"tutorials/Others/#Spin-glass-problem","page":"Other Problems","title":"Spin-glass problem","text":"","category":"section"},{"location":"tutorials/Others/","page":"Other Problems","title":"Other Problems","text":"It is another way of saying the Max-Cut problem.","category":"page"},{"location":"tutorials/Others/","page":"Other Problems","title":"Other Problems","text":"","category":"page"},{"location":"tutorials/Others/","page":"Other Problems","title":"Other Problems","text":"This page was generated using Literate.jl.","category":"page"},{"location":"ref/","page":"References","title":"References","text":"DocTestSetup = quote\n    import TropicalNumbers, Mods, Polynomials\nend","category":"page"},{"location":"ref/#References","page":"References","title":"References","text":"","category":"section"},{"location":"ref/","page":"References","title":"References","text":"Modules = [GraphTensorNetworks]","category":"page"},{"location":"ref/#GraphTensorNetworks.Coloring","page":"References","title":"GraphTensorNetworks.Coloring","text":"Coloring{K,CT<:EinTypes} <: GraphProblem\nColoring{K}(graph; openvertices=(), optimizer=GreedyMethod(), simplifier=nothing)\n\nK-Coloring problem. optimizer and simplifier are for tensor network optimization, check optimize_code for details.\n\n\n\n\n\n","category":"type"},{"location":"ref/#GraphTensorNetworks.ConfigEnumerator","page":"References","title":"GraphTensorNetworks.ConfigEnumerator","text":"ConfigEnumerator{N,S,C}\n\nSet algebra for enumerating configurations, where N is the length of configurations, C is the size of storage in unit of UInt64, S is the bit width to store a single element in a configuration, i.e. log2(# of flavors), for bitstrings, it is 1`.\n\njulia> a = ConfigEnumerator([StaticBitVector([1,1,1,0,0]), StaticBitVector([1,0,0,0,1])])\n{11100, 10001}\n\njulia> b = ConfigEnumerator([StaticBitVector([0,0,0,0,0]), StaticBitVector([1,0,1,0,1])])\n{00000, 10101}\n\njulia> a + b\n{11100, 10001, 00000, 10101}\n\n\n\n\n\n","category":"type"},{"location":"ref/#GraphTensorNetworks.ConfigSampler","page":"References","title":"GraphTensorNetworks.ConfigSampler","text":"ConfigSampler{N,S,C}\n\nThe algebra for sampling one configuration, where N is the length of configurations, C is the size of storage in unit of UInt64, S is the bit width to store a single element in a configuration, i.e. log2(# of flavors), for bitstrings, it is 1`.\n\njulia> ConfigSampler(StaticBitVector([1,1,1,0,0]))\nConfigSampler{5, 1, 1}(11100)\n\n\n\n\n\n","category":"type"},{"location":"ref/#GraphTensorNetworks.ConfigsAll","page":"References","title":"GraphTensorNetworks.ConfigsAll","text":"ConfigsAll <:AbstractProperty\nConfigsAll()\n\nFind all valid configurations, e.g. for Independence problem, it is finding all independent sets.\n\nThe corresponding data type is ConfigEnumerator.\nWeights do not take effect.\n\n\n\n\n\n","category":"type"},{"location":"ref/#GraphTensorNetworks.ConfigsMax","page":"References","title":"GraphTensorNetworks.ConfigsMax","text":"ConfigsMax{K, BOUNDED} <:AbstractProperty\nConfigsMax(K=1; bounded=true)\n\nFind configurations with largest sizes, e.g. for Independence problem, it is finding all independent sets of sizes alpha(G) alpha(G)-1 ldots alpha(G)-K+1.\n\nThe corresponding data type is CountingTropical{Float64,<:ConfigEnumerator} for K == 1 and TruncatedPoly{K,<:ConfigEnumerator} for K > 1.\nWeighted graph problems is only supported for K == 1.\n\n\n\n\n\n","category":"type"},{"location":"ref/#GraphTensorNetworks.CountingAll","page":"References","title":"GraphTensorNetworks.CountingAll","text":"CountingAll <: AbstractProperty\nCountingAll()\n\nCounting the total number of sets. e.g. for Independence problem, it counts the independent sets.\n\nThe corresponding tensor element type is Base.Real.\nThe weights on graph does not have effect.\nBLAS (GPU and CPU) and GPU are supported,\n\n\n\n\n\n","category":"type"},{"location":"ref/#GraphTensorNetworks.CountingMax","page":"References","title":"GraphTensorNetworks.CountingMax","text":"CountingMax{K} <: AbstractProperty\nCountingMax(K=1)\n\nCounting the number of sets with K largest size. e.g. for Independence problem, it counts independent sets of size alpha(G) alpha(G)-1 ldots alpha(G)-K+1.\n\nThe corresponding tensor element type is CountingTropical for K == 1, and TruncatedPoly{K} for K > 1.\nWeighted graph problems is only supported for K == 1.\nGPU is supported,\n\n\n\n\n\n","category":"type"},{"location":"ref/#GraphTensorNetworks.GraphPolynomial","page":"References","title":"GraphTensorNetworks.GraphPolynomial","text":"GraphPolynomial{METHOD} <: AbstractProperty\nGraphPolynomial(; method=:finitefield, kwargs...)\n\nCompute the graph polynomial, e.g. for Independence problem, it is the independence polynomial. The METHOD type parameter can be one of the following symbols\n\n:finitefield, it uses finite field algebra to fit the polynomial.\nThe corresponding tensor element type is Mods.Mod,\nIt does not have round-off error,\nGPU is supported,\nIt accepts keyword arguments maxorder (optional, e.g. the MIS size in the Independence problem).\n:polynomial, the program uses polynomial numbers to solve the polynomial directly.\nThe corresponding tensor element type is Polynomials.Polynomial.\nIt might have small round-off error depending on the data type for storing the counting.\nIt has memory overhead that linear to the graph size.\n:fft, \nThe corresponding tensor element type is Base.Complex.\nIt has (controllable) round-off error.\nBLAS and GPU are supported.\nIt accepts keyword arguments maxorder (optional) and r,   if r > 1, one has better precision for coefficients of large order, if r < 1,   one has better precision for coefficients of small order.\n\nGraph polynomials are not defined for weighted graph problems.\n\n\n\n\n\n","category":"type"},{"location":"ref/#GraphTensorNetworks.Independence","page":"References","title":"GraphTensorNetworks.Independence","text":"Independence{CT<:EinTypes,WT<:Union{UnWeighted, Vector}} <: GraphProblem\nIndependence(graph; weights=UnWeighted(), openvertices=(),\n             optimizer=GreedyMethod(), simplifier=nothing)\n\nThe Independent set problem. In the constructor, weights are the weights of vertices. openvertices specifies labels for the output tensor. optimizer and simplifier are for tensor network optimization, check optimize_code for details.\n\nAn independent set is defined in the monadic second order logic as\n\nexists x_ildotsx_Mleftbigwedge_ineq j (x_ineq x_j wedge neg textbfadj(x_i x_j))right\n\nIn tensor network representation, we define a vertex tensors on vertex i (labeled by s_i) as\n\nW(x_i)_s_i = left(beginmatrix\n    1 \n    x_i\nendmatrixright)_s_i\n\nand a bond tensor on edge (i, j) as\n\nB_s_i s_j = left(beginmatrix\n    1   1\n    1  0\nendmatrixright)_s_is_j\n\n\n\n\n\n","category":"type"},{"location":"ref/#GraphTensorNetworks.Matching","page":"References","title":"GraphTensorNetworks.Matching","text":"Matching{CT<:EinTypes} <: GraphProblem\nMatching(graph; openvertices=(), optimizer=GreedyMethod(), simplifier=nothing)\n\nVertex matching problem. optimizer and simplifier are for tensor network optimization, check optimize_code for details. The matching polynomial adopts the first definition in wiki page\n\nm_G(x) = sum_kgeq 0m_kx^k\n\nwhere m_k is the number of k-edge matchings.\n\n\n\n\n\n","category":"type"},{"location":"ref/#GraphTensorNetworks.MaxCut","page":"References","title":"GraphTensorNetworks.MaxCut","text":"MaxCut{CT<:EinTypes,WT<:Union{UnWeighted, Vector}} <: GraphProblem\nMaxCut(graph; weights=UnWeighted(), openvertices=(),\n            optimizer=GreedyMethod(), simplifier=nothing)\n\nMax cut problem (or spin glass problem). In the constructor, weights are the weights of edges. optimizer and simplifier are for tensor network optimization, check optimize_code for details.\n\n\n\n\n\n","category":"type"},{"location":"ref/#GraphTensorNetworks.MaximalIndependence","page":"References","title":"GraphTensorNetworks.MaximalIndependence","text":"MaximalIndependence{CT<:EinTypes,WT<:Union{UnWeighted, Vector}} <: GraphProblem\nMaximalIndependence(graph; weights=UnWeighted(), openvertices=(),\n             optimizer=GreedyMethod(), simplifier=nothing)\n\nMaximal independent set problem. In the constructor, weights are the weights of vertices. optimizer and simplifier are for tensor network optimization, check optimize_code for details.\n\n\n\n\n\n","category":"type"},{"location":"ref/#GraphTensorNetworks.PaintShop","page":"References","title":"GraphTensorNetworks.PaintShop","text":"PaintShop{CT<:EinTypes} <: GraphProblem\nPaintShop(labels::AbstractVector; openvertices=(),\n         optimizer=GreedyMethod(), simplifier=nothing)\n\nThe binary paint shop problem.\n\nExample\n\nOne can encode the paint shop problem abaccb as the following\n\njulia> symbols = collect(\"abaccb\");\n\njulia> pb = PaintShop(symbols);\n\njulia> solve(pb, SizeMax())[]\n3.0ₜ\n\njulia> solve(pb, ConfigsMax())[].c.data\n2-element Vector{StaticBitVector{5, 1}}:\n 01101\n 01101\n\nIn our definition, we find the maximum number of unchanged color in this sequence, i.e. (n-1) - (minimum number of color changes) In the output of maximum configurations, the two configurations are defined on 5 bonds i.e. pairs of (i, i+1), 0 means color changed, while 1 means color not changed. If we denote two \"colors\" as r and b, then the optimal painting is rbbbrr or brrrbb, both change the colors twice.\n\n\n\n\n\n","category":"type"},{"location":"ref/#GraphTensorNetworks.SingleConfigMax","page":"References","title":"GraphTensorNetworks.SingleConfigMax","text":"SingleConfigMax{BOUNDED} <: AbstractProperty\nSingleConfigMax(; bounded=false)\n\nFinding single best solution, e.g. for Independence problem, it is one of the maximum independent sets.\n\nThe corresponding data type is CountingTropical{Float64,<:ConfigSampler} if BOUNDED is true, Tropical otherwise.\nWeighted graph problems is supported.\nGPU is supported,\n\n\n\n\n\n","category":"type"},{"location":"ref/#GraphTensorNetworks.SizeMax","page":"References","title":"GraphTensorNetworks.SizeMax","text":"SizeMax <: AbstractProperty\nSizeMax()\n\nThe maximum independent set size.\n\nThe corresponding tensor element type is Tropical.\nIt is compatible with weighted graph problems.\nBLAS (on CPU) and GPU are supported,\n\n\n\n\n\n","category":"type"},{"location":"ref/#GraphTensorNetworks.StaticElementVector","page":"References","title":"GraphTensorNetworks.StaticElementVector","text":"StaticElementVector{N,S,C}\n\nN is the length of vector, C is the size of storage in unit of UInt64, S is the stride defined as the log2(# of flavors). When the number of flavors is 2, it is a StaticBitVector.\n\n\n\n\n\n","category":"type"},{"location":"ref/#GraphTensorNetworks.TruncatedPoly","page":"References","title":"GraphTensorNetworks.TruncatedPoly","text":"TruncatedPoly{K,T,TO} <: Number\n\nPolynomial truncated to largest K orders. T is the coefficients type and TO is the orders type.\n\njulia> TruncatedPoly((1,2,3), 6)\nx^4 + 2*x^5 + 3*x^6\n\n\n\n\n\n","category":"type"},{"location":"ref/#GraphTensorNetworks.all_solutions-Tuple{GraphTensorNetworks.GraphProblem}","page":"References","title":"GraphTensorNetworks.all_solutions","text":"all_solutions(problem)\n\nFinding all solutions. e.g. when the problem is MaximalIndependence, it computes all maximal independent sets, or the maximal cliques of it complement.\n\n\n\n\n\n","category":"method"},{"location":"ref/#GraphTensorNetworks.backward_tropical-Tuple{Any, Any, Tuple, Any, Any, Any, Any}","page":"References","title":"GraphTensorNetworks.backward_tropical","text":"backward_tropical(mode, ixs, xs, iy, y, ymask, size_dict)\n\nThe backward rule for tropical einsum.\n\nmode can be one of :all and :single,\nixs and xs are labels and tensor data for input tensors,\niy and y are labels and tensor data for the output tensor,\nymask is the boolean mask for gradients,\nsize_dict is a key-value map from tensor label to dimension size.\n\n\n\n\n\n","category":"method"},{"location":"ref/#GraphTensorNetworks.best2_solutions-Tuple{GraphTensorNetworks.GraphProblem}","page":"References","title":"GraphTensorNetworks.best2_solutions","text":"best2_solutions(problem; all=true, usecuda=false)\n\nFinding optimal and suboptimal solutions.\n\n\n\n\n\n","category":"method"},{"location":"ref/#GraphTensorNetworks.best_solutions-Tuple{GraphTensorNetworks.GraphProblem}","page":"References","title":"GraphTensorNetworks.best_solutions","text":"best_solutions(problem; all=false, usecuda=false)\n\nFind optimal solutions with bounding.\n\nWhen all is true, the program will use set for enumerate all possible solutions, otherwise, it will return one solution for each size.\nusecuda can not be true if you want to use set to enumerate all possible solutions.\n\n\n\n\n\n","category":"method"},{"location":"ref/#GraphTensorNetworks.bounding_contract-Tuple{AllConfigs, OMEinsum.EinCode, Any, Any, Any}","page":"References","title":"GraphTensorNetworks.bounding_contract","text":"bounding_contract(mode, code, xsa, ymask, xsb; size_info=nothing)\n\nContraction method with bounding.\n\nmode is a AllConfigs{K} instance, where MIS-K+1 is the largest IS size that you care about.\nxsa are input tensors for bounding, e.g. tropical tensors,\nxsb are input tensors for computing, e.g. tensors elements are counting tropical with set algebra,\nymask is the initial gradient mask for the output tensor.\n\n\n\n\n\n","category":"method"},{"location":"ref/#GraphTensorNetworks.graph_polynomial","page":"References","title":"GraphTensorNetworks.graph_polynomial","text":"graph_polynomial(problem, method; usecuda=false, kwargs...)\n\nComputing the graph polynomial for specific problem.\n\nproblem can be one of the following instances,\nIndependence for the independence polynomial,\nMaximalIndependence for the maximal independence polynomial,\nMatching for the matching polynomial,\nmethod can be one of the following inputs,\nVal(:finitefield), compute exactly with the finite field method.   It consumes additional kwargs [max_iter, maxorder], where maxorder is maximum order of polynomial   and max_iter is the maximum number of primes numbers to use in the finitefield algebra.   max_iter can be determined automatically in most cases.\nVal(:polynomial), compute directly with Polynomial number type,\nVal(:fft), compute with the fast fourier transformation approach, fast but needs to tune the hyperparameter r.   It Consumes additional kwargs [maxorder, r]. The larger r is,   the more accurate the factors of high order terms, and the less accurate the factors of low order terms.\nVal(:fitting), compute with the polynomial fitting approach, fast but inaccurate for large graphs.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GraphTensorNetworks.labels-Tuple{Union{OMEinsum.EinCode, OMEinsum.NestedEinsum, OMEinsumContractionOrders.SlicedEinsum}}","page":"References","title":"GraphTensorNetworks.labels","text":"labels(code)\n\nReturn a vector of unique labels in an Einsum token.\n\n\n\n\n\n","category":"method"},{"location":"ref/#GraphTensorNetworks.load_configs-Tuple{Any}","page":"References","title":"GraphTensorNetworks.load_configs","text":"load_configs(filename; format=:binary, bitlength=nothing, nflavors=2)\n\nLoad configurations from file filename. The format is :binary or :text. If the format is :binary, the bitstring length bitlength must be specified, nflavors specifies the degree of freedom.\n\n\n\n\n\n","category":"method"},{"location":"ref/#GraphTensorNetworks.mis_compactify!-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T<:(TropicalNumbers.TropicalTypes)","page":"References","title":"GraphTensorNetworks.mis_compactify!","text":"mis_compactify!(tropicaltensor)\n\nCompactify tropical tensor for maximum independent set problem. It will eliminate some entries by setting them to zero, by the criteria that even these entries are removed, the MIS size is not changed.\n\n\n\n\n\n","category":"method"},{"location":"ref/#GraphTensorNetworks.save_configs-Union{Tuple{C}, Tuple{S}, Tuple{N}, Tuple{Any, ConfigEnumerator{N, S, C}}} where {N, S, C}","page":"References","title":"GraphTensorNetworks.save_configs","text":"save_configs(filename, data::ConfigEnumerator; format=:binary)\n\nSave configurations data to file filename. The format is :binary or :text.\n\n\n\n\n\n","category":"method"},{"location":"ref/#GraphTensorNetworks.set_packing-Tuple{Any}","page":"References","title":"GraphTensorNetworks.set_packing","text":"set_packing(sets; openvertices=(), optimizer=GreedyMethod(), simplifier=nothing)\n\nSet packing is a generalization of independent set problem to hypergraphs. Calling this function will return you an Independence instance. sets are a vector of vectors, each element being a vertex in the independent set problem. optimizer and simplifier are for tensor network optimization, check optimize_code for details.\n\nExample\n\njulia> sets = [[1, 2, 5], [1, 3], [2, 4], [3, 6], [2, 3, 6]];  # each set is a vertex\n\njulia> gp = set_packing(sets);\n\njulia> res = best_solutions(gp; all=true)[]\n(2, {10010, 00110, 01100})ₜ\n\n\n\n\n\n","category":"method"},{"location":"ref/#GraphTensorNetworks.show_graph-Tuple{Any, Any}","page":"References","title":"GraphTensorNetworks.show_graph","text":"show_graph(locations, edges;\n    colors=[\"black\", \"black\", ...],\n    texts=[\"1\", \"2\", ...],\n    format=SVG,\n    bond_color=\"black\",\n    )\n\nPlots vertices at locations with colors specified by colors and texts specified by texts. You will need a VSCode, Pluto notebook or Jupyter notebook to show the image. If you want to write this image to the disk without displaying it in a frontend, please try\n\njulia> open(\"test.png\", \"w\") do f\n            viz_atoms(f, generate_sites(SquareLattice(), 5, 5))\n       end\n\nThe format keyword argument can also be Compose.SVG or Compose.PDF.\n\n\n\n\n\n","category":"method"},{"location":"ref/#GraphTensorNetworks.solutions-Union{Tuple{BT}, Tuple{GraphTensorNetworks.GraphProblem, Type{BT}}} where BT","page":"References","title":"GraphTensorNetworks.solutions","text":"solutions(problem, basetype; all, usecuda=false)\n\nGeneral routine to find solutions without bounding,\n\nbasetype can be a type with counting field,\nCountingTropical{Float64,Float64} for finding optimal solutions,\nPolynomial{Float64, :x} for enumerating all solutions,\nMax2Poly{Float64,Float64} for optimal and suboptimal solutions.\nWhen all is true, the program will use set for enumerate all possible solutions, otherwise, it will return one solution for each size.\nusecuda can not be true if you want to use set to enumerate all possible solutions.\n\n\n\n\n\n","category":"method"},{"location":"ref/#GraphTensorNetworks.solve-Tuple{GraphTensorNetworks.GraphProblem, GraphTensorNetworks.AbstractProperty}","page":"References","title":"GraphTensorNetworks.solve","text":"solve(problem, property; usecuda=false, T=Float64)\n\nSolving a certain property of a graph problem.\n\nPositional Arguments\n\nproblem is the graph problem with tensor network information,\nproperty is string specifying the task. Using the maximum independent set problem as an example, it can be one of\nSizeMax for finding maximum configuration size,\nCountingMax for counting configurations with top K sizes,\nCountingAll for counting all configurations,\nGraphPolynomial for evaluating the graph polynomial,\nSingleConfigMax for finding one maximum configuration,\nConfigsMax for enumerating configurations with top K sizes,\nConfigsAll for enumerating all configurations,\n\nKeyword arguments\n\nusecuda is a switch to use CUDA (if possible), user need to call statement using CUDA before turning on this switch.\nT is the \"base\" element type, sometimes can be used to reduce the memory cost.\n\n\n\n\n\n","category":"method"},{"location":"ref/#GraphTensorNetworks.@bv_str-Tuple{Any}","page":"References","title":"GraphTensorNetworks.@bv_str","text":"Constructing a static bit vector.\n\n\n\n\n\n","category":"macro"},{"location":"ref/","page":"References","title":"References","text":"TropicalNumbers.Tropical","category":"page"},{"location":"ref/#TropicalNumbers.Tropical","page":"References","title":"TropicalNumbers.Tropical","text":"Tropical{T} <: Number\n\nTropical number is a semiring algebra that maps\n\n+ in regular algebra to max,\n* in regular algebra to +,\n1 in regular algebra to 0,\n0 in regular algebra to -Inf (for integer content types, this is chosen as a mall integer).\n\nWe implemented fast tropical matrix multiplication in TropicalGEMM.\n\n\n\n\n\n","category":"type"},{"location":"ref/","page":"References","title":"References","text":"TropicalNumbers.CountingTropical","category":"page"},{"location":"ref/#TropicalNumbers.CountingTropical","page":"References","title":"TropicalNumbers.CountingTropical","text":"CountingTropical{T,CT} <: Number\n\nCounting tropical number type is also a semiring algebra. It is tropical algebra with one extra field for counting, it is introduced in arXiv:2008.06888.\n\n\n\n\n\n","category":"type"},{"location":"ref/","page":"References","title":"References","text":"Mods.Mod","category":"page"},{"location":"ref/#Mods.Mod","page":"References","title":"Mods.Mod","text":"Mod{m}(v) creates a modular number in mod m with value mod(v,m).\n\n\n\n\n\n","category":"type"},{"location":"ref/","page":"References","title":"References","text":"Polynomials.Polynomial","category":"page"},{"location":"ref/#Polynomials.Polynomial","page":"References","title":"Polynomials.Polynomial","text":"Polynomial{T, X}(coeffs::AbstractVector{T}, [var = :x])\n\nConstruct a polynomial from its coefficients coeffs, lowest order first, optionally in terms of the given variable var which may be a character, symbol, or a string.\n\nIf p = a_n x^n + ldots + a_2 x^2 + a_1 x + a_0, we construct this through Polynomial([a_0, a_1, ..., a_n]).\n\nThe usual arithmetic operators are overloaded to work with polynomials as well as with combinations of polynomials and scalars. However, operations involving two polynomials of different variables causes an error except those involving a constant polynomial.\n\nnote: Note\nPolynomial is not axis-aware, and it treats coeffs simply as a list of coefficients with the first index always corresponding to the constant term. In order to use the axis of coeffs as exponents, consider using a LaurentPolynomial or possibly a SparsePolynomial.\n\nExamples\n\njulia> using Polynomials\n\njulia> Polynomial([1, 0, 3, 4])\nPolynomial(1 + 3*x^2 + 4*x^3)\n\njulia> Polynomial([1, 2, 3], :s)\nPolynomial(1 + 2*s + 3*s^2)\n\njulia> one(Polynomial)\nPolynomial(1.0)\n\n\n\n\n\n","category":"type"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = GraphTensorNetworks","category":"page"},{"location":"#GraphTensorNetworks","page":"Home","title":"GraphTensorNetworks","text":"","category":"section"},{"location":"#Background-knowledge","page":"Home","title":"Background knowledge","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Please check our paper \"Computing properties of independent sets by generic programming tensor networks\". If you find our paper or software useful in your work, please cite us.","category":"page"},{"location":"#Quick-start","page":"Home","title":"Quick start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"You can find a good installation guide and a quick start in our README.","category":"page"}]
}
