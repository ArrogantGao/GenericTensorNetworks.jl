<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Independent set problem · GenericTensorNetworks.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://QuEraComputing.github.io/GenericTensorNetworks.jl/generated/IndependentSet/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/indigo.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">GenericTensorNetworks.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Problems</span><ul><li class="is-active"><a class="tocitem" href>Independent set problem</a><ul class="internal"><li><a class="tocitem" href="#Problem-definition"><span>Problem definition</span></a></li><li><a class="tocitem" href="#Generic-tensor-network-representation"><span>Generic tensor network representation</span></a></li><li><a class="tocitem" href="#Solution-space-properties"><span>Solution space properties</span></a></li></ul></li><li><a class="tocitem" href="../MaximalIS/">Maximal independent set problem</a></li><li><a class="tocitem" href="../MaxCut/">Cutting problem</a></li><li><a class="tocitem" href="../Matching/">Vertex Matching problem</a></li><li><a class="tocitem" href="../PaintShop/">Binary paint shop problem</a></li><li><a class="tocitem" href="../Coloring/">Coloring problem</a></li><li><a class="tocitem" href="../DominatingSet/">Dominating set problem</a></li><li><a class="tocitem" href="../Satisfiability/">Satisfiability problem</a></li><li><a class="tocitem" href="../SetCovering/">Set covering problem</a></li><li><a class="tocitem" href="../SetPacking/">Set packing problem</a></li></ul></li><li><span class="tocitem">Topics</span><ul><li><a class="tocitem" href="../../gist/">Gist</a></li><li><a class="tocitem" href="../saveload/">Save and load solutions</a></li><li><a class="tocitem" href="../../sumproduct/">Sum product tree representation</a></li><li><a class="tocitem" href="../weighted/">Weighted problems</a></li><li><a class="tocitem" href="../open/">Open and fixed degrees of freedom</a></li></ul></li><li><a class="tocitem" href="../../performancetips/">Performance Tips</a></li><li><a class="tocitem" href="../../ref/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Problems</a></li><li class="is-active"><a href>Independent set problem</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Independent set problem</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/QuEraComputing/GenericTensorNetworks.jl/blob/master/examples/IndependentSet.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Independent-set-problem"><a class="docs-heading-anchor" href="#Independent-set-problem">Independent set problem</a><a id="Independent-set-problem-1"></a><a class="docs-heading-anchor-permalink" href="#Independent-set-problem" title="Permalink"></a></h1><h2 id="Problem-definition"><a class="docs-heading-anchor" href="#Problem-definition">Problem definition</a><a id="Problem-definition-1"></a><a class="docs-heading-anchor-permalink" href="#Problem-definition" title="Permalink"></a></h2><p>In graph theory, an <a href="https://en.wikipedia.org/wiki/Independent_set_(graph_theory)">independent set</a> is a set of vertices in a graph, no two of which are adjacent.</p><p>In the following, we are going to solve the solution space properties of the independent set problem on the Petersen graph. To start, let us define a Petersen graph instance.</p><pre><code class="language-julia hljs">using GenericTensorNetworks, Graphs

graph = Graphs.smallgraph(:petersen)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">{10, 15} undirected simple Int64 graph</code></pre><p>We can visualize this graph using the <a href="../../ref/#LuxorGraphPlot.show_graph"><code>show_graph</code></a> function</p><pre><code class="language-julia hljs"># set the vertex locations manually instead of using the default spring layout
rot15(a, b, i::Int) = cos(2i*π/5)*a + sin(2i*π/5)*b, cos(2i*π/5)*b - sin(2i*π/5)*a

locations = [[rot15(0.0, 2.0, i) for i=0:4]..., [rot15(0.0, 1.0, i) for i=0:4]...]

show_graph(graph; locs=locations)</code></pre><img src="data:image/png;base64,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" /><p>The graphical display is available in the following editors</p><ul><li>a <a href="https://github.com/julia-vscode/julia-vscode">VSCode</a> editor,</li><li>a <a href="https://github.com/JunoLab/Juno.jl">Jupyter</a> notebook,</li><li>or a <a href="https://github.com/fonsp/Pluto.jl">Pluto</a> notebook,</li></ul><h2 id="Generic-tensor-network-representation"><a class="docs-heading-anchor" href="#Generic-tensor-network-representation">Generic tensor network representation</a><a id="Generic-tensor-network-representation-1"></a><a class="docs-heading-anchor-permalink" href="#Generic-tensor-network-representation" title="Permalink"></a></h2><p>The generic tensor network representation of the independent set problem can be constructed with <a href="../../ref/#GenericTensorNetworks.IndependentSet"><code>IndependentSet</code></a>.</p><pre><code class="language-julia hljs">problem = IndependentSet(graph; optimizer=TreeSA());</code></pre><p>Here, the key word argument <code>optimizer</code> specifies the tensor network contraction order optimizer as a local search based optimizer <a href="../../ref/#OMEinsumContractionOrders.TreeSA"><code>TreeSA</code></a>. The resulting contraction order optimized tensor network is contained in the <code>code</code> field of <code>problem</code>.</p><h3 id="Theory-(can-skip)"><a class="docs-heading-anchor" href="#Theory-(can-skip)">Theory (can skip)</a><a id="Theory-(can-skip)-1"></a><a class="docs-heading-anchor-permalink" href="#Theory-(can-skip)" title="Permalink"></a></h3><p>Let <span>$G=(V, E)$</span> be a graph with each vertex <span>$v\in V$</span> associated with a weight <span>$w_v$</span>. To reduce the independent set problem on it to a tensor network contraction, we first map a vertex <span>$v\in V$</span> to a label <span>$s_v \in \{0, 1\}$</span> of dimension <span>$2$</span>, where we use <span>$0$</span> (<span>$1$</span>) to denote a vertex absent (present) in the set. For each vertex <span>$v$</span>, we defined a parameterized rank-one tensor indexed by <span>$s_v$</span> as</p><p class="math-container">\[W(x_v^{w_v}) = \left(\begin{matrix}
    1 \\
    x_v^{w_v}
    \end{matrix}\right)\]</p><p>where <span>$x_v$</span> is a variable associated with <span>$v$</span>. Similarly, for each edge <span>$(u, v) \in E$</span>, we define a matrix <span>$B$</span> indexed by <span>$s_u$</span> and <span>$s_v$</span> as</p><p class="math-container">\[B = \left(\begin{matrix}
1  &amp; 1\\
1 &amp; 0
\end{matrix}\right).\]</p><p>Ideally, an optimal contraction order has a space complexity <span>$2^{{\rm tw}(G)}$</span>, where <span>${\rm tw(G)}$</span> is the <a href="https://en.wikipedia.org/wiki/Treewidth">tree-width</a> of <span>$G$</span> (or <code>graph</code> in the code). We can check the time, space and read-write complexities by typing</p><pre><code class="language-julia hljs">timespacereadwrite_complexity(problem)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(7.965784284662087, 4.0, 8.661778097771986)</code></pre><p>The three return values are <code>log2</code> values of the the number of element-wise multiplication operations, the number elements in the largest tensor during contraction and the number of tensor element read-write operations. For more information about how to improve the contraction order, please check the <a href="../../performancetips/#Performance-Tips">Performance Tips</a>.</p><h2 id="Solution-space-properties"><a class="docs-heading-anchor" href="#Solution-space-properties">Solution space properties</a><a id="Solution-space-properties-1"></a><a class="docs-heading-anchor-permalink" href="#Solution-space-properties" title="Permalink"></a></h2><h3 id="Maximum-independent-set-size-\\alpha(G)"><a class="docs-heading-anchor" href="#Maximum-independent-set-size-\\alpha(G)">Maximum independent set size <span>$\alpha(G)$</span></a><a id="Maximum-independent-set-size-\\alpha(G)-1"></a><a class="docs-heading-anchor-permalink" href="#Maximum-independent-set-size-\\alpha(G)" title="Permalink"></a></h3><p>We can compute solution space properties with the <a href="../../ref/#GenericTensorNetworks.solve"><code>solve</code></a> function, which takes two positional arguments, the problem instance and the wanted property.</p><pre><code class="language-julia hljs">maximum_independent_set_size = solve(problem, SizeMax())[]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4.0ₜ</code></pre><p>Here <a href="../../ref/#GenericTensorNetworks.SizeMax"><code>SizeMax</code></a> means finding the solution with maximum set size. The return value has <a href="../../ref/#TropicalNumbers.Tropical"><code>Tropical</code></a> type. We can get its content by typing</p><pre><code class="language-julia hljs">maximum_independent_set_size.n</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4.0</code></pre><h3 id="Counting-properties"><a class="docs-heading-anchor" href="#Counting-properties">Counting properties</a><a id="Counting-properties-1"></a><a class="docs-heading-anchor-permalink" href="#Counting-properties" title="Permalink"></a></h3><h5 id="Count-all-solutions-and-best-several-solutions"><a class="docs-heading-anchor" href="#Count-all-solutions-and-best-several-solutions">Count all solutions and best several solutions</a><a id="Count-all-solutions-and-best-several-solutions-1"></a><a class="docs-heading-anchor-permalink" href="#Count-all-solutions-and-best-several-solutions" title="Permalink"></a></h5><p>We can count all independent sets with the <a href="../../ref/#GenericTensorNetworks.CountingAll"><code>CountingAll</code></a> property.</p><pre><code class="language-julia hljs">count_all_independent_sets = solve(problem, CountingAll())[]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">76.0</code></pre><p>The return value has type <code>Float64</code>.</p><p>We can count the maximum independent sets with <a href="../../ref/#GenericTensorNetworks.CountingMax"><code>CountingMax</code></a>.</p><pre><code class="language-julia hljs">count_maximum_independent_sets = solve(problem, CountingMax())[]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(4.0, 5.0)ₜ</code></pre><p>The return value has type <a href="../../ref/#TropicalNumbers.CountingTropical"><code>CountingTropical</code></a>, which contains two fields. They are <code>n</code> being the maximum independent set size and <code>c</code> being the number of the maximum independent sets.</p><pre><code class="language-julia hljs">count_maximum_independent_sets.c</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5.0</code></pre><p>Similarly, we can count independent sets of sizes <span>$\alpha(G)$</span> and <span>$\alpha(G)-1$</span> by feeding an integer positional argument to <a href="../../ref/#GenericTensorNetworks.CountingMax"><code>CountingMax</code></a>.</p><pre><code class="language-julia hljs">count_max2_independent_sets = solve(problem, CountingMax(2))[]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">30.0*x^3 + 5.0*x^4</code></pre><p>The return value has type <a href="../../ref/#GenericTensorNetworks.TruncatedPoly"><code>TruncatedPoly</code></a>, which contains two fields. They are <code>maxorder</code> being the maximum independent set size and <code>coeffs</code> being the number of independent sets having sizes <span>$\alpha(G)-1$</span> and <span>$\alpha(G)$</span>.</p><pre><code class="language-julia hljs">count_max2_independent_sets.coeffs</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(30.0, 5.0)</code></pre><h5 id="Find-the-graph-polynomial"><a class="docs-heading-anchor" href="#Find-the-graph-polynomial">Find the graph polynomial</a><a id="Find-the-graph-polynomial-1"></a><a class="docs-heading-anchor-permalink" href="#Find-the-graph-polynomial" title="Permalink"></a></h5><p>We can count the number of independent sets at any size, which is equivalent to finding the coefficients of an independence polynomial that defined as</p><p class="math-container">\[I(G, x) = \sum_{k=0}^{\alpha(G)} a_k x^k,\]</p><p>where <span>$\alpha(G)$</span> is the maximum independent set size, <span>$a_k$</span> is the number of independent sets of size <span>$k$</span>. The total number of independent sets is thus equal to <span>$I(G, 1)$</span>. There are 3 methods to compute a graph polynomial, <code>:finitefield</code>, <code>:fft</code> and <code>:polynomial</code>. These methods are introduced in the docstring of <a href="../../ref/#GenericTensorNetworks.GraphPolynomial"><code>GraphPolynomial</code></a>.</p><pre><code class="language-julia hljs">independence_polynomial = solve(problem, GraphPolynomial(; method=:finitefield))[]</code></pre>1 &#43; 10&#8729;x &#43; 30&#8729;x<sup>2</sup> &#43; 30&#8729;x<sup>3</sup> &#43; 5&#8729;x<sup>4</sup><p>The return type is <a href="https://juliamath.github.io/Polynomials.jl/stable/polynomials/polynomial/#Polynomial-2"><code>Polynomial</code></a>.</p><pre><code class="language-julia hljs">independence_polynomial.coeffs</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5-element Vector{BigInt}:
  1
 10
 30
 30
  5</code></pre><h3 id="Configuration-properties"><a class="docs-heading-anchor" href="#Configuration-properties">Configuration properties</a><a id="Configuration-properties-1"></a><a class="docs-heading-anchor-permalink" href="#Configuration-properties" title="Permalink"></a></h3><h5 id="Find-one-best-solution"><a class="docs-heading-anchor" href="#Find-one-best-solution">Find one best solution</a><a id="Find-one-best-solution-1"></a><a class="docs-heading-anchor-permalink" href="#Find-one-best-solution" title="Permalink"></a></h5><p>We can use the bounded or unbounded <a href="../../ref/#GenericTensorNetworks.SingleConfigMax"><code>SingleConfigMax</code></a> to find one of the solutions with largest size. The unbounded (default) version uses a joint type of <a href="../../ref/#TropicalNumbers.CountingTropical"><code>CountingTropical</code></a> and <a href="../../ref/#GenericTensorNetworks.ConfigSampler"><code>ConfigSampler</code></a> in computation, where <code>CountingTropical</code> finds the maximum size and <code>ConfigSampler</code> samples one of the best solutions. The bounded version uses the binary gradient back-propagation (see our paper) to compute the gradients. It requires caching intermediate states, but is often faster (on CPU) because it can use <a href="https://github.com/TensorBFS/TropicalGEMM.jl"><code>TropicalGEMM</code></a> (see <a href="../../performancetips/#Performance-Tips">Performance Tips</a>).</p><pre><code class="language-julia hljs">max_config = solve(problem, SingleConfigMax(; bounded=false))[]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(4.0, ConfigSampler{10, 1, 1}(0101010001))ₜ</code></pre><p>The return value has type <a href="../../ref/#TropicalNumbers.CountingTropical"><code>CountingTropical</code></a> with its counting field having <a href="../../ref/#GenericTensorNetworks.ConfigSampler"><code>ConfigSampler</code></a> type. The <code>data</code> field of <a href="../../ref/#GenericTensorNetworks.ConfigSampler"><code>ConfigSampler</code></a> is a bit string that corresponds to the solution</p><pre><code class="language-julia hljs">single_solution = max_config.c.data</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0101010001</code></pre><p>This bit string should be read from left to right, with the i-th bit being 1 (0) to indicate the i-th vertex is present (absent) in the set. We can visualize this MIS with the following function.</p><pre><code class="language-julia hljs">show_graph(graph; locs=locations, vertex_colors=
    [iszero(single_solution[i]) ? &quot;white&quot; : &quot;red&quot; for i=1:nv(graph)])</code></pre><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAVwAAAFRCAYAAAA4iBXyAAAABmJLR0QA/wD/AP+gvaeTAAAgAElEQVR4nO3deXzU1b3/8ReZLJPMmhAWBQRcgLIoLuCGS221Vty9VvGq5fprra1t9XZTW7ertVdLca128aLV4oZVi4p1LVZBFIqKIuLC5oIiSwhZSEKS8/vjJCYkM8lMMjPnO5n38/HIQyTfzPfzDcmZ8z3fz+dzQEREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREclM/1wFIJ/nAocBeQH9gG7AGeAmodRiXeJcPOAgYBQwEqoG12J+ZKndhSUcacL2jLAhXN8J5I6HxACgYDEUVUL8MdrwFRX6YVwk/w/4yiYSKi4t/CVw4dOhQM2nSJN+QIUP8lZWV9W+//faON954w19UVPRCZWXlT4D3XAcr4hVHlcDW78D2j8GYGB8VYK6GhhKoKYDvug5YnDswEAhsPuuss2pXrVplYqmqqjK//e1vG4PBYE1xcfHPXQcs4pwPTo5AzYtxBtqOH++DGQbVJXCV69jFma8GAoHqJ598MuZA29FHH31kRo8eXR0MBm9xHbiIS+MDUL00wcG29eMzMAOgxgcnub4AybgRgUCg8sUXX0xosG1VUVFhhg0bVl1QUPBt1xcg4kQEFv0BmpMZbFs/XgYThI2A3/V1SOZEo9Enr7322h1JjbYtli1bZgKBQCUQdn0dIpl24K5QtaOLQXUFmBCYv8b5/NFQ5YPzXV+IZMzo0tLSmtra2k6D6dNPP2323ntvE41GzR577GFmz54dc9CdNm1abWFh4WWuL0QkowJw0xWwI95gWwFmHJh9uhhw/wamDBa4vhbJjPz8/F/94Ac/qOs4iG7atMmEw2HTuszw4osvmvz8fFNTU9NpwH3hhRdMaWnpO66vRSSjymHZ/DgDaSOYb4D5I5j/7GLA3QKmSLm5OaO8vHz+o48+2mkQbWxsNBs2bPjy/5977jkzfPhw09jY2OnYhoYGk5+f34jN95YM0zfdkQYYNCzO5y4BhgLfA17u4jVKAQMF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CFST2VaTmRYOhUJrb7jhhsZEvy/19fXm1FNPrQ2Hw0/itow7Ef2BSiDgOhCR3ioHKvD+reXekUikZs2aNQkPtq0efPDB5mAw+AnZsWSStEgk8rfzzz9/e7Lfl7q6OjNx4sTqgoKCH7i+hgQ8h23fKZLVvout6PG0SCTy4m233daU9Gjb4qijjqouKCj4sevrSIN9SktLa6qrq3v0fXnzzTdNIBDYCgRdX0g3LsA+5BPJak9jK3q8bEgwGNze0NDQacB45plnzL777mvKy8vNAQccYBYsWBBzYHn55ZdNNBpd5fpCUi0YDP7x2muvjbmU8NBDD5kJEyaY0aNHm3322cfMnTs35vfma1/72jZgmutr6cYg7J2Y33UgIj0VxabceH12890zzjij0xRuzZo1prS01CxcuNAYY8zjjz9uysvLTW1tbadBpampyUQikVrsVj59RigU+nz58uWdrreystIUFBSYd955xxhjzOLFi43f74/5vZk1a5YpLS39u+trScC/UF+NtFIpZ3qdhN28sdp1IF0pLi4eu//++3d6YPLaa6+x5557csghhwBwwgknkJeXx8qVKzu9Rl5eHnvttVc9sGfaA86c/Nra2vIxYzrvKl5QUEA4HGbTpk0AbNy4kdLSUvLzOxcSjh8/nn79+mXD1uSPYHOxRbLS49hKHk8rLS19cNasWZ1mZm+99ZYJBoNm2bJlxhhjHn30UZOfn282bdoU89Z56tSplXh/+SQZA4LBYOcpa4uHH37YFBQUmHA4bIqKisy8efNiHrd69WoTDoe/cH0xCRhC9uSLi+wkiE21KXUdSHeKi4tvnjFjRszB4q677jJjx441EydONEOHDjUXXnhhvPHHTJo0qYK+lZObn5+f39jU1PlZ4ooVK0w0GjWLFi0yxtj0uEgkYmJleSxevNiUlZW95/piEvQqcLTrIESSdSa2gicbfP+cc86piTuSGmMee+wxM3HixJhrlMYY09zcbEpLS2uwTXr6jGAwuPH999/vdL1//vOfzUEHHbTT340bN8488MADnY699957TVlZWbb8LPwcu9GoSFZ5GFvBkw1GRCKRmsbG2Hn9ixcvNoMGDTLvvfde3AF58eLFJhKJfOT6QlItFArdPWPGjE5T3CVLlphwOPzlQ7OlS5eaQCBgVq5c2el7c/zxx1eRPR25RmKbGHmtlaRIXK19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" /><h5 id="Enumerate-all-solutions-and-best-several-solutions"><a class="docs-heading-anchor" href="#Enumerate-all-solutions-and-best-several-solutions">Enumerate all solutions and best several solutions</a><a id="Enumerate-all-solutions-and-best-several-solutions-1"></a><a class="docs-heading-anchor-permalink" href="#Enumerate-all-solutions-and-best-several-solutions" title="Permalink"></a></h5><p>We can use bounded or unbounded <a href="../../ref/#GenericTensorNetworks.ConfigsMax"><code>ConfigsMax</code></a> to find all solutions with largest-K set sizes. In most cases, the bounded (default) version is preferred because it can reduce the memory usage significantly.</p><pre><code class="language-julia hljs">all_max_configs = solve(problem, ConfigsMax(; bounded=true))[]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(4.0, {1001001100, 0100100110, 1010000011, 0010111000, 0101010001})ₜ</code></pre><p>The return value has type <a href="../../ref/#TropicalNumbers.CountingTropical"><code>CountingTropical</code></a>, while its counting field having type <a href="../../ref/#GenericTensorNetworks.ConfigEnumerator"><code>ConfigEnumerator</code></a>. The <code>data</code> field of a <a href="../../ref/#GenericTensorNetworks.ConfigEnumerator"><code>ConfigEnumerator</code></a> instance contains a vector of bit strings.</p><pre><code class="language-julia hljs">all_max_configs.c.data</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5-element Vector{StaticBitVector{10, 1}}:
 1001001100
 0100100110
 1010000011
 0010111000
 0101010001</code></pre><p>These solutions can be visualized with the <a href="../../ref/#LuxorGraphPlot.show_gallery"><code>show_gallery</code></a> function.</p><pre><code class="language-julia hljs">show_gallery(graph, (1, length(all_max_configs.c)); locs=locations, vertex_configs=all_max_configs.c);</code></pre><p>We can use <a href="../../ref/#GenericTensorNetworks.ConfigsAll"><code>ConfigsAll</code></a> to enumerate all sets satisfying the independence constraint.</p><pre><code class="language-julia hljs">all_independent_sets = solve(problem, ConfigsAll())[]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">{0000000000, 0000001000, 0000100000, 0000101000, 1000000000, 1000001000, 0000000100, 0000001100, 0000100100, 0000101100, 1000000100, 1000001100, 0010000000, 0010001000, 0010100000, 0010101000, 1010000000, 1010001000, 0100000000, 0100100000, 0100000100, 0100100100, 0000000001, 1000000001, 0010000001, 1010000001, 0100000001, 0001000000, 0001001000, 1001000000, 1001001000, 0001000100, 0001001100, 1001000100, 1001001100, 0101000000, 0101000100, 0001000001, 1001000001, 0101000001, 0000000010, 0000100010, 1000000010, 0000000110, 0000100110, 1000000110, 0010000010, 0010100010, 1010000010, 0100000010, 0100100010, 0100000110, 0100100110, 0000000011, 1000000011, 0010000011, 1010000011, 0100000011, 0000010000, 0000011000, 0000110000, 0000111000, 0010010000, 0010011000, 0010110000, 0010111000, 0100010000, 0100110000, 0000010001, 0010010001, 0100010001, 0001010000, 0001011000, 0101010000, 0001010001, 0101010001}</code></pre><p>The return value has type <a href="../../ref/#GenericTensorNetworks.ConfigEnumerator"><code>ConfigEnumerator</code></a>.</p><h5 id="Sample-solutions"><a class="docs-heading-anchor" href="#Sample-solutions">Sample solutions</a><a id="Sample-solutions-1"></a><a class="docs-heading-anchor-permalink" href="#Sample-solutions" title="Permalink"></a></h5><p>It is often difficult to store all configurations in a vector. A more clever way to store the data is using the sum product tree format.</p><pre><code class="language-julia hljs">all_independent_sets_tree = solve(problem, ConfigsAll(; tree_storage=true))[]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">+ (count = 76.0)
├─ + (count = 58.0)
│  ├─ + (count = 40.0)
│  │  ├─ + (count = 27.0)
│  │  │  ├─ + (count = 26.0)
│  │  │  │  ├─ + (count = 22.0)
│  │  │  │  │  ⋮
│  │  │  │  │  
│  │  │  │  └─ * (count = 4.0)
│  │  │  │     ⋮
│  │  │  │     
│  │  │  └─ * (count = 1.0)
│  │  │     ├─ OnehotVec{10, 2}(2, 1)
│  │  │     │  ⋮
│  │  │     │  
│  │  │     └─ OnehotVec{10, 2}(10, 1)
│  │  │        ⋮
│  │  │        
│  │  └─ + (count = 13.0)
│  │     ├─ + (count = 12.0)
│  │     │  ├─ + (count = 10.0)
│  │     │  │  ⋮
│  │     │  │  
│  │     │  └─ * (count = 2.0)
│  │     │     ⋮
│  │     │     
│  │     └─ * (count = 1.0)
│  │        ├─ * (count = 1.0)
│  │        │  ⋮
│  │        │  
│  │        └─ OnehotVec{10, 2}(4, 1)
│  │           ⋮
│  │           
│  └─ * (count = 18.0)
│     ├─ + (count = 18.0)
│     │  ├─ + (count = 17.0)
│     │  │  ├─ + (count = 13.0)
│     │  │  │  ⋮
│     │  │  │  
│     │  │  └─ * (count = 4.0)
│     │  │     ⋮
│     │  │     
│     │  └─ * (count = 1.0)
│     │     ├─ OnehotVec{10, 2}(2, 1)
│     │     │  ⋮
│     │     │  
│     │     └─ OnehotVec{10, 2}(10, 1)
│     │        ⋮
│     │        
│     └─ OnehotVec{10, 2}(9, 1)
└─ * (count = 18.0)
   ├─ OnehotVec{10, 2}(6, 1)
   └─ + (count = 18.0)
      ├─ + (count = 13.0)
      │  ├─ + (count = 12.0)
      │  │  ├─ + (count = 10.0)
      │  │  │  ⋮
      │  │  │  
      │  │  └─ * (count = 2.0)
      │  │     ⋮
      │  │     
      │  └─ * (count = 1.0)
      │     ├─ OnehotVec{10, 2}(2, 1)
      │     │  ⋮
      │     │  
      │     └─ OnehotVec{10, 2}(10, 1)
      │        ⋮
      │        
      └─ + (count = 5.0)
         ├─ + (count = 4.0)
         │  ├─ + (count = 3.0)
         │  │  ⋮
         │  │  
         │  └─ * (count = 1.0)
         │     ⋮
         │     
         └─ * (count = 1.0)
            ├─ * (count = 1.0)
            │  ⋮
            │  
            └─ OnehotVec{10, 2}(4, 1)
               ⋮
               
</code></pre><p>The return value has the <a href="../../ref/#GenericTensorNetworks.SumProductTree"><code>SumProductTree</code></a> type. Its length corresponds to the number of configurations.</p><pre><code class="language-julia hljs">length(all_independent_sets_tree)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">76.0</code></pre><p>We can use <code>Base.collect</code> function to create a <a href="../../ref/#GenericTensorNetworks.ConfigEnumerator"><code>ConfigEnumerator</code></a> or use <a href="../../ref/#GenericTensorNetworks.generate_samples"><code>generate_samples</code></a> to generate samples from it.</p><pre><code class="language-julia hljs">collect(all_independent_sets_tree)

generate_samples(all_independent_sets_tree, 10)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">10-element Vector{StaticBitVector{10, 1}}:
 0000000100
 0000000001
 0010000001
 0000000001
 1001001000
 0010100010
 0000100010
 0100100110
 0001011000
 0101010000</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">« Home</a><a class="docs-footer-nextpage" href="../MaximalIS/">Maximal independent set problem »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.19 on <span class="colophon-date" title="Monday 20 June 2022 16:00">Monday 20 June 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
